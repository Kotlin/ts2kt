package typescriptServices

native class Error
native class RegExp

//non standard
native class ITextWriter

native
public trait `T$0` {
    public var error_TS_0_1: String
    public var warning_TS_0_1: String
    public var Unrecognized_escape_sequence: String
    public var Unexpected_character_0: String
    public var Missing_close_quote_character: String
    public var Identifier_expected: String
    public var _0_keyword_expected: String
    public var _0_expected: String
    public var Identifier_expected_0_is_a_keyword: String
    public var Automatic_semicolon_insertion_not_allowed: String
    public var Unexpected_token_0_expected: String
    public var Trailing_separator_not_allowed: String
    public var AsteriskSlash_expected: String
    public var public_or_private_modifier_must_precede_static: String
    public var Unexpected_token: String
    public var Catch_clause_parameter_cannot_have_a_type_annotation: String
    public var Rest_parameter_must_be_last_in_list: String
    public var Parameter_cannot_have_question_mark_and_initializer: String
    public var Required_parameter_cannot_follow_optional_parameter: String
    public var Index_signatures_cannot_have_rest_parameters: String
    public var Index_signature_parameter_cannot_have_accessibility_modifiers: String
    public var Index_signature_parameter_cannot_have_a_question_mark: String
    public var Index_signature_parameter_cannot_have_an_initializer: String
    public var Index_signature_must_have_a_type_annotation: String
    public var Index_signature_parameter_must_have_a_type_annotation: String
    public var Index_signature_parameter_type_must_be_string_or_number: String
    public var extends_clause_already_seen: String
    public var extends_clause_must_precede_implements_clause: String
    public var Classes_can_only_extend_a_single_class: String
    public var implements_clause_already_seen: String
    public var Accessibility_modifier_already_seen: String
    public var _0_modifier_must_precede_1_modifier: String
    public var _0_modifier_already_seen: String
    public var _0_modifier_cannot_appear_on_a_class_element: String
    public var Interface_declaration_cannot_have_implements_clause: String
    public var super_invocation_cannot_have_type_arguments: String
    public var Only_ambient_modules_can_use_quoted_names: String
    public var Statements_are_not_allowed_in_ambient_contexts: String
    public var Implementations_are_not_allowed_in_ambient_contexts: String
    public var declare_modifier_not_allowed_for_code_already_in_an_ambient_context: String
    public var Initializers_are_not_allowed_in_ambient_contexts: String
    public var Parameter_property_declarations_can_only_be_used_in_a_non_ambient_constructor_declaration: String
    public var Function_implementation_expected: String
    public var Constructor_implementation_expected: String
    public var Function_overload_name_must_be_0: String
    public var _0_modifier_cannot_appear_on_a_module_element: String
    public var declare_modifier_cannot_appear_on_an_interface_declaration: String
    public var declare_modifier_required_for_top_level_element: String
    public var Rest_parameter_cannot_be_optional: String
    public var Rest_parameter_cannot_have_an_initializer: String
    public var set_accessor_must_have_one_and_only_one_parameter: String
    public var set_accessor_parameter_cannot_be_optional: String
    public var set_accessor_parameter_cannot_have_an_initializer: String
    public var set_accessor_cannot_have_rest_parameter: String
    public var get_accessor_cannot_have_parameters: String
    public var Modifiers_cannot_appear_here: String
    public var Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: String
    public var Class_name_cannot_be_0: String
    public var Interface_name_cannot_be_0: String
    public var Enum_name_cannot_be_0: String
    public var Module_name_cannot_be_0: String
    public var Enum_member_must_have_initializer: String
    public var Export_assignment_cannot_be_used_in_internal_modules: String
    public var Export_assignment_not_allowed_in_module_with_exported_element: String
    public var Module_cannot_have_multiple_export_assignments: String
    public var Ambient_enum_elements_can_only_have_integer_literal_initializers: String
    public var module_class_interface_enum_import_or_statement: String
    public var constructor_function_accessor_or_variable: String
    public var statement: String
    public var case_or_default_clause: String
    public var identifier: String
    public var call_construct_index_property_or_function_signature: String
    public var expression: String
    public var type_name: String
    public var property_or_accessor: String
    public var parameter: String
    public var `type`: String
    public var type_parameter: String
    public var declare_modifier_not_allowed_on_import_declaration: String
    public var Function_overload_must_be_static: String
    public var Function_overload_must_not_be_static: String
    public var Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: String
    public var Invalid_reference_directive_syntax: String
    public var Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: String
    public var Accessors_are_not_allowed_in_ambient_contexts: String
    public var _0_modifier_cannot_appear_on_a_constructor_declaration: String
    public var _0_modifier_cannot_appear_on_a_parameter: String
    public var Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: String
    public var Type_parameters_cannot_appear_on_a_constructor_declaration: String
    public var Type_annotation_cannot_appear_on_a_constructor_declaration: String
    public var Duplicate_identifier_0: String
    public var The_name_0_does_not_exist_in_the_current_scope: String
    public var The_name_0_does_not_refer_to_a_value: String
    public var super_can_only_be_used_inside_a_class_instance_method: String
    public var The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: String
    public var Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: String
    public var Value_of_type_0_is_not_callable: String
    public var Value_of_type_0_is_not_newable: String
    public var Value_of_type_0_is_not_indexable_by_type_1: String
    public var Operator_0_cannot_be_applied_to_types_1_and_2: String
    public var Operator_0_cannot_be_applied_to_types_1_and_2_3: String
    public var Cannot_convert_0_to_1: String
    public var Cannot_convert_0_to_1_NL_2: String
    public var Expected_var_class_interface_or_module: String
    public var Operator_0_cannot_be_applied_to_type_1: String
    public var Getter_0_already_declared: String
    public var Setter_0_already_declared: String
    public var Exported_class_0_extends_private_class_1: String
    public var Exported_class_0_implements_private_interface_1: String
    public var Exported_interface_0_extends_private_interface_1: String
    public var Exported_class_0_extends_class_from_inaccessible_module_1: String
    public var Exported_class_0_implements_interface_from_inaccessible_module_1: String
    public var Exported_interface_0_extends_interface_from_inaccessible_module_1: String
    public var Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: String
    public var Public_property_0_of_exported_class_has_or_is_using_private_type_1: String
    public var Property_0_of_exported_interface_has_or_is_using_private_type_1: String
    public var Exported_variable_0_has_or_is_using_private_type_1: String
    public var Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: String
    public var Public_property_0_of_exported_class_is_using_inaccessible_module_1: String
    public var Property_0_of_exported_interface_is_using_inaccessible_module_1: String
    public var Exported_variable_0_is_using_inaccessible_module_1: String
    public var Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: String
    public var Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: String
    public var Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: String
    public var Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: String
    public var Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: String
    public var Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: String
    public var Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: String
    public var Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: String
    public var Parameter_0_of_exported_function_has_or_is_using_private_type_1: String
    public var Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: String
    public var Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: String
    public var Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: String
    public var Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: String
    public var Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: String
    public var Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: String
    public var Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: String
    public var Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: String
    public var Parameter_0_of_exported_function_is_using_inaccessible_module_1: String
    public var Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: String
    public var Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: String
    public var Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: String
    public var Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: String
    public var Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: String
    public var Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: String
    public var Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: String
    public var Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: String
    public var Return_type_of_exported_function_has_or_is_using_private_type_0: String
    public var Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: String
    public var Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: String
    public var Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: String
    public var Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: String
    public var Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: String
    public var Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: String
    public var Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: String
    public var Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: String
    public var Return_type_of_exported_function_is_using_inaccessible_module_0: String
    public var new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: String
    public var A_parameter_list_must_follow_a_generic_type_argument_list_expected: String
    public var Multiple_constructor_implementations_are_not_allowed: String
    public var Unable_to_resolve_external_module_0: String
    public var Module_cannot_be_aliased_to_a_non_module_type: String
    public var A_class_may_only_extend_another_class: String
    public var A_class_may_only_implement_another_class_or_interface: String
    public var An_interface_may_only_extend_another_class_or_interface: String
    public var Unable_to_resolve_type: String
    public var Unable_to_resolve_type_of_0: String
    public var Unable_to_resolve_type_parameter_constraint: String
    public var Type_parameter_constraint_cannot_be_a_primitive_type: String
    public var Supplied_parameters_do_not_match_any_signature_of_call_target: String
    public var Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: String
    public var Invalid_new_expression: String
    public var Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: String
    public var Could_not_select_overload_for_new_expression: String
    public var Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: String
    public var Could_not_select_overload_for_call_expression: String
    public var Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: String
    public var Calls_to_super_are_only_valid_inside_a_class: String
    public var Generic_type_0_requires_1_type_argument_s: String
    public var Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: String
    public var Could_not_find_enclosing_symbol_for_dotted_name_0: String
    public var The_property_0_does_not_exist_on_value_of_type_1: String
    public var Could_not_find_symbol_0: String
    public var get_and_set_accessor_must_have_the_same_type: String
    public var this_cannot_be_referenced_in_current_location: String
    public var Static_members_cannot_reference_class_type_parameters: String
    public var Class_0_is_recursively_referenced_as_a_base_type_of_itself: String
    public var Interface_0_is_recursively_referenced_as_a_base_type_of_itself: String
    public var super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: String
    public var super_cannot_be_referenced_in_non_derived_classes: String
    public var A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: String
    public var Constructors_for_derived_classes_must_contain_a_super_call: String
    public var Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: String
    public var _0_1_is_inaccessible: String
    public var this_cannot_be_referenced_within_module_bodies: String
    public var Invalid_expression_types_not_known_to_support_the_addition_operator: String
    public var The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: String
    public var The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: String
    public var The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: String
    public var Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: String
    public var Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: String
    public var The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: String
    public var The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: String
    public var The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: String
    public var The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: String
    public var The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: String
    public var Setters_cannot_return_a_value: String
    public var Tried_to_query_type_of_uninitialized_module_0: String
    public var Tried_to_set_variable_type_to_uninitialized_module_type_0: String
    public var Type_0_does_not_have_type_parameters: String
    public var Getters_must_return_a_value: String
    public var Getter_and_setter_accessors_do_not_agree_in_visibility: String
    public var Invalid_left_hand_side_of_assignment_expression: String
    public var Function_declared_a_non_void_return_type_but_has_no_return_expression: String
    public var Cannot_resolve_return_type_reference: String
    public var Constructors_cannot_have_a_return_type_of_void: String
    public var Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: String
    public var All_symbols_within_a_with_block_will_be_resolved_to_any: String
    public var Import_declarations_in_an_internal_module_cannot_reference_an_external_module: String
    public var Class_0_declares_interface_1_but_does_not_implement_it_NL_2: String
    public var Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: String
    public var The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: String
    public var this_cannot_be_referenced_in_static_initializers_in_a_class_body: String
    public var Class_0_cannot_extend_class_1_NL_2: String
    public var Interface_0_cannot_extend_class_1_NL_2: String
    public var Interface_0_cannot_extend_interface_1_NL_2: String
    public var Duplicate_overload_signature_for_0: String
    public var Duplicate_constructor_overload_signature: String
    public var Duplicate_overload_call_signature: String
    public var Duplicate_overload_construct_signature: String
    public var Overload_signature_is_not_compatible_with_function_definition: String
    public var Overload_signature_is_not_compatible_with_function_definition_NL_0: String
    public var Overload_signatures_must_all_be_public_or_private: String
    public var Overload_signatures_must_all_be_exported_or_not_exported: String
    public var Overload_signatures_must_all_be_ambient_or_non_ambient: String
    public var Overload_signatures_must_all_be_optional_or_required: String
    public var Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: String
    public var this_cannot_be_referenced_in_constructor_arguments: String
    public var Instance_member_cannot_be_accessed_off_a_class: String
    public var Untyped_function_calls_may_not_accept_type_arguments: String
    public var Non_generic_functions_may_not_accept_type_arguments: String
    public var A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: String
    public var Rest_parameters_must_be_array_types: String
    public var Overload_signature_implementation_cannot_use_specialized_type: String
    public var Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: String
    public var Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: String
    public var Only_public_methods_of_the_base_class_are_accessible_via_the_super_keyword: String
    public var Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1: String
    public var Numeric_indexer_type_0_must_be_assignable_to_string_indexer_type_1_NL_2: String
    public var All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0: String
    public var All_numerically_named_properties_must_be_assignable_to_numeric_indexer_type_0_NL_1: String
    public var All_named_properties_must_be_assignable_to_string_indexer_type_0: String
    public var All_named_properties_must_be_assignable_to_string_indexer_type_0_NL_1: String
    public var Generic_type_references_must_include_all_type_arguments: String
    public var Default_arguments_are_only_allowed_in_implementation: String
    public var Overloads_cannot_differ_only_by_return_type: String
    public var Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: String
    public var Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: String
    public var Could_not_find_symbol_0_in_module_1: String
    public var Unable_to_resolve_module_reference_0: String
    public var Could_not_find_module_0_in_module_1: String
    public var Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: String
    public var Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: String
    public var Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: String
    public var Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: String
    public var Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: String
    public var Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_1: String
    public var Internal_module_reference_0_in_import_declaration_does_not_reference_module_instance_for_1: String
    public var Module_0_cannot_merge_with_previous_declaration_of_1_in_a_different_file_2: String
    public var Interface_0_cannot_simultaneously_extend_types_1_and_2_NL_3: String
    public var Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: String
    public var Ambient_external_module_declaration_cannot_be_reopened: String
    public var All_declarations_of_merged_declaration_0_must_be_exported_or_not_exported: String
    public var super_cannot_be_referenced_in_constructor_arguments: String
    public var Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: String
    public var Ambient_external_module_declaration_must_be_defined_in_global_context: String
    public var Ambient_external_module_declaration_cannot_specify_relative_module_name: String
    public var Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: String
    public var Could_not_find_the_best_common_type_of_types_of_all_return_statement_expressions: String
    public var Import_declaration_cannot_refer_to_external_module_reference_when_noResolve_option_is_set: String
    public var Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: String
    public var continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: String
    public var break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: String
    public var Jump_target_not_found: String
    public var Jump_target_cannot_cross_function_boundary: String
    public var Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: String
    public var Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: String
    public var Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: String
    public var TypeParameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_exported_function_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_exported_function_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_exported_class_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_exported_interface_has_or_is_using_private_type_1: String
    public var TypeParameter_0_of_exported_class_is_using_inaccessible_module_1: String
    public var TypeParameter_0_of_exported_interface_is_using_inaccessible_module_1: String
    public var Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: String
    public var Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: String
    public var Type_of_conditional_0_must_be_identical_to_1_or_2: String
    public var Type_of_conditional_0_must_be_identical_to_1_2_or_3: String
    public var Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: String
    public var Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: String
    public var Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: String
    public var Parameter_0_cannot_be_referenced_in_its_initializer: String
    public var Duplicate_string_index_signature: String
    public var Duplicate_number_index_signature: String
    public var All_declarations_of_an_interface_must_have_identical_type_parameters: String
    public var Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: String
    public var Type_0_is_missing_property_1_from_type_2: String
    public var Types_of_property_0_of_types_1_and_2_are_incompatible: String
    public var Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: String
    public var Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: String
    public var Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: String
    public var Types_0_and_1_define_property_2_as_private: String
    public var Call_signatures_of_types_0_and_1_are_incompatible: String
    public var Call_signatures_of_types_0_and_1_are_incompatible_NL_2: String
    public var Type_0_requires_a_call_signature_but_type_1_lacks_one: String
    public var Construct_signatures_of_types_0_and_1_are_incompatible: String
    public var Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: String
    public var Type_0_requires_a_construct_signature_but_type_1_lacks_one: String
    public var Index_signatures_of_types_0_and_1_are_incompatible: String
    public var Index_signatures_of_types_0_and_1_are_incompatible_NL_2: String
    public var Call_signature_expects_0_or_fewer_parameters: String
    public var Could_not_apply_type_0_to_argument_1_which_is_of_type_2: String
    public var Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: String
    public var Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: String
    public var Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: String
    public var Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: String
    public var Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: String
    public var Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: String
    public var Type_reference_cannot_refer_to_container_0: String
    public var Type_reference_must_refer_to_type: String
    public var In_enums_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_the_first_enum_element: String
    public var _0_overload_s: String
    public var Variable_declaration_cannot_have_the_same_name_as_an_import_declaration: String
    public var Signature_expected_0_type_arguments_got_1_instead: String
    public var Property_0_defined_as_optional_in_type_1_but_is_required_in_type_2: String
    public var Types_0_and_1_originating_in_infinitely_expanding_type_reference_do_not_refer_to_same_named_type: String
    public var Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments: String
    public var Types_0_and_1_originating_in_infinitely_expanding_type_reference_have_incompatible_type_arguments_NL_2: String
    public var Named_properties_0_of_types_1_and_2_are_not_identical: String
    public var Types_of_string_indexer_of_types_0_and_1_are_not_identical: String
    public var Types_of_number_indexer_of_types_0_and_1_are_not_identical: String
    public var Type_of_number_indexer_in_type_0_is_not_assignable_to_string_indexer_type_in_type_1_NL_2: String
    public var Type_of_property_0_in_type_1_is_not_assignable_to_string_indexer_type_in_type_2_NL_3: String
    public var Type_of_property_0_in_type_1_is_not_assignable_to_number_indexer_type_in_type_2_NL_3: String
    public var Static_property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: String
    public var Static_property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: String
    public var Types_0_and_1_define_static_property_2_as_private: String
    public var Current_host_does_not_support_0_option: String
    public var ECMAScript_target_version_0_not_supported_Specify_a_valid_target_version_1_default_or_2: String
    public var Module_code_generation_0_not_supported: String
    public var Could_not_find_file_0: String
    public var A_file_cannot_have_a_reference_to_itself: String
    public var Cannot_resolve_referenced_file_0: String
    public var Cannot_find_the_common_subdirectory_path_for_the_input_files: String
    public var Emit_Error_0: String
    public var Cannot_read_file_0_1: String
    public var Unsupported_file_encoding: String
    public var Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: String
    public var Unsupported_locale_0: String
    public var Execution_Failed_NL: String
    public var Invalid_call_to_up: String
    public var Invalid_call_to_down: String
    public var Base64_value_0_finished_with_a_continuation_bit: String
    public var Unknown_option_0: String
    public var Expected_0_arguments_to_message_got_1_instead: String
    public var Expected_the_message_0_to_have_1_arguments_but_it_had_2: String
    public var Could_not_delete_file_0: String
    public var Could_not_create_directory_0: String
    public var Error_while_executing_file_0: String
    public var Cannot_compile_external_modules_unless_the_module_flag_is_provided: String
    public var Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: String
    public var Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: String
    public var Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: String
    public var Option_0_specified_without_1: String
    public var codepage_option_not_supported_on_current_platform: String
    public var Concatenate_and_emit_output_to_single_file: String
    public var Generates_corresponding_0_file: String
    public var Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: String
    public var Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: String
    public var Watch_input_files: String
    public var Redirect_output_structure_to_the_directory: String
    public var Do_not_emit_comments_to_output: String
    public var Skip_resolution_and_preprocessing: String
    public var Specify_ECMAScript_target_version_0_default_or_1: String
    public var Specify_module_code_generation_0_or_1: String
    public var Print_this_message: String
    public var Print_the_compiler_s_version_0: String
    public var Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: String
    public var Specify_locale_for_errors_and_messages_For_example_0_or_1: String
    public var Syntax_0: String
    public var options: String
    public var file1: String
    public var Examples: String
    public var Options: String
    public var Insert_command_line_options_and_files_from_a_file: String
    public var Version_0: String
    public var Use_the_0_flag_to_see_options: String
    public var NL_Recompiling_0: String
    public var STRING: String
    public var KIND: String
    public var file2: String
    public var VERSION: String
    public var LOCATION: String
    public var DIRECTORY: String
    public var NUMBER: String
    public var Specify_the_codepage_to_use_when_opening_source_files: String
    public var Additional_locations: String
    public var This_version_of_the_Javascript_runtime_does_not_support_the_0_function: String
    public var Unknown_rule: String
    public var Invalid_line_number_0: String
    public var Warn_on_expressions_and_declarations_with_an_implied_any_type: String
    public var Variable_0_implicitly_has_an_any_type: String
    public var Parameter_0_of_1_implicitly_has_an_any_type: String
    public var Parameter_0_of_function_type_implicitly_has_an_any_type: String
    public var Member_0_of_object_type_implicitly_has_an_any_type: String
    public var new_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: String
    public var _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: String
    public var Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: String
    public var Parameter_0_of_lambda_function_implicitly_has_an_any_type: String
    public var Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: String
    public var Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: String
    public var Array_Literal_implicitly_has_an_any_type_from_widening: String
    public var _0_which_lacks_get_accessor_and_parameter_type_annotation_on_set_accessor_implicitly_has_an_any_type: String
    public var Index_signature_of_object_type_implicitly_has_an_any_type: String
    public var Object_literal_s_property_0_implicitly_has_an_any_type_from_widening: String
}
module("typescript-services")
public object TypeScript {
    public var DiagnosticCode: `T$0` = noImpl
    public open class ArrayUtilities {
        public class object {
            public fun isArray(value: Any): Boolean = noImpl
            public fun sequenceEquals<T>(array1: Array<T>, array2: Array<T>, equals: (v1: T, v2: T) -> Boolean): Boolean = noImpl
            public fun contains<T>(array: Array<T>, value: T): Boolean = noImpl
            public fun groupBy<T>(array: Array<T>, func: (v: T) -> String): Any = noImpl
            public fun distinct<T>(array: Array<T>, equalsFn: ((a: T, b: T) -> Boolean)? = null): Array<T> = noImpl
            public fun min<T>(array: Array<T>, func: (v: T) -> Number): Number = noImpl
            public fun max<T>(array: Array<T>, func: (v: T) -> Number): Number = noImpl
            public fun last<T>(array: Array<T>): T = noImpl
            public fun lastOrDefault<T>(array: Array<T>, predicate: (v: T, index: Number) -> Boolean): T = noImpl
            public fun firstOrDefault<T>(array: Array<T>, func: (v: T, index: Number) -> Boolean): T = noImpl
            public fun first<T>(array: Array<T>, func: ((v: T, index: Number) -> Boolean)? = null): T = noImpl
            public fun sum<T>(array: Array<T>, func: (v: T) -> Number): Number = noImpl
            public fun select<T, S>(values: Array<T>, func: (v: T) -> S): Array<S> = noImpl
            public fun where<T>(values: Array<T>, func: (v: T) -> Boolean): Array<T> = noImpl
            public fun any<T>(array: Array<T>, func: (v: T) -> Boolean): Boolean = noImpl
            public fun all<T>(array: Array<T>, func: (v: T) -> Boolean): Boolean = noImpl
            public fun binarySearch(array: Array<Number>, value: Number): Number = noImpl
            public fun createArray<T>(length: Number, defaultValue: Any): Array<T> = noImpl
            public fun grow<T>(array: Array<T>, length: Number, defaultValue: T): Unit = noImpl
            public fun copy<T>(sourceArray: Array<T>, sourceIndex: Number, destinationArray: Array<T>, destinationIndex: Number, length: Number): Unit = noImpl
            public fun indexOf<T>(array: Array<T>, predicate: (v: T) -> Boolean): Number = noImpl
        }
    }
    public trait IBitVector {
        public fun valueAt(index: Number): Boolean
        public fun setValueAt(index: Number, value: Boolean)
        public fun release()
    }
    module
    public object BitVector {
        public fun getBitVector(allowUndefinedValues: Boolean): IBitVector = noImpl
    }
    public trait IBitMatrix {
        public fun valueAt(x: Number, y: Number): Boolean
        public fun setValueAt(x: Number, y: Number, value: Boolean)
        public fun release()
    }
    module
    public object BitMatrix {
        public fun getBitMatrix(allowUndefinedValues: Boolean): IBitMatrix = noImpl
    }

    enum class AssertionLevel

    public open class Debug {
        public class object {
            public var currentAssertionLevel: Any = noImpl
            public fun shouldAssert(level: AssertionLevel): Boolean = noImpl
            public fun assert(expression: Any, message: String? = null, verboseDebugInfo: (() -> String)? = null): Unit = noImpl
            public fun fail(message: String? = null): Unit = noImpl
        }
    }
    public var LocalizedDiagnosticMessages: IIndexable<Any> = noImpl
    public open class Location(fileName: String, lineMap: LineMap, start: Number, length: Number) {
        public open var _fileName: Any = noImpl
        public open var _lineMap: Any = noImpl
        public open var _start: Any = noImpl
        public open var _length: Any = noImpl
        public open fun fileName(): String = noImpl
        public open fun lineMap(): LineMap = noImpl
        public open fun line(): Number = noImpl
        public open fun character(): Number = noImpl
        public open fun start(): Number = noImpl
        public open fun length(): Number = noImpl
        public class object {
            public fun equals(location1: Location, location2: Location): Boolean = noImpl
        }
    }
    public open class Diagnostic(fileName: String, lineMap: LineMap, start: Number, length: Number, diagnosticKey: String, _arguments: Array<Any>? = null, additionalLocations: Array<Location>? = null) : Location() {
        public open var _diagnosticKey: Any = noImpl
        public open var _arguments: Any = noImpl
        public open var _additionalLocations: Any = noImpl
        public open fun toJSON(key: Any): Any = noImpl
        public open fun diagnosticKey(): String = noImpl
        public open fun arguments(): Array<Any> = noImpl
        public open fun text(): String = noImpl
        public open fun message(): String = noImpl
        public open fun additionalLocations(): Array<Location> = noImpl
        public open fun info(): DiagnosticInfo = noImpl
        public class object {
            public fun equals(diagnostic1: Diagnostic, diagnostic2: Diagnostic): Boolean = noImpl
        }
    }
    public fun newLine(): String = noImpl
    public fun getLocalizedText(diagnosticKey: String, args: Array<Any>): String = noImpl
    public fun getDiagnosticMessage(diagnosticKey: String, args: Array<Any>): String = noImpl
    public trait DiagnosticInfo {
        public var category: DiagnosticCategory
        public var message: String
        public var code: Number
    }
    public open class Errors {
        public class object {
            public fun argument(argument: String, message: String? = null): Error = noImpl
            public fun argumentOutOfRange(argument: String): Error = noImpl
            public fun argumentNull(argument: String): Error = noImpl
            public fun abstract(): Error = noImpl
            public fun notYetImplemented(): Error = noImpl
            public fun invalidOperation(message: String? = null): Error = noImpl
        }
    }
    public open class Hash {
        public class object {
            public var FNV_BASE: Any = noImpl
            public var FNV_PRIME: Any = noImpl
            public fun computeFnv1aCharArrayHashCode(text: Any, start: Any, len: Any): Unit = noImpl
            public fun computeSimple31BitCharArrayHashCode(key: Array<Number>, start: Number, len: Number): Number = noImpl
            public fun computeSimple31BitStringHashCode(key: String): Number = noImpl
            public fun computeMurmur2StringHashCode(key: String, seed: Number): Number = noImpl
            public var primes: Any = noImpl
            public fun getPrime(min: Number): Number = noImpl
            public fun expandPrime(oldSize: Number): Number = noImpl
            public fun combine(value: Number, currentHash: Number): Number = noImpl
        }
    }
    module
    public object Collections {
        public var DefaultHashTableCapacity: Number = noImpl
        public open class HashTable<TKey, TValue>(capacity: Number, hash: (k: TKey) -> Number) {
            public open var hash: Any = noImpl
            public open var entries: Any = noImpl
            public open var count: Any = noImpl
            public open fun set(key: TKey, value: TValue): Unit = noImpl
            public open fun add(key: TKey, value: TValue): Unit = noImpl
            public open fun containsKey(key: TKey): Boolean = noImpl
            public open fun get(key: TKey): TValue = noImpl
            public open fun computeHashCode(key: Any): Unit = noImpl
            public open fun addOrSet(key: Any, value: Any, throwOnExistingEntry: Any): Unit = noImpl
            public open fun findEntry(key: Any, hashCode: Any): Unit = noImpl
            public open fun addEntry(key: Any, value: Any, hashCode: Any): Unit = noImpl
            public open fun grow(): Unit = noImpl
        }
        public fun createHashTable<TKey, TValue>(capacity: Number? = null, hash: ((k: TKey) -> Number)? = null): HashTable<TKey, TValue> = noImpl
        public fun identityHashCode(value: Any): Number = noImpl
        public var DefaultStringTableCapacity: Number = noImpl
        public open class StringTable(capacity: Number) {
            public open var entries: Any = noImpl
            public open var count: Any = noImpl
            public open fun addCharArray(key: Array<Number>, start: Number, len: Number): String = noImpl
            public open fun findCharArrayEntry(key: Any, start: Any, len: Any, hashCode: Any): Unit = noImpl
            public open fun addEntry(text: Any, hashCode: Any): Unit = noImpl
            public open fun grow(): Unit = noImpl
            public class object {
                public fun textCharArrayEquals(text: Any, array: Any, start: Any, length: Any): Unit = noImpl
            }
        }
        public var DefaultStringTable: StringTable = noImpl
    }
    public var nodeMakeDirectoryTime: Number = noImpl
    public var nodeCreateBufferTime: Number = noImpl
    public var nodeWriteFileSyncTime: Number = noImpl

    enum class ByteOrderMark

    public open class FileInformation(contents: String, byteOrderMark: ByteOrderMark) {
        public open var contents: String = noImpl
        public open var byteOrderMark: ByteOrderMark = noImpl
    }
    public trait IEnvironment {
        public fun supportsCodePage(): Boolean
        public fun readFile(path: String, codepage: Number): FileInformation
        public fun writeFile(path: String, contents: String, writeByteOrderMark: Boolean)
        public fun deleteFile(path: String)
        public fun fileExists(path: String): Boolean
        public fun directoryExists(path: String): Boolean
        public fun listFiles(path: String, re: RegExp? = null, options: `T$1`? = null): Array<String>
        public var arguments: Array<String>
        public var standardOut: ITextWriter
        public fun currentDirectory(): String
        public var newLine: String
    }
    public var Environment: IEnvironment = noImpl
    public trait IIndexable<T> {
        public fun get(s: String): T
        public fun set(s: String, value: T)
    }
    module
    public object IntegerUtilities {
        public fun integerDivide(numerator: Number, denominator: Number): Number = noImpl
        public fun integerMultiplyLow32Bits(n1: Number, n2: Number): Number = noImpl
        public fun integerMultiplyHigh32Bits(n1: Number, n2: Number): Number = noImpl
        public fun isInteger(text: String): Boolean = noImpl
        public fun isHexInteger(text: String): Boolean = noImpl
    }
    public trait Iterator<T> {
        public fun moveNext(): Boolean
        public fun current(): T
    }
    public trait ILineAndCharacter {
        public var line: Number
        public var character: Number
    }
    public open class LineMap(_computeLineStarts: () -> Array<Number>, length: Number) {
        public open var _computeLineStarts: Any = noImpl
        public open var length: Any = noImpl
        public open var _lineStarts: Any = noImpl
        public open fun toJSON(key: Any): `T$2` = noImpl
        public open fun equals(other: LineMap): Boolean = noImpl
        public open fun lineStarts(): Array<Number> = noImpl
        public open fun lineCount(): Number = noImpl
        public open fun getPosition(line: Number, character: Number): Number = noImpl
        public open fun getLineNumberFromPosition(position: Number): Number = noImpl
        public open fun getLineStartPosition(lineNumber: Number): Number = noImpl
        public open fun fillLineAndCharacterFromPosition(position: Number, lineAndCharacter: ILineAndCharacter): Unit = noImpl
        public open fun getLineAndCharacterFromPosition(position: Number): LineAndCharacter = noImpl
        public class object {
            public var empty: LineMap = noImpl
        }
    }
    public open class LineAndCharacter(line: Number, character: Number) {
        public open var _line: Any = noImpl
        public open var _character: Any = noImpl
        public open fun line(): Number = noImpl
        public open fun character(): Number = noImpl
    }
    public open class MathPrototype {
        public class object {
            public fun max(a: Number, b: Number): Number = noImpl
            public fun min(a: Number, b: Number): Number = noImpl
        }
    }
    public open class StringUtilities {
        public class object {
            public fun isString(value: Any): Boolean = noImpl
            public fun fromCharCodeArray(array: Array<Number>): String = noImpl
            public fun endsWith(string: String, value: String): Boolean = noImpl
            public fun startsWith(string: String, value: String): Boolean = noImpl
            public fun copyTo(source: String, sourceIndex: Number, destination: Array<Number>, destinationIndex: Number, count: Number): Unit = noImpl
            public fun repeat(value: String, count: Number): String = noImpl
            public fun stringEquals(val1: String, val2: String): Boolean = noImpl
        }
    }
    public open class Timer {
        public open var startTime: Number = noImpl
        public open var time: Number = noImpl
        public open fun start(): Unit = noImpl
        public open fun end(): Unit = noImpl
    }
    public var diagnosticInformationMap: IIndexable<Any> = noImpl
    public trait IScriptSnapshot {
        public fun getText(start: Number, end: Number): String
        public fun getLength(): Number
        public fun getLineStartPositions(): Array<Number>
        public fun getTextChangeRangeSinceVersion(scriptVersion: Number): TextChangeRange
    }
    module
    public object ScriptSnapshot {
        public fun fromString(text: String): IScriptSnapshot = noImpl
    }
    public trait ISimpleText {
        public fun length(): Number
        public fun copyTo(sourceIndex: Number, destination: Array<Number>, destinationIndex: Number, count: Number)
        public fun substr(start: Number, length: Number, intern: Boolean): String
        public fun subText(span: TextSpan): ISimpleText
        public fun charCodeAt(index: Number): Number
        public fun lineMap(): LineMap
    }
    public trait IText : ISimpleText {
        public fun lineCount(): Number
        public fun lines(): Array<ITextLine>
        override fun charCodeAt(position: Number): Number
        public fun getLineFromLineNumber(lineNumber: Number): ITextLine
        public fun getLineFromPosition(position: Number): ITextLine
        public fun getLineNumberFromPosition(position: Number): Number
        public fun getLinePosition(position: Number): LineAndCharacter
        public fun toString(span: TextSpan? = null): String
    }
    public trait ITextLine {
        public fun start(): Number
        public fun end(): Number
        public fun endIncludingLineBreak(): Number
        public fun extent(): TextSpan
        public fun extentIncludingLineBreak(): TextSpan
        override fun toString(): String
        public fun lineNumber(): Number
    }
    module
    public object LineMap1 {
        public fun fromSimpleText(text: ISimpleText): LineMap = noImpl
        public fun fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): LineMap = noImpl
        public fun fromString(text: String): LineMap = noImpl
    }
    module
    public object TextFactory {
        public fun createText(value: String): IText = noImpl
    }
    module
    public object SimpleText {
        public fun fromString(value: String): ISimpleText = noImpl
        public fun fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): ISimpleText = noImpl
    }
    module
    public object TextUtilities {
        public trait ICharacterSequence {
            public fun charCodeAt(index: Number): Number
            public var length: Number
        }
        public fun parseLineStarts(text: ICharacterSequence): Array<Number> = noImpl
        public fun getLengthOfLineBreakSlow(text: ICharacterSequence, index: Number, c: Number): Number = noImpl
        public fun getLengthOfLineBreak(text: ICharacterSequence, index: Number): Number = noImpl
        public fun isAnyLineBreakCharacter(c: Number): Boolean = noImpl
    }
    public open class TextSpan(start: Number, length: Number) {
        public open var _start: Any = noImpl
        public open var _length: Any = noImpl
        public open fun start(): Number = noImpl
        public open fun length(): Number = noImpl
        public open fun end(): Number = noImpl
        public open fun isEmpty(): Boolean = noImpl
        public open fun containsPosition(position: Number): Boolean = noImpl
        public open fun containsTextSpan(span: TextSpan): Boolean = noImpl
        public open fun overlapsWith(span: TextSpan): Boolean = noImpl
        public open fun overlap(span: TextSpan): TextSpan = noImpl
        public open fun intersectsWithTextSpan(span: TextSpan): Boolean = noImpl
        public open fun intersectsWith(start: Number, length: Number): Boolean = noImpl
        public open fun intersectsWithPosition(position: Number): Boolean = noImpl
        public open fun intersection(span: TextSpan): TextSpan = noImpl
        public class object {
            public fun fromBounds(start: Number, end: Number): TextSpan = noImpl
        }
    }
    public open class TextChangeRange(span: TextSpan, newLength: Number) {
        public open var _span: Any = noImpl
        public open var _newLength: Any = noImpl
        public open fun span(): TextSpan = noImpl
        public open fun newLength(): Number = noImpl
        public open fun newSpan(): TextSpan = noImpl
        public open fun isUnchanged(): Boolean = noImpl
        public class object {
            public var unchanged: TextChangeRange = noImpl
            public fun collapseChangesFromSingleVersion(changes: Array<TextChangeRange>): TextChangeRange = noImpl
            public fun collapseChangesAcrossMultipleVersions(changes: Array<TextChangeRange>): TextChangeRange = noImpl
        }
    }
    public open class CharacterInfo {
        public class object {
            public fun isDecimalDigit(c: Number): Boolean = noImpl
            public fun isOctalDigit(c: Number): Boolean = noImpl
            public fun isHexDigit(c: Number): Boolean = noImpl
            public fun hexValue(c: Number): Number = noImpl
            public fun isWhitespace(ch: Number): Boolean = noImpl
            public fun isLineTerminator(ch: Number): Boolean = noImpl
        }
    }
    module
    public object Indentation {
        public fun columnForEndOfToken(token: ISyntaxToken, syntaxInformationMap: SyntaxInformationMap, options: FormattingOptions): Number = noImpl
        public fun columnForStartOfToken(token: ISyntaxToken, syntaxInformationMap: SyntaxInformationMap, options: FormattingOptions): Number = noImpl
        public fun columnForStartOfFirstTokenInLineContainingToken(token: ISyntaxToken, syntaxInformationMap: SyntaxInformationMap, options: FormattingOptions): Number = noImpl
        public fun columnForPositionInString(input: String, position: Number, options: FormattingOptions): Number = noImpl
        public fun indentationString(column: Number, options: FormattingOptions): String = noImpl
        public fun indentationTrivia(column: Number, options: FormattingOptions): ISyntaxTrivia = noImpl
        public fun firstNonWhitespacePosition(value: String): Number = noImpl
    }

    enum class LanguageVersion
    public open class ParseOptions(languageVersion: LanguageVersion, allowAutomaticSemicolonInsertion: Boolean) {
        public open var _languageVersion: Any = noImpl
        public open var _allowAutomaticSemicolonInsertion: Any = noImpl
        public open fun toJSON(key: Any): `T$3` = noImpl
        public open fun languageVersion(): LanguageVersion = noImpl
        public open fun allowAutomaticSemicolonInsertion(): Boolean = noImpl
    }
    public open class PositionedElement(parent: PositionedElement, element: ISyntaxElement, fullStart: Number) {
        public open var _parent: Any = noImpl
        public open var _element: Any = noImpl
        public open var _fullStart: Any = noImpl
        public open fun parent(): PositionedElement = noImpl
        public open fun parentElement(): ISyntaxElement = noImpl
        public open fun element(): ISyntaxElement = noImpl
        public open fun kind(): SyntaxKind = noImpl
        public open fun childIndex(child: ISyntaxElement): Number = noImpl
        public open fun childCount(): Number = noImpl
        public open fun childAt(index: Number): PositionedElement = noImpl
        public open fun childStart(child: ISyntaxElement): Number = noImpl
        public open fun childEnd(child: ISyntaxElement): Number = noImpl
        public open fun childStartAt(index: Number): Number = noImpl
        public open fun childEndAt(index: Number): Number = noImpl
        public open fun getPositionedChild(child: ISyntaxElement): PositionedElement = noImpl
        public open fun fullStart(): Number = noImpl
        public open fun fullEnd(): Number = noImpl
        public open fun fullWidth(): Number = noImpl
        public open fun start(): Number = noImpl
        public open fun end(): Number = noImpl
        public open fun root(): PositionedNode = noImpl
        public open fun containingNode(): PositionedNode = noImpl
        public class object {
            public fun create(parent: PositionedElement, element: ISyntaxElement, fullStart: Number): PositionedElement = noImpl
        }
    }
    public open class PositionedNodeOrToken(parent: PositionedElement, nodeOrToken: ISyntaxNodeOrToken, fullStart: Number) : PositionedElement() {
        public open fun nodeOrToken(): ISyntaxNodeOrToken = noImpl
    }
    public open class PositionedNode(parent: PositionedElement, node: SyntaxNode, fullStart: Number) : PositionedNodeOrToken() {
        public open fun node(): SyntaxNode = noImpl
    }
    public open class PositionedToken(parent: PositionedElement, token: ISyntaxToken, fullStart: Number) : PositionedNodeOrToken(noImpl, noImpl, noImpl) {
        public open fun token(): ISyntaxToken = noImpl
        public open fun previousToken(includeSkippedTokens: Boolean? = null): PositionedToken = noImpl
        public open fun nextToken(includeSkippedTokens: Boolean? = null): PositionedToken = noImpl
    }
    public open class PositionedList(parent: PositionedElement, list: ISyntaxList, fullStart: Number) : PositionedElement(noImpl, noImpl, noImpl) {
        public open fun list(): ISyntaxList = noImpl
    }
    public open class PositionedSeparatedList(parent: PositionedElement, list: ISeparatedSyntaxList, fullStart: Number) : PositionedElement(noImpl, noImpl, noImpl) {
        public open fun list(): ISeparatedSyntaxList = noImpl
    }
    public open class PositionedSkippedToken(parentToken: PositionedToken, token: ISyntaxToken, fullStart: Number) : PositionedToken(noImpl, noImpl, noImpl) {
        public open var _parentToken: Any = noImpl
        public open fun parentToken(): PositionedToken = noImpl
        override fun previousToken(includeSkippedTokens: Boolean?): PositionedToken = noImpl
        override fun nextToken(includeSkippedTokens: Boolean?): PositionedToken = noImpl
    }
    module
    public object SyntaxFacts {
        public fun getTokenKind(text: String): SyntaxKind = noImpl
        public fun getText(kind: SyntaxKind): String = noImpl
        public fun isTokenKind(kind: SyntaxKind): Boolean = noImpl
        public fun isAnyKeyword(kind: SyntaxKind): Boolean = noImpl
        public fun isStandardKeyword(kind: SyntaxKind): Boolean = noImpl
        public fun isFutureReservedKeyword(kind: SyntaxKind): Boolean = noImpl
        public fun isFutureReservedStrictKeyword(kind: SyntaxKind): Boolean = noImpl
        public fun isAnyPunctuation(kind: SyntaxKind): Boolean = noImpl
        public fun isPrefixUnaryExpressionOperatorToken(tokenKind: SyntaxKind): Boolean = noImpl
        public fun isBinaryExpressionOperatorToken(tokenKind: SyntaxKind): Boolean = noImpl
        public fun getPrefixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind = noImpl
        public fun getPostfixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind = noImpl
        public fun getBinaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind = noImpl
        public fun getOperatorTokenFromBinaryExpression(tokenKind: SyntaxKind): SyntaxKind = noImpl
        public fun isAnyDivideToken(kind: SyntaxKind): Boolean = noImpl
        public fun isAnyDivideOrRegularExpressionToken(kind: SyntaxKind): Boolean = noImpl
        public fun isDirectivePrologueElement(node: ISyntaxNodeOrToken): Boolean = noImpl
        public fun isUseStrictDirective(node: ISyntaxNodeOrToken): Boolean = noImpl
        public fun isIdentifierNameOrAnyKeyword(token: ISyntaxToken): Boolean = noImpl
    }
    public open class Scanner(fileName: String, text: ISimpleText, languageVersion: LanguageVersion, window: Array<Number>? = null) : ISlidingWindowSource {
        public open var slidingWindow: Any = noImpl
        public open var fileName: Any = noImpl
        public open var text: Any = noImpl
        public open var _languageVersion: Any = noImpl
        public open fun languageVersion(): LanguageVersion = noImpl
        override fun fetchMoreItems(argument: Any, sourceIndex: Number, window: Array<Number>, destinationIndex: Number, spaceAvailable: Number): Number = noImpl
        public open fun currentCharCode(): Unit = noImpl
        public open fun absoluteIndex(): Number = noImpl
        public open fun setAbsoluteIndex(index: Number): Unit = noImpl
        public open fun scan(diagnostics: Array<Diagnostic>, allowRegularExpression: Boolean): ISyntaxToken = noImpl
        public open fun createToken(fullStart: Any, leadingTriviaInfo: Any, start: Any, kind: Any, end: Any, fullEnd: Any, trailingTriviaInfo: Any, isVariableWidthKeyword: Any): Unit = noImpl
        public open fun scanTrivia(underlyingText: Any, underlyingTextStart: Any, isTrailing: Any): Unit = noImpl
        public open fun scanTriviaInfo(diagnostics: Any, isTrailing: Any): Unit = noImpl
        public open fun isNewLineCharacter(ch: Any): Unit = noImpl
        public open fun scanWhitespaceTrivia(underlyingText: Any, underlyingTextStart: Any): Unit = noImpl
        public open fun scanSingleLineCommentTrivia(underlyingText: Any, underlyingTextStart: Any): Unit = noImpl
        public open fun scanSingleLineCommentTriviaLength(): Unit = noImpl
        public open fun scanMultiLineCommentTrivia(underlyingText: Any, underlyingTextStart: Any): Unit = noImpl
        public open fun scanMultiLineCommentTriviaLength(diagnostics: Any): Unit = noImpl
        public open fun scanLineTerminatorSequenceTrivia(ch: Any): Unit = noImpl
        public open fun scanLineTerminatorSequenceLength(ch: Any): Unit = noImpl
        public open fun scanSyntaxToken(diagnostics: Any, allowRegularExpression: Any): Unit = noImpl
        public open fun isIdentifierStart(interpretedChar: Any): Unit = noImpl
        public open fun isIdentifierPart(interpretedChar: Any): Unit = noImpl
        public open fun tryFastScanIdentifierOrKeyword(firstCharacter: Any): Unit = noImpl
        public open fun slowScanIdentifierOrKeyword(diagnostics: Any): Unit = noImpl
        public open fun scanNumericLiteral(diagnostics: Any): Unit = noImpl
        public open fun isOctalNumericLiteral(): Unit = noImpl
        public open fun scanOctalNumericLiteral(diagnostics: Any): Unit = noImpl
        public open fun scanDecimalDigits(): Unit = noImpl
        public open fun scanDecimalNumericLiteral(): Unit = noImpl
        public open fun scanHexNumericLiteral(): Unit = noImpl
        public open fun isHexNumericLiteral(): Unit = noImpl
        public open fun advanceAndSetTokenKind(kind: Any): Unit = noImpl
        public open fun scanLessThanToken(): Unit = noImpl
        public open fun scanBarToken(): Unit = noImpl
        public open fun scanCaretToken(): Unit = noImpl
        public open fun scanAmpersandToken(): Unit = noImpl
        public open fun scanPercentToken(): Unit = noImpl
        public open fun scanMinusToken(): Unit = noImpl
        public open fun scanPlusToken(): Unit = noImpl
        public open fun scanAsteriskToken(): Unit = noImpl
        public open fun scanEqualsToken(): Unit = noImpl
        public open fun isDotPrefixedNumericLiteral(): Unit = noImpl
        public open fun scanDotToken(diagnostics: Any): Unit = noImpl
        public open fun scanSlashToken(allowRegularExpression: Any): Unit = noImpl
        public open fun tryScanRegularExpressionToken(): Unit = noImpl
        public open fun scanExclamationToken(): Unit = noImpl
        public open fun scanDefaultCharacter(character: Any, diagnostics: Any): Unit = noImpl
        public open fun getErrorMessageText(text: Any): Unit = noImpl
        public open fun skipEscapeSequence(diagnostics: Any): Unit = noImpl
        public open fun scanStringLiteral(diagnostics: Any): Unit = noImpl
        public open fun isUnicodeEscape(character: Any): Unit = noImpl
        public open fun peekCharOrUnicodeEscape(): Unit = noImpl
        public open fun peekUnicodeOrHexEscape(): Unit = noImpl
        public open fun scanCharOrUnicodeEscape(errors: Any): Unit = noImpl
        public open fun scanUnicodeOrHexEscape(errors: Any): Unit = noImpl
        public open fun substring(start: Number, end: Number, intern: Boolean): String = noImpl
        public open fun createIllegalEscapeDiagnostic(start: Any, end: Any): Unit = noImpl
        public class object {
            public var triviaWindow: Any = noImpl
            public fun scanTrivia(text: ISimpleText, start: Number, length: Number, isTrailing: Boolean): ISyntaxTriviaList = noImpl
            public fun isValidIdentifier(text: ISimpleText, languageVersion: LanguageVersion): Boolean = noImpl
        }
    }
    public open class ScannerUtilities {
        public class object {
            public fun identifierKind(array: Array<Number>, startIndex: Number, length: Number): SyntaxKind = noImpl
        }
    }
    public trait ISeparatedSyntaxList : ISyntaxElement {
        override fun childAt(index: Number): ISyntaxNodeOrToken
        public fun toArray(): Array<ISyntaxNodeOrToken>
        public fun toNonSeparatorArray(): Array<ISyntaxNodeOrToken>
        public fun separatorCount(): Number
        public fun separatorAt(index: Number): ISyntaxToken
        public fun nonSeparatorCount(): Number
        public fun nonSeparatorAt(index: Number): ISyntaxNodeOrToken
        public fun insertChildrenInto(array: Array<ISyntaxElement>, index: Number)
    }
    module
    public object Syntax {
        public var emptySeparatedList: ISeparatedSyntaxList = noImpl
        public fun separatedList(nodes: Array<ISyntaxNodeOrToken>): ISeparatedSyntaxList = noImpl
        public fun emptySourceUnit(): SourceUnitSyntax = noImpl
        public fun getStandaloneExpression(positionedToken: PositionedToken): PositionedNodeOrToken = noImpl
        public fun isInModuleOrTypeContext(positionedToken: PositionedToken): Boolean = noImpl
        public fun isInTypeOnlyContext(positionedToken: PositionedToken): Boolean = noImpl
        public fun childOffset(parent: ISyntaxElement, child: ISyntaxElement): Number = noImpl
        public fun childOffsetAt(parent: ISyntaxElement, index: Number): Number = noImpl
        public fun childIndex(parent: ISyntaxElement, child: ISyntaxElement): Number = noImpl
        public fun nodeStructuralEquals(node1: SyntaxNode, node2: SyntaxNode): Boolean = noImpl
        public fun nodeOrTokenStructuralEquals(node1: ISyntaxNodeOrToken, node2: ISyntaxNodeOrToken): Boolean = noImpl
        public fun tokenStructuralEquals(token1: ISyntaxToken, token2: ISyntaxToken): Boolean = noImpl
        public fun triviaListStructuralEquals(triviaList1: ISyntaxTriviaList, triviaList2: ISyntaxTriviaList): Boolean = noImpl
        public fun triviaStructuralEquals(trivia1: ISyntaxTrivia, trivia2: ISyntaxTrivia): Boolean = noImpl
        public fun listStructuralEquals(list1: ISyntaxList, list2: ISyntaxList): Boolean = noImpl
        public fun separatedListStructuralEquals(list1: ISeparatedSyntaxList, list2: ISeparatedSyntaxList): Boolean = noImpl
        public fun elementStructuralEquals(element1: ISyntaxElement, element2: ISyntaxElement): Boolean = noImpl
        public fun identifierName(text: String, info: ITokenInfo? = null): ISyntaxToken = noImpl
        public fun trueExpression(): IUnaryExpressionSyntax = noImpl
        public fun falseExpression(): IUnaryExpressionSyntax = noImpl
        public fun numericLiteralExpression(text: String): IUnaryExpressionSyntax = noImpl
        public fun stringLiteralExpression(text: String): IUnaryExpressionSyntax = noImpl
        public fun isSuperInvocationExpression(node: IExpressionSyntax): Boolean = noImpl
        public fun isSuperInvocationExpressionStatement(node: SyntaxNode): Boolean = noImpl
        public fun isSuperMemberAccessExpression(node: IExpressionSyntax): Boolean = noImpl
        public fun isSuperMemberAccessInvocationExpression(node: SyntaxNode): Boolean = noImpl
        public fun assignmentExpression(left: IExpressionSyntax, token: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax = noImpl
        public fun nodeHasSkippedOrMissingTokens(node: SyntaxNode): Boolean = noImpl
        public fun isUnterminatedStringLiteral(token: ISyntaxToken): Boolean = noImpl
        public fun isUnterminatedMultilineCommentTrivia(trivia: ISyntaxTrivia): Boolean = noImpl
        public fun isEntirelyInsideCommentTrivia(trivia: ISyntaxTrivia, fullStart: Number, position: Number): Boolean = noImpl
        public fun isEntirelyInsideComment(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
        public fun isEntirelyInStringOrRegularExpressionLiteral(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
        public fun findSkippedTokenInLeadingTriviaList(positionedToken: PositionedToken, position: Number): PositionedSkippedToken = noImpl
        public fun findSkippedTokenInTrailingTriviaList(positionedToken: PositionedToken, position: Number): PositionedSkippedToken = noImpl
        public fun findSkippedTokenInPositionedToken(positionedToken: PositionedToken, position: Number): PositionedSkippedToken = noImpl
        public fun findSkippedTokenOnLeft(positionedToken: PositionedToken, position: Number): PositionedSkippedToken = noImpl
        public fun getAncestorOfKind(positionedToken: PositionedElement, kind: SyntaxKind): PositionedElement = noImpl
        public fun hasAncestorOfKind(positionedToken: PositionedElement, kind: SyntaxKind): Boolean = noImpl
        public fun isIntegerLiteral(expression: IExpressionSyntax): Boolean = noImpl
        public trait IFactory {
            public fun sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax
            public fun externalModuleReference(requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax
            public fun moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax
            public fun importDeclaration(modifiers: ISyntaxList, importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax
            public fun exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax
            public fun classDeclaration(modifiers: ISyntaxList, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax
            public fun interfaceDeclaration(modifiers: ISyntaxList, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, body: ObjectTypeSyntax): InterfaceDeclarationSyntax
            public fun heritageClause(kind: SyntaxKind, extendsOrImplementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): HeritageClauseSyntax
            public fun moduleDeclaration(modifiers: ISyntaxList, moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax
            public fun functionDeclaration(modifiers: ISyntaxList, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax
            public fun variableStatement(modifiers: ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax
            public fun variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax
            public fun variableDeclarator(propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax
            public fun equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax
            public fun prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax
            public fun arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax
            public fun omittedExpression(): OmittedExpressionSyntax
            public fun parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax
            public fun simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): SimpleArrowFunctionExpressionSyntax
            public fun parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): ParenthesizedArrowFunctionExpressionSyntax
            public fun qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax
            public fun typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax
            public fun constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): ConstructorTypeSyntax
            public fun functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): FunctionTypeSyntax
            public fun objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax
            public fun arrayType(`type`: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax
            public fun genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax
            public fun typeQuery(typeOfKeyword: ISyntaxToken, name: INameSyntax): TypeQuerySyntax
            public fun typeAnnotation(colonToken: ISyntaxToken, `type`: ITypeSyntax): TypeAnnotationSyntax
            public fun block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax
            public fun parameter(dotDotDotToken: ISyntaxToken, modifiers: ISyntaxList, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax
            public fun memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax
            public fun postfixUnaryExpression(kind: SyntaxKind, operand: IMemberExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax
            public fun elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax
            public fun invocationExpression(expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax
            public fun argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax
            public fun binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax
            public fun conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax
            public fun constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax
            public fun methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax
            public fun indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax
            public fun propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax
            public fun callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax
            public fun parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax
            public fun typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax
            public fun typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax
            public fun constraint(extendsKeyword: ISyntaxToken, `type`: ITypeSyntax): ConstraintSyntax
            public fun elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax
            public fun ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax
            public fun expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax
            public fun constructorDeclaration(modifiers: ISyntaxList, constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax
            public fun memberFunctionDeclaration(modifiers: ISyntaxList, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax
            public fun getAccessor(modifiers: ISyntaxList, getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorSyntax
            public fun setAccessor(modifiers: ISyntaxList, setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetAccessorSyntax
            public fun memberVariableDeclaration(modifiers: ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax
            public fun indexMemberDeclaration(modifiers: ISyntaxList, indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax
            public fun throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax
            public fun returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax
            public fun objectCreationExpression(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax
            public fun switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax
            public fun caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax
            public fun defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax
            public fun breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax
            public fun continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax
            public fun forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax
            public fun forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax
            public fun whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax
            public fun withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax
            public fun enumDeclaration(modifiers: ISyntaxList, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax
            public fun enumElement(propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax
            public fun castExpression(lessThanToken: ISyntaxToken, `type`: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax
            public fun objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax
            public fun simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax
            public fun functionPropertyAssignment(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionPropertyAssignmentSyntax
            public fun functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax
            public fun emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax
            public fun tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax
            public fun catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax
            public fun finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax
            public fun labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax
            public fun doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax
            public fun typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax
            public fun deleteExpression(deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): DeleteExpressionSyntax
            public fun voidExpression(voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): VoidExpressionSyntax
            public fun debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax
        }
        public open class NormalModeFactory : IFactory {
            override fun sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
            override fun externalModuleReference(requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
            override fun moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax = noImpl
            override fun importDeclaration(modifiers: ISyntaxList, importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
            override fun exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax = noImpl
            override fun classDeclaration(modifiers: ISyntaxList, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
            override fun interfaceDeclaration(modifiers: ISyntaxList, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, body: ObjectTypeSyntax): InterfaceDeclarationSyntax = noImpl
            override fun heritageClause(kind: SyntaxKind, extendsOrImplementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): HeritageClauseSyntax = noImpl
            override fun moduleDeclaration(modifiers: ISyntaxList, moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
            override fun functionDeclaration(modifiers: ISyntaxList, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax = noImpl
            override fun variableStatement(modifiers: ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax = noImpl
            override fun variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax = noImpl
            override fun variableDeclarator(propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax = noImpl
            override fun equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax = noImpl
            override fun prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax = noImpl
            override fun arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
            override fun omittedExpression(): OmittedExpressionSyntax = noImpl
            override fun parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax = noImpl
            override fun simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): SimpleArrowFunctionExpressionSyntax = noImpl
            override fun parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
            override fun qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax = noImpl
            override fun typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
            override fun constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
            override fun functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): FunctionTypeSyntax = noImpl
            override fun objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
            override fun arrayType(`type`: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax = noImpl
            override fun genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax = noImpl
            override fun typeQuery(typeOfKeyword: ISyntaxToken, name: INameSyntax): TypeQuerySyntax = noImpl
            override fun typeAnnotation(colonToken: ISyntaxToken, `type`: ITypeSyntax): TypeAnnotationSyntax = noImpl
            override fun block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax = noImpl
            override fun parameter(dotDotDotToken: ISyntaxToken, modifiers: ISyntaxList, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax = noImpl
            override fun memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
            override fun postfixUnaryExpression(kind: SyntaxKind, operand: IMemberExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax = noImpl
            override fun elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax = noImpl
            override fun invocationExpression(expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax = noImpl
            override fun argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
            override fun binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax = noImpl
            override fun conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
            override fun constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax = noImpl
            override fun methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax = noImpl
            override fun indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax = noImpl
            override fun propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax = noImpl
            override fun callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax = noImpl
            override fun parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax = noImpl
            override fun typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
            override fun typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax = noImpl
            override fun constraint(extendsKeyword: ISyntaxToken, `type`: ITypeSyntax): ConstraintSyntax = noImpl
            override fun elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax = noImpl
            override fun ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax = noImpl
            override fun expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax = noImpl
            override fun constructorDeclaration(modifiers: ISyntaxList, constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
            override fun memberFunctionDeclaration(modifiers: ISyntaxList, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
            override fun getAccessor(modifiers: ISyntaxList, getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorSyntax = noImpl
            override fun setAccessor(modifiers: ISyntaxList, setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetAccessorSyntax = noImpl
            override fun memberVariableDeclaration(modifiers: ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
            override fun indexMemberDeclaration(modifiers: ISyntaxList, indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
            override fun throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax = noImpl
            override fun returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax = noImpl
            override fun objectCreationExpression(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax = noImpl
            override fun switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
            override fun caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax = noImpl
            override fun defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax = noImpl
            override fun breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax = noImpl
            override fun continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax = noImpl
            override fun forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax = noImpl
            override fun forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax = noImpl
            override fun whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax = noImpl
            override fun withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax = noImpl
            override fun enumDeclaration(modifiers: ISyntaxList, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
            override fun enumElement(propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax = noImpl
            override fun castExpression(lessThanToken: ISyntaxToken, `type`: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax = noImpl
            override fun objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
            override fun simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax = noImpl
            override fun functionPropertyAssignment(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionPropertyAssignmentSyntax = noImpl
            override fun functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax = noImpl
            override fun emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax = noImpl
            override fun tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax = noImpl
            override fun catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax = noImpl
            override fun finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax = noImpl
            override fun labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax = noImpl
            override fun doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax = noImpl
            override fun typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax = noImpl
            override fun deleteExpression(deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): DeleteExpressionSyntax = noImpl
            override fun voidExpression(voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): VoidExpressionSyntax = noImpl
            override fun debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax = noImpl
        }
        public open class StrictModeFactory : IFactory {
            override fun sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
            override fun externalModuleReference(requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
            override fun moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax = noImpl
            override fun importDeclaration(modifiers: ISyntaxList, importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
            override fun exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax = noImpl
            override fun classDeclaration(modifiers: ISyntaxList, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
            override fun interfaceDeclaration(modifiers: ISyntaxList, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, body: ObjectTypeSyntax): InterfaceDeclarationSyntax = noImpl
            override fun heritageClause(kind: SyntaxKind, extendsOrImplementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): HeritageClauseSyntax = noImpl
            override fun moduleDeclaration(modifiers: ISyntaxList, moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
            override fun functionDeclaration(modifiers: ISyntaxList, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax = noImpl
            override fun variableStatement(modifiers: ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax = noImpl
            override fun variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax = noImpl
            override fun variableDeclarator(propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax = noImpl
            override fun equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax = noImpl
            override fun prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax = noImpl
            override fun arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
            override fun omittedExpression(): OmittedExpressionSyntax = noImpl
            override fun parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax = noImpl
            override fun simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): SimpleArrowFunctionExpressionSyntax = noImpl
            override fun parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
            override fun qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax = noImpl
            override fun typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
            override fun constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
            override fun functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): FunctionTypeSyntax = noImpl
            override fun objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
            override fun arrayType(`type`: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax = noImpl
            override fun genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax = noImpl
            override fun typeQuery(typeOfKeyword: ISyntaxToken, name: INameSyntax): TypeQuerySyntax = noImpl
            override fun typeAnnotation(colonToken: ISyntaxToken, `type`: ITypeSyntax): TypeAnnotationSyntax = noImpl
            override fun block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax = noImpl
            override fun parameter(dotDotDotToken: ISyntaxToken, modifiers: ISyntaxList, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax = noImpl
            override fun memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
            override fun postfixUnaryExpression(kind: SyntaxKind, operand: IMemberExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax = noImpl
            override fun elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax = noImpl
            override fun invocationExpression(expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax = noImpl
            override fun argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
            override fun binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax = noImpl
            override fun conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
            override fun constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax = noImpl
            override fun methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax = noImpl
            override fun indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax = noImpl
            override fun propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax = noImpl
            override fun callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax = noImpl
            override fun parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax = noImpl
            override fun typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
            override fun typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax = noImpl
            override fun constraint(extendsKeyword: ISyntaxToken, `type`: ITypeSyntax): ConstraintSyntax = noImpl
            override fun elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax = noImpl
            override fun ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax = noImpl
            override fun expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax = noImpl
            override fun constructorDeclaration(modifiers: ISyntaxList, constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
            override fun memberFunctionDeclaration(modifiers: ISyntaxList, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
            override fun getAccessor(modifiers: ISyntaxList, getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorSyntax = noImpl
            override fun setAccessor(modifiers: ISyntaxList, setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetAccessorSyntax = noImpl
            override fun memberVariableDeclaration(modifiers: ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
            override fun indexMemberDeclaration(modifiers: ISyntaxList, indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
            override fun throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax = noImpl
            override fun returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax = noImpl
            override fun objectCreationExpression(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax = noImpl
            override fun switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
            override fun caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax = noImpl
            override fun defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax = noImpl
            override fun breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax = noImpl
            override fun continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax = noImpl
            override fun forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax = noImpl
            override fun forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax = noImpl
            override fun whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax = noImpl
            override fun withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax = noImpl
            override fun enumDeclaration(modifiers: ISyntaxList, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
            override fun enumElement(propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax = noImpl
            override fun castExpression(lessThanToken: ISyntaxToken, `type`: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax = noImpl
            override fun objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
            override fun simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax = noImpl
            override fun functionPropertyAssignment(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionPropertyAssignmentSyntax = noImpl
            override fun functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax = noImpl
            override fun emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax = noImpl
            override fun tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax = noImpl
            override fun catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax = noImpl
            override fun finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax = noImpl
            override fun labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax = noImpl
            override fun doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax = noImpl
            override fun typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax = noImpl
            override fun deleteExpression(deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): DeleteExpressionSyntax = noImpl
            override fun voidExpression(voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): VoidExpressionSyntax = noImpl
            override fun debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax = noImpl
        }
        public var normalModeFactory: IFactory = noImpl
        public var strictModeFactory: IFactory = noImpl
        public open class EmptySyntaxList : ISyntaxList {
            override fun kind(): SyntaxKind = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxNodeOrToken = noImpl
            override fun toArray(): Array<ISyntaxNodeOrToken> = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun fullText(): String = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            public open fun findTokenInternal(parent: PositionedElement, position: Number, fullStart: Number): PositionedToken = noImpl
            override fun insertChildrenInto(array: Array<ISyntaxElement>, index: Number): Unit = noImpl
        }
        public var emptyList: ISyntaxList = noImpl
        public fun list(nodes: Array<ISyntaxNodeOrToken>): ISyntaxList = noImpl
        public open class VariableWidthTokenWithNoTrivia(fullText: String, kind: SyntaxKind) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class VariableWidthTokenWithLeadingTrivia(fullText: String, kind: SyntaxKind, leadingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _leadingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class VariableWidthTokenWithTrailingTrivia(fullText: String, kind: SyntaxKind, trailingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _trailingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class VariableWidthTokenWithLeadingAndTrailingTrivia(fullText: String, kind: SyntaxKind, leadingTriviaInfo: Number, trailingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _leadingTriviaInfo: Any = noImpl
            public open var _trailingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class FixedWidthTokenWithNoTrivia(kind: SyntaxKind) : ISyntaxToken {
            override var tokenKind: SyntaxKind = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class FixedWidthTokenWithLeadingTrivia(fullText: String, kind: SyntaxKind, leadingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _leadingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class FixedWidthTokenWithTrailingTrivia(fullText: String, kind: SyntaxKind, trailingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _trailingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public open class FixedWidthTokenWithLeadingAndTrailingTrivia(fullText: String, kind: SyntaxKind, leadingTriviaInfo: Number, trailingTriviaInfo: Number) : ISyntaxToken {
            public open var _fullText: Any = noImpl
            override var tokenKind: SyntaxKind = noImpl
            public open var _leadingTriviaInfo: Any = noImpl
            public open var _trailingTriviaInfo: Any = noImpl
            override fun clone(): ISyntaxToken = noImpl
            override fun isNode(): Boolean = noImpl
            override fun isToken(): Boolean = noImpl
            override fun isList(): Boolean = noImpl
            override fun isSeparatedList(): Boolean = noImpl
            override fun kind(): SyntaxKind = noImpl
            override fun childCount(): Number = noImpl
            override fun childAt(index: Number): ISyntaxElement = noImpl
            override fun fullWidth(): Number = noImpl
            override fun width(): Number = noImpl
            override fun text(): String = noImpl
            override fun fullText(): String = noImpl
            override fun value(): Any = noImpl
            override fun valueText(): String = noImpl
            override fun hasLeadingTrivia(): Boolean = noImpl
            override fun hasLeadingComment(): Boolean = noImpl
            override fun hasLeadingNewLine(): Boolean = noImpl
            override fun hasLeadingSkippedText(): Boolean = noImpl
            override fun leadingTriviaWidth(): Number = noImpl
            override fun leadingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasTrailingTrivia(): Boolean = noImpl
            override fun hasTrailingComment(): Boolean = noImpl
            override fun hasTrailingNewLine(): Boolean = noImpl
            override fun hasTrailingSkippedText(): Boolean = noImpl
            override fun trailingTriviaWidth(): Number = noImpl
            override fun trailingTrivia(): ISyntaxTriviaList = noImpl
            override fun hasSkippedToken(): Boolean = noImpl
            public open fun toJSON(key: Any): Any = noImpl
            override fun firstToken(): ISyntaxToken = noImpl
            override fun lastToken(): ISyntaxToken = noImpl
            override fun isTypeScriptSpecific(): Boolean = noImpl
            override fun isIncrementallyUnusable(): Boolean = noImpl
            override fun accept(visitor: ISyntaxVisitor): Any = noImpl
            public open fun realize(): Unit = noImpl
            override fun collectTextElements(elements: Array<String>): Unit = noImpl
            public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
            override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken = noImpl
            override fun isExpression(): Boolean = noImpl
            override fun isPrimaryExpression(): Boolean = noImpl
            override fun isMemberExpression(): Boolean = noImpl
            override fun isPostfixExpression(): Boolean = noImpl
            override fun isUnaryExpression(): Boolean = noImpl
        }
        public fun isExpression(token: ISyntaxToken): Boolean = noImpl
        public fun realizeToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public fun convertToIdentifierName(token: ISyntaxToken): ISyntaxToken = noImpl
        public fun tokenToJSON(token: ISyntaxToken): Any = noImpl
        public fun value(token: ISyntaxToken): Any = noImpl
        public fun massageEscapes(text: String): String = noImpl
        public fun valueText(token: ISyntaxToken): String = noImpl
        public fun emptyToken(kind: SyntaxKind): ISyntaxToken = noImpl
        public fun token(kind: SyntaxKind, info: ITokenInfo? = null): ISyntaxToken = noImpl
        public fun identifier(text: String, info: ITokenInfo? = null): ISyntaxToken = noImpl
        public fun deferredTrivia(kind: SyntaxKind, text: ISimpleText, fullStart: Number, fullWidth: Number): ISyntaxTrivia = noImpl
        public fun trivia(kind: SyntaxKind, text: String): ISyntaxTrivia = noImpl
        public fun skippedTokenTrivia(token: ISyntaxToken): ISyntaxTrivia = noImpl
        public fun spaces(count: Number): ISyntaxTrivia = noImpl
        public fun whitespace(text: String): ISyntaxTrivia = noImpl
        public fun multiLineComment(text: String): ISyntaxTrivia = noImpl
        public fun singleLineComment(text: String): ISyntaxTrivia = noImpl
        public var spaceTrivia: ISyntaxTrivia = noImpl
        public var lineFeedTrivia: ISyntaxTrivia = noImpl
        public var carriageReturnTrivia: ISyntaxTrivia = noImpl
        public var carriageReturnLineFeedTrivia: ISyntaxTrivia = noImpl
        public fun splitMultiLineCommentTriviaIntoMultipleLines(trivia: ISyntaxTrivia): Array<String> = noImpl
        public var emptyTriviaList: ISyntaxTriviaList = noImpl
        public fun triviaList(trivia: Array<ISyntaxTrivia>): ISyntaxTriviaList = noImpl
        public var spaceTriviaList: ISyntaxTriviaList = noImpl
    }
    public trait ISlidingWindowSource {
        public fun fetchMoreItems(argument: Any, sourceIndex: Number, window: Array<Any>, destinationIndex: Number, spaceAvailable: Number): Number
    }
    public open class SlidingWindow(source: ISlidingWindowSource, window: Array<Any>, defaultValue: Any, sourceLength: Number? = null) {
        public open var source: Any = noImpl
        public open var window: Array<Any> = noImpl
        public open var defaultValue: Any = noImpl
        public open var sourceLength: Any = noImpl
        public open var windowCount: Number = noImpl
        public open var windowAbsoluteStartIndex: Number = noImpl
        public open var currentRelativeItemIndex: Number = noImpl
        public open var _pinCount: Any = noImpl
        public open var firstPinnedAbsoluteIndex: Any = noImpl
        public open fun windowAbsoluteEndIndex(): Unit = noImpl
        public open fun addMoreItemsToWindow(argument: Any): Unit = noImpl
        public open fun tryShiftOrGrowWindow(): Unit = noImpl
        public open fun absoluteIndex(): Number = noImpl
        public open fun isAtEndOfSource(): Boolean = noImpl
        public open fun getAndPinAbsoluteIndex(): Number = noImpl
        public open fun releaseAndUnpinAbsoluteIndex(absoluteIndex: Number): Unit = noImpl
        public open fun rewindToPinnedIndex(absoluteIndex: Number): Unit = noImpl
        public open fun currentItem(argument: Any): Any = noImpl
        public open fun peekItemN(n: Number): Any = noImpl
        public open fun moveToNextItem(): Unit = noImpl
        public open fun disgardAllItemsFromCurrentIndexOnwards(): Unit = noImpl
        public open fun setAbsoluteIndex(absoluteIndex: Number): Unit = noImpl
        public open fun pinCount(): Number = noImpl
    }
    public trait ISyntaxElement {
        public fun kind(): SyntaxKind
        public fun isNode(): Boolean
        public fun isToken(): Boolean
        public fun isList(): Boolean
        public fun isSeparatedList(): Boolean
        public fun childCount(): Number
        public fun childAt(index: Number): ISyntaxElement
        public fun isTypeScriptSpecific(): Boolean
        public fun isIncrementallyUnusable(): Boolean
        public fun fullWidth(): Number
        public fun width(): Number
        public fun fullText(): String
        public fun leadingTrivia(): ISyntaxTriviaList
        public fun trailingTrivia(): ISyntaxTriviaList
        public fun leadingTriviaWidth(): Number
        public fun trailingTriviaWidth(): Number
        public fun firstToken(): ISyntaxToken
        public fun lastToken(): ISyntaxToken
        public fun collectTextElements(elements: Array<String>)
    }
    public trait ISyntaxNode : ISyntaxNodeOrToken
    public trait IModuleReferenceSyntax : ISyntaxNode {
        public fun isModuleReference(): Boolean
    }
    public trait IModuleElementSyntax : ISyntaxNode
    public trait IStatementSyntax : IModuleElementSyntax {
        public fun isStatement(): Boolean
    }
    public trait IIterationStatementSyntax : IStatementSyntax {
        public fun isIterationStatement(): Boolean
    }
    public trait ITypeMemberSyntax : ISyntaxNode
    public trait IClassElementSyntax : ISyntaxNode
    public trait IMemberDeclarationSyntax : IClassElementSyntax
    public trait IPropertyAssignmentSyntax : IClassElementSyntax
    public trait ISwitchClauseSyntax : ISyntaxNode {
        public fun isSwitchClause(): Boolean
        public var statements: ISyntaxList
    }
    public trait IExpressionSyntax : ISyntaxNodeOrToken {
        public fun isExpression(): Boolean
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): IExpressionSyntax
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): IExpressionSyntax
    }
    public trait IUnaryExpressionSyntax : IExpressionSyntax {
        public fun isUnaryExpression(): Boolean
    }
    public trait IArrowFunctionExpressionSyntax : IUnaryExpressionSyntax {
        public fun isArrowFunctionExpression(): Boolean
        public var equalsGreaterThanToken: ISyntaxToken
        public var block: BlockSyntax
        public var expression: IExpressionSyntax
    }
    public trait IPostfixExpressionSyntax : IUnaryExpressionSyntax {
        public fun isPostfixExpression(): Boolean
    }
    public trait IMemberExpressionSyntax : IPostfixExpressionSyntax {
        public fun isMemberExpression(): Boolean
    }
    public trait IPrimaryExpressionSyntax : IMemberExpressionSyntax {
        public fun isPrimaryExpression(): Boolean
    }
    public trait ITypeSyntax : ISyntaxNodeOrToken
    public trait INameSyntax : ITypeSyntax
    public trait ISyntaxList : ISyntaxElement {
        override fun childAt(index: Number): ISyntaxNodeOrToken
        public fun toArray(): Array<ISyntaxNodeOrToken>
        public fun insertChildrenInto(array: Array<ISyntaxElement>, index: Number)
    }
    public open class SyntaxNode(parsedInStrictMode: Boolean) : ISyntaxNodeOrToken {
        public open var _data: Any = noImpl
        override fun isNode(): Boolean = noImpl
        override fun isToken(): Boolean = noImpl
        override fun isList(): Boolean = noImpl
        override fun isSeparatedList(): Boolean = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun firstToken(): ISyntaxToken = noImpl
        override fun lastToken(): ISyntaxToken = noImpl
        public open fun insertChildrenInto(array: Array<ISyntaxElement>, index: Number): Unit = noImpl
        override fun leadingTrivia(): ISyntaxTriviaList = noImpl
        override fun trailingTrivia(): ISyntaxTriviaList = noImpl
        public open fun toJSON(key: Any): Any = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun fullText(): String = noImpl
        override fun collectTextElements(elements: Array<String>): Unit = noImpl
        public open fun replaceToken(token1: ISyntaxToken, token2: ISyntaxToken): SyntaxNode = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SyntaxNode = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SyntaxNode = noImpl
        public open fun hasLeadingTrivia(): Boolean = noImpl
        public open fun hasTrailingTrivia(): Boolean = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        override fun isIncrementallyUnusable(): Boolean = noImpl
        public open fun parsedInStrictMode(): Boolean = noImpl
        override fun fullWidth(): Number = noImpl
        public open fun computeData(): Unit = noImpl
        public open fun data(): Unit = noImpl
        public open fun findToken(position: Number, includeSkippedTokens: Boolean? = null): PositionedToken = noImpl
        public open fun tryGetEndOfFileAt(position: Any): Unit = noImpl
        public open fun findTokenInternal(parent: Any, position: Any, fullStart: Any): Unit = noImpl
        public open fun findTokenOnLeft(position: Number, includeSkippedTokens: Boolean? = null): PositionedToken = noImpl
        public open fun findCompleteTokenOnLeft(position: Number, includeSkippedTokens: Boolean? = null): PositionedToken = noImpl
        public open fun isModuleElement(): Boolean = noImpl
        public open fun isClassElement(): Boolean = noImpl
        public open fun isTypeMember(): Boolean = noImpl
        public open fun isStatement(): Boolean = noImpl
        public open fun isExpression(): Boolean = noImpl
        public open fun isSwitchClause(): Boolean = noImpl
        public open fun structuralEquals(node: SyntaxNode): Boolean = noImpl
        override fun width(): Number = noImpl
        override fun leadingTriviaWidth(): Number = noImpl
        override fun trailingTriviaWidth(): Number = noImpl
    }
    public trait ISyntaxNodeOrToken : ISyntaxElement {
        public fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken
        public fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken
        public fun accept(visitor: ISyntaxVisitor): Any
    }
    public open class SourceUnitSyntax(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var moduleElements: ISyntaxList = noImpl
        public open var endOfFileToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax = noImpl
        public open fun withModuleElements(moduleElements: ISyntaxList): SourceUnitSyntax = noImpl
        public open fun withModuleElement(moduleElement: IModuleElementSyntax): SourceUnitSyntax = noImpl
        public open fun withEndOfFileToken(endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
            public fun create1(endOfFileToken: ISyntaxToken): SourceUnitSyntax = noImpl
        }
    }
    public open class ExternalModuleReferenceSyntax(requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleReferenceSyntax {
        public open var requireKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var stringLiteral: ISyntaxToken = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleReference(): Boolean = noImpl
        public open fun update(requireKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax = noImpl
        public open fun withRequireKeyword(requireKeyword: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        public open fun withStringLiteral(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax = noImpl
        }
    }
    public open class ModuleNameModuleReferenceSyntax(moduleName: INameSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleReferenceSyntax {
        public open var moduleName: INameSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleReference(): Boolean = noImpl
        public open fun update(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax = noImpl
        public open fun withModuleName(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ImportDeclarationSyntax(modifiers: ISyntaxList, importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var importKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var equalsToken: ISyntaxToken = noImpl
        public open var moduleReference: IModuleReferenceSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): ImportDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): ImportDeclarationSyntax = noImpl
        public open fun withImportKeyword(importKeyword: ISyntaxToken): ImportDeclarationSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): ImportDeclarationSyntax = noImpl
        public open fun withEqualsToken(equalsToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
        public open fun withModuleReference(moduleReference: IModuleReferenceSyntax): ImportDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: IModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax = noImpl
            public fun create1(identifier: ISyntaxToken, moduleReference: IModuleReferenceSyntax): ImportDeclarationSyntax = noImpl
        }
    }
    public open class ExportAssignmentSyntax(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var exportKeyword: ISyntaxToken = noImpl
        public open var equalsToken: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ExportAssignmentSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ExportAssignmentSyntax = noImpl
        public open fun withExportKeyword(exportKeyword: ISyntaxToken): ExportAssignmentSyntax = noImpl
        public open fun withEqualsToken(equalsToken: ISyntaxToken): ExportAssignmentSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): ExportAssignmentSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ExportAssignmentSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(identifier: ISyntaxToken): ExportAssignmentSyntax = noImpl
        }
    }
    public open class ClassDeclarationSyntax(modifiers: ISyntaxList, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var classKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var typeParameterList: TypeParameterListSyntax = noImpl
        public open var heritageClauses: ISyntaxList = noImpl
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var classElements: ISyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): ClassDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): ClassDeclarationSyntax = noImpl
        public open fun withClassKeyword(classKeyword: ISyntaxToken): ClassDeclarationSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): ClassDeclarationSyntax = noImpl
        public open fun withTypeParameterList(typeParameterList: TypeParameterListSyntax): ClassDeclarationSyntax = noImpl
        public open fun withHeritageClauses(heritageClauses: ISyntaxList): ClassDeclarationSyntax = noImpl
        public open fun withHeritageClause(heritageClause: HeritageClauseSyntax): ClassDeclarationSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
        public open fun withClassElements(classElements: ISyntaxList): ClassDeclarationSyntax = noImpl
        public open fun withClassElement(classElement: IClassElementSyntax): ClassDeclarationSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(classKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): ClassDeclarationSyntax = noImpl
        }
    }
    public open class InterfaceDeclarationSyntax(modifiers: ISyntaxList, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, body: ObjectTypeSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var interfaceKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var typeParameterList: TypeParameterListSyntax = noImpl
        public open var heritageClauses: ISyntaxList = noImpl
        public open var body: ObjectTypeSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: ISyntaxList, body: ObjectTypeSyntax): InterfaceDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): InterfaceDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): InterfaceDeclarationSyntax = noImpl
        public open fun withInterfaceKeyword(interfaceKeyword: ISyntaxToken): InterfaceDeclarationSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): InterfaceDeclarationSyntax = noImpl
        public open fun withTypeParameterList(typeParameterList: TypeParameterListSyntax): InterfaceDeclarationSyntax = noImpl
        public open fun withHeritageClauses(heritageClauses: ISyntaxList): InterfaceDeclarationSyntax = noImpl
        public open fun withHeritageClause(heritageClause: HeritageClauseSyntax): InterfaceDeclarationSyntax = noImpl
        public open fun withBody(body: ObjectTypeSyntax): InterfaceDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, body: ObjectTypeSyntax): InterfaceDeclarationSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): InterfaceDeclarationSyntax = noImpl
        }
    }
    public open class HeritageClauseSyntax(kind: SyntaxKind, extendsOrImplementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var extendsOrImplementsKeyword: ISyntaxToken = noImpl
        public open var typeNames: ISeparatedSyntaxList = noImpl
        public open var _kind: Any = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun kind(): SyntaxKind = noImpl
        public open fun update(kind: SyntaxKind, extendsOrImplementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): HeritageClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): HeritageClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): HeritageClauseSyntax = noImpl
        public open fun withKind(kind: SyntaxKind): HeritageClauseSyntax = noImpl
        public open fun withExtendsOrImplementsKeyword(extendsOrImplementsKeyword: ISyntaxToken): HeritageClauseSyntax = noImpl
        public open fun withTypeNames(typeNames: ISeparatedSyntaxList): HeritageClauseSyntax = noImpl
        public open fun withTypeName(typeName: INameSyntax): HeritageClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ModuleDeclarationSyntax(modifiers: ISyntaxList, moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var moduleKeyword: ISyntaxToken = noImpl
        public open var name: INameSyntax = noImpl
        public open var stringLiteral: ISyntaxToken = noImpl
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var moduleElements: ISyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, moduleKeyword: ISyntaxToken, name: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): ModuleDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        public open fun withModuleKeyword(moduleKeyword: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        public open fun withName(name: INameSyntax): ModuleDeclarationSyntax = noImpl
        public open fun withStringLiteral(stringLiteral: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        public open fun withModuleElements(moduleElements: ISyntaxList): ModuleDeclarationSyntax = noImpl
        public open fun withModuleElement(moduleElement: IModuleElementSyntax): ModuleDeclarationSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(moduleKeyword: ISyntaxToken, openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax = noImpl
            public fun create1(): ModuleDeclarationSyntax = noImpl
        }
    }
    public open class FunctionDeclarationSyntax(modifiers: ISyntaxList, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var functionKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): FunctionDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        public open fun withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): FunctionDeclarationSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): FunctionDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax): FunctionDeclarationSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): FunctionDeclarationSyntax = noImpl
        }
    }
    public open class VariableStatementSyntax(modifiers: ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var variableDeclaration: VariableDeclarationSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): VariableStatementSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): VariableStatementSyntax = noImpl
        public open fun withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): VariableStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax = noImpl
            public fun create1(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax = noImpl
        }
    }
    public open class VariableDeclarationSyntax(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var varKeyword: ISyntaxToken = noImpl
        public open var variableDeclarators: ISeparatedSyntaxList = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax = noImpl
        public open fun withVarKeyword(varKeyword: ISyntaxToken): VariableDeclarationSyntax = noImpl
        public open fun withVariableDeclarators(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax = noImpl
        public open fun withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): VariableDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax = noImpl
        }
    }
    public open class VariableDeclaratorSyntax(propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var propertyName: ISyntaxToken = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        public open var equalsValueClause: EqualsValueClauseSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(propertyName: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): VariableDeclaratorSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): VariableDeclaratorSyntax = noImpl
        public open fun withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(propertyName: ISyntaxToken): VariableDeclaratorSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): VariableDeclaratorSyntax = noImpl
        }
    }
    public open class EqualsValueClauseSyntax(equalsToken: ISyntaxToken, value: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var equalsToken: ISyntaxToken = noImpl
        public open var value: IExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax = noImpl
        public open fun withEqualsToken(equalsToken: ISyntaxToken): EqualsValueClauseSyntax = noImpl
        public open fun withValue(value: IExpressionSyntax): EqualsValueClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(value: IExpressionSyntax): EqualsValueClauseSyntax = noImpl
        }
    }
    public open class PrefixUnaryExpressionSyntax(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IUnaryExpressionSyntax {
        public open var operatorToken: ISyntaxToken = noImpl
        public open var operand: IUnaryExpressionSyntax = noImpl
        public open var _kind: Any = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        override fun kind(): SyntaxKind = noImpl
        public open fun update(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax = noImpl
        public open fun withKind(kind: SyntaxKind): PrefixUnaryExpressionSyntax = noImpl
        public open fun withOperatorToken(operatorToken: ISyntaxToken): PrefixUnaryExpressionSyntax = noImpl
        public open fun withOperand(operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ArrayLiteralExpressionSyntax(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPrimaryExpressionSyntax {
        public open var openBracketToken: ISyntaxToken = noImpl
        public open var expressions: ISeparatedSyntaxList = noImpl
        public open var closeBracketToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isPrimaryExpression(): Boolean = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax = noImpl
        public open fun withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
        public open fun withExpressions(expressions: ISeparatedSyntaxList): ArrayLiteralExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ArrayLiteralExpressionSyntax = noImpl
        public open fun withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax = noImpl
            public fun create1(): ArrayLiteralExpressionSyntax = noImpl
        }
    }
    public open class OmittedExpressionSyntax(parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IExpressionSyntax {
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(): OmittedExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ParenthesizedExpressionSyntax(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPrimaryExpressionSyntax {
        public open var openParenToken: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isPrimaryExpression(): Boolean = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ParenthesizedExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ParenthesizedExpressionSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IExpressionSyntax): ParenthesizedExpressionSyntax = noImpl
        }
    }
    public open class SimpleArrowFunctionExpressionSyntax(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IArrowFunctionExpressionSyntax {
        public open var identifier: ISyntaxToken = noImpl
        override var equalsGreaterThanToken: ISyntaxToken = noImpl
        override var block: BlockSyntax = noImpl
        override var expression: IExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isArrowFunctionExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): SimpleArrowFunctionExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): SimpleArrowFunctionExpressionSyntax = noImpl
        public open fun withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): SimpleArrowFunctionExpressionSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): SimpleArrowFunctionExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): SimpleArrowFunctionExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken): SimpleArrowFunctionExpressionSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): SimpleArrowFunctionExpressionSyntax = noImpl
        }
    }
    public open class ParenthesizedArrowFunctionExpressionSyntax(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IArrowFunctionExpressionSyntax {
        public open var callSignature: CallSignatureSyntax = noImpl
        override var equalsGreaterThanToken: ISyntaxToken = noImpl
        override var block: BlockSyntax = noImpl
        override var expression: IExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isArrowFunctionExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, block: BlockSyntax, expression: IExpressionSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        public open fun withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken): ParenthesizedArrowFunctionExpressionSyntax = noImpl
            public fun create1(): ParenthesizedArrowFunctionExpressionSyntax = noImpl
        }
    }
    public open class QualifiedNameSyntax(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), INameSyntax {
        public open var left: INameSyntax = noImpl
        public open var dotToken: ISyntaxToken = noImpl
        public open var right: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isName(): Boolean = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax = noImpl
        public open fun withLeft(left: INameSyntax): QualifiedNameSyntax = noImpl
        public open fun withDotToken(dotToken: ISyntaxToken): QualifiedNameSyntax = noImpl
        public open fun withRight(right: ISyntaxToken): QualifiedNameSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(left: INameSyntax, right: ISyntaxToken): QualifiedNameSyntax = noImpl
        }
    }
    public open class TypeArgumentListSyntax(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var lessThanToken: ISyntaxToken = noImpl
        public open var typeArguments: ISeparatedSyntaxList = noImpl
        public open var greaterThanToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax = noImpl
        public open fun withLessThanToken(lessThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
        public open fun withTypeArguments(typeArguments: ISeparatedSyntaxList): TypeArgumentListSyntax = noImpl
        public open fun withTypeArgument(typeArgument: ITypeSyntax): TypeArgumentListSyntax = noImpl
        public open fun withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(lessThanToken: ISyntaxToken, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax = noImpl
            public fun create1(): TypeArgumentListSyntax = noImpl
        }
    }
    public open class ConstructorTypeSyntax(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var newKeyword: ISyntaxToken = noImpl
        public open var typeParameterList: TypeParameterListSyntax = noImpl
        public open var parameterList: ParameterListSyntax = noImpl
        public open var equalsGreaterThanToken: ISyntaxToken = noImpl
        public open var `type`: ITypeSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax = noImpl
        public open fun withNewKeyword(newKeyword: ISyntaxToken): ConstructorTypeSyntax = noImpl
        public open fun withTypeParameterList(typeParameterList: TypeParameterListSyntax): ConstructorTypeSyntax = noImpl
        public open fun withParameterList(parameterList: ParameterListSyntax): ConstructorTypeSyntax = noImpl
        public open fun withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ConstructorTypeSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(newKeyword: ISyntaxToken, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
            public fun create1(`type`: ITypeSyntax): ConstructorTypeSyntax = noImpl
        }
    }
    public open class FunctionTypeSyntax(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var typeParameterList: TypeParameterListSyntax = noImpl
        public open var parameterList: ParameterListSyntax = noImpl
        public open var equalsGreaterThanToken: ISyntaxToken = noImpl
        public open var `type`: ITypeSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): FunctionTypeSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax = noImpl
        public open fun withTypeParameterList(typeParameterList: TypeParameterListSyntax): FunctionTypeSyntax = noImpl
        public open fun withParameterList(parameterList: ParameterListSyntax): FunctionTypeSyntax = noImpl
        public open fun withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): FunctionTypeSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): FunctionTypeSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, `type`: ITypeSyntax): FunctionTypeSyntax = noImpl
            public fun create1(`type`: ITypeSyntax): FunctionTypeSyntax = noImpl
        }
    }
    public open class ObjectTypeSyntax(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var typeMembers: ISeparatedSyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
        public open fun withTypeMembers(typeMembers: ISeparatedSyntaxList): ObjectTypeSyntax = noImpl
        public open fun withTypeMember(typeMember: ITypeMemberSyntax): ObjectTypeSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): ObjectTypeSyntax = noImpl
            public fun create1(): ObjectTypeSyntax = noImpl
        }
    }
    public open class ArrayTypeSyntax(`type`: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var `type`: ITypeSyntax = noImpl
        public open var openBracketToken: ISyntaxToken = noImpl
        public open var closeBracketToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(`type`: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): ArrayTypeSyntax = noImpl
        public open fun withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayTypeSyntax = noImpl
        public open fun withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayTypeSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(`type`: ITypeSyntax): ArrayTypeSyntax = noImpl
        }
    }
    public open class GenericTypeSyntax(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var name: INameSyntax = noImpl
        public open var typeArgumentList: TypeArgumentListSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax = noImpl
        public open fun withName(name: INameSyntax): GenericTypeSyntax = noImpl
        public open fun withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(name: INameSyntax): GenericTypeSyntax = noImpl
        }
    }
    public open class TypeQuerySyntax(typeOfKeyword: ISyntaxToken, name: INameSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeSyntax {
        public open var typeOfKeyword: ISyntaxToken = noImpl
        public open var name: INameSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun update(typeOfKeyword: ISyntaxToken, name: INameSyntax): TypeQuerySyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeQuerySyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeQuerySyntax = noImpl
        public open fun withTypeOfKeyword(typeOfKeyword: ISyntaxToken): TypeQuerySyntax = noImpl
        public open fun withName(name: INameSyntax): TypeQuerySyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(name: INameSyntax): TypeQuerySyntax = noImpl
        }
    }
    public open class TypeAnnotationSyntax(colonToken: ISyntaxToken, `type`: ITypeSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var colonToken: ISyntaxToken = noImpl
        public open var `type`: ITypeSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(colonToken: ISyntaxToken, `type`: ITypeSyntax): TypeAnnotationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): TypeAnnotationSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): TypeAnnotationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(`type`: ITypeSyntax): TypeAnnotationSyntax = noImpl
        }
    }
    public open class BlockSyntax(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var statements: ISyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): BlockSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): BlockSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): BlockSyntax = noImpl
        public open fun withStatements(statements: ISyntaxList): BlockSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): BlockSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): BlockSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): BlockSyntax = noImpl
            public fun create1(): BlockSyntax = noImpl
        }
    }
    public open class ParameterSyntax(dotDotDotToken: ISyntaxToken, modifiers: ISyntaxList, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var dotDotDotToken: ISyntaxToken = noImpl
        public open var modifiers: ISyntaxList = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var questionToken: ISyntaxToken = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        public open var equalsValueClause: EqualsValueClauseSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(dotDotDotToken: ISyntaxToken, modifiers: ISyntaxList, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax = noImpl
        public open fun withDotDotDotToken(dotDotDotToken: ISyntaxToken): ParameterSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): ParameterSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): ParameterSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): ParameterSyntax = noImpl
        public open fun withQuestionToken(questionToken: ISyntaxToken): ParameterSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): ParameterSyntax = noImpl
        public open fun withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(identifier: ISyntaxToken): ParameterSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): ParameterSyntax = noImpl
        }
    }
    public open class MemberAccessExpressionSyntax(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberExpressionSyntax {
        public open var expression: IExpressionSyntax = noImpl
        public open var dotToken: ISyntaxToken = noImpl
        public open var name: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): MemberAccessExpressionSyntax = noImpl
        public open fun withDotToken(dotToken: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
        public open fun withName(name: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IExpressionSyntax, name: ISyntaxToken): MemberAccessExpressionSyntax = noImpl
        }
    }
    public open class PostfixUnaryExpressionSyntax(kind: SyntaxKind, operand: IMemberExpressionSyntax, operatorToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPostfixExpressionSyntax {
        public open var operand: IMemberExpressionSyntax = noImpl
        public open var operatorToken: ISyntaxToken = noImpl
        public open var _kind: Any = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        override fun kind(): SyntaxKind = noImpl
        public open fun update(kind: SyntaxKind, operand: IMemberExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax = noImpl
        public open fun withKind(kind: SyntaxKind): PostfixUnaryExpressionSyntax = noImpl
        public open fun withOperand(operand: IMemberExpressionSyntax): PostfixUnaryExpressionSyntax = noImpl
        public open fun withOperatorToken(operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ElementAccessExpressionSyntax(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberExpressionSyntax {
        public open var expression: IExpressionSyntax = noImpl
        public open var openBracketToken: ISyntaxToken = noImpl
        public open var argumentExpression: IExpressionSyntax = noImpl
        public open var closeBracketToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ElementAccessExpressionSyntax = noImpl
        public open fun withOpenBracketToken(openBracketToken: ISyntaxToken): ElementAccessExpressionSyntax = noImpl
        public open fun withArgumentExpression(argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax = noImpl
        public open fun withCloseBracketToken(closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IExpressionSyntax, argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax = noImpl
        }
    }
    public open class InvocationExpressionSyntax(expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberExpressionSyntax {
        public open var expression: IMemberExpressionSyntax = noImpl
        public open var argumentList: ArgumentListSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax = noImpl
        public open fun withExpression(expression: IMemberExpressionSyntax): InvocationExpressionSyntax = noImpl
        public open fun withArgumentList(argumentList: ArgumentListSyntax): InvocationExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IMemberExpressionSyntax): InvocationExpressionSyntax = noImpl
        }
    }
    public open class ArgumentListSyntax(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var typeArgumentList: TypeArgumentListSyntax = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var arguments: ISeparatedSyntaxList = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax = noImpl
        public open fun withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
        public open fun withArguments(_arguments: ISeparatedSyntaxList): ArgumentListSyntax = noImpl
        public open fun withArgument(_argument: IExpressionSyntax): ArgumentListSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken): ArgumentListSyntax = noImpl
            public fun create1(): ArgumentListSyntax = noImpl
        }
    }
    public open class BinaryExpressionSyntax(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IExpressionSyntax {
        public open var left: IExpressionSyntax = noImpl
        public open var operatorToken: ISyntaxToken = noImpl
        public open var right: IExpressionSyntax = noImpl
        public open var _kind: Any = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isExpression(): Boolean = noImpl
        override fun kind(): SyntaxKind = noImpl
        public open fun update(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax = noImpl
        public open fun withKind(kind: SyntaxKind): BinaryExpressionSyntax = noImpl
        public open fun withLeft(left: IExpressionSyntax): BinaryExpressionSyntax = noImpl
        public open fun withOperatorToken(operatorToken: ISyntaxToken): BinaryExpressionSyntax = noImpl
        public open fun withRight(right: IExpressionSyntax): BinaryExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
    }
    public open class ConditionalExpressionSyntax(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IExpressionSyntax {
        public open var condition: IExpressionSyntax = noImpl
        public open var questionToken: ISyntaxToken = noImpl
        public open var whenTrue: IExpressionSyntax = noImpl
        public open var colonToken: ISyntaxToken = noImpl
        public open var whenFalse: IExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
        public open fun withQuestionToken(questionToken: ISyntaxToken): ConditionalExpressionSyntax = noImpl
        public open fun withWhenTrue(whenTrue: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): ConditionalExpressionSyntax = noImpl
        public open fun withWhenFalse(whenFalse: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(condition: IExpressionSyntax, whenTrue: IExpressionSyntax, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax = noImpl
        }
    }
    public open class ConstructSignatureSyntax(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeMemberSyntax {
        public open var newKeyword: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isTypeMember(): Boolean = noImpl
        public open fun update(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax = noImpl
        public open fun withNewKeyword(newKeyword: ISyntaxToken): ConstructSignatureSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): ConstructSignatureSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(): ConstructSignatureSyntax = noImpl
        }
    }
    public open class MethodSignatureSyntax(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeMemberSyntax {
        public open var propertyName: ISyntaxToken = noImpl
        public open var questionToken: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isTypeMember(): Boolean = noImpl
        public open fun update(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): MethodSignatureSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): MethodSignatureSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): MethodSignatureSyntax = noImpl
        public open fun withQuestionToken(questionToken: ISyntaxToken): MethodSignatureSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): MethodSignatureSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): MethodSignatureSyntax = noImpl
        }
    }
    public open class IndexSignatureSyntax(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeMemberSyntax {
        public open var openBracketToken: ISyntaxToken = noImpl
        public open var parameter: ParameterSyntax = noImpl
        public open var closeBracketToken: ISyntaxToken = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isTypeMember(): Boolean = noImpl
        public open fun update(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax = noImpl
        public open fun withOpenBracketToken(openBracketToken: ISyntaxToken): IndexSignatureSyntax = noImpl
        public open fun withParameter(parameter: ParameterSyntax): IndexSignatureSyntax = noImpl
        public open fun withCloseBracketToken(closeBracketToken: ISyntaxToken): IndexSignatureSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken): IndexSignatureSyntax = noImpl
            public fun create1(parameter: ParameterSyntax): IndexSignatureSyntax = noImpl
        }
    }
    public open class PropertySignatureSyntax(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeMemberSyntax {
        public open var propertyName: ISyntaxToken = noImpl
        public open var questionToken: ISyntaxToken = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isTypeMember(): Boolean = noImpl
        public open fun update(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): PropertySignatureSyntax = noImpl
        public open fun withQuestionToken(questionToken: ISyntaxToken): PropertySignatureSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(propertyName: ISyntaxToken): PropertySignatureSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): PropertySignatureSyntax = noImpl
        }
    }
    public open class CallSignatureSyntax(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ITypeMemberSyntax {
        public open var typeParameterList: TypeParameterListSyntax = noImpl
        public open var parameterList: ParameterListSyntax = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isTypeMember(): Boolean = noImpl
        public open fun update(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax = noImpl
        public open fun withTypeParameterList(typeParameterList: TypeParameterListSyntax): CallSignatureSyntax = noImpl
        public open fun withParameterList(parameterList: ParameterListSyntax): CallSignatureSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(parameterList: ParameterListSyntax): CallSignatureSyntax = noImpl
            public fun create1(): CallSignatureSyntax = noImpl
        }
    }
    public open class ParameterListSyntax(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var openParenToken: ISyntaxToken = noImpl
        public open var parameters: ISeparatedSyntaxList = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ParameterListSyntax = noImpl
        public open fun withParameters(parameters: ISeparatedSyntaxList): ParameterListSyntax = noImpl
        public open fun withParameter(parameter: ParameterSyntax): ParameterListSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ParameterListSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken): ParameterListSyntax = noImpl
            public fun create1(): ParameterListSyntax = noImpl
        }
    }
    public open class TypeParameterListSyntax(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var lessThanToken: ISyntaxToken = noImpl
        public open var typeParameters: ISeparatedSyntaxList = noImpl
        public open var greaterThanToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax = noImpl
        public open fun withLessThanToken(lessThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
        public open fun withTypeParameters(typeParameters: ISeparatedSyntaxList): TypeParameterListSyntax = noImpl
        public open fun withTypeParameter(typeParameter: TypeParameterSyntax): TypeParameterListSyntax = noImpl
        public open fun withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(lessThanToken: ISyntaxToken, greaterThanToken: ISyntaxToken): TypeParameterListSyntax = noImpl
            public fun create1(): TypeParameterListSyntax = noImpl
        }
    }
    public open class TypeParameterSyntax(identifier: ISyntaxToken, constraint: ConstraintSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var identifier: ISyntaxToken = noImpl
        public open var constraint: ConstraintSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): TypeParameterSyntax = noImpl
        public open fun withConstraint(constraint: ConstraintSyntax): TypeParameterSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(identifier: ISyntaxToken): TypeParameterSyntax = noImpl
            public fun create1(identifier: ISyntaxToken): TypeParameterSyntax = noImpl
        }
    }
    public open class ConstraintSyntax(extendsKeyword: ISyntaxToken, `type`: ITypeSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var extendsKeyword: ISyntaxToken = noImpl
        public open var `type`: ITypeSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(extendsKeyword: ISyntaxToken, `type`: ITypeSyntax): ConstraintSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax = noImpl
        public open fun withExtendsKeyword(extendsKeyword: ISyntaxToken): ConstraintSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): ConstraintSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(`type`: ITypeSyntax): ConstraintSyntax = noImpl
        }
    }
    public open class ElseClauseSyntax(elseKeyword: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var elseKeyword: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax = noImpl
        public open fun withElseKeyword(elseKeyword: ISyntaxToken): ElseClauseSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): ElseClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(statement: IStatementSyntax): ElseClauseSyntax = noImpl
        }
    }
    public open class IfStatementSyntax(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var ifKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var condition: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        public open var elseClause: ElseClauseSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax = noImpl
        public open fun withIfKeyword(ifKeyword: ISyntaxToken): IfStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): IfStatementSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): IfStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): IfStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): IfStatementSyntax = noImpl
        public open fun withElseClause(elseClause: ElseClauseSyntax): IfStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): IfStatementSyntax = noImpl
            public fun create1(condition: IExpressionSyntax, statement: IStatementSyntax): IfStatementSyntax = noImpl
        }
    }
    public open class ExpressionStatementSyntax(expression: IExpressionSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var expression: IExpressionSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ExpressionStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ExpressionStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IExpressionSyntax): ExpressionStatementSyntax = noImpl
        }
    }
    public open class ConstructorDeclarationSyntax(modifiers: ISyntaxList, constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IClassElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var constructorKeyword: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): ConstructorDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
        public open fun withConstructorKeyword(constructorKeyword: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): ConstructorDeclarationSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): ConstructorDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(constructorKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructorDeclarationSyntax = noImpl
            public fun create1(): ConstructorDeclarationSyntax = noImpl
        }
    }
    public open class MemberFunctionDeclarationSyntax(modifiers: ISyntaxList, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberDeclarationSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var propertyName: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isMemberDeclaration(): Boolean = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): MemberFunctionDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): MemberFunctionDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): MemberFunctionDeclarationSyntax = noImpl
        }
    }
    public open class GetAccessorSyntax(modifiers: ISyntaxList, getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberDeclarationSyntax, IPropertyAssignmentSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var getKeyword: ISyntaxToken = noImpl
        public open var propertyName: ISyntaxToken = noImpl
        public open var parameterList: ParameterListSyntax = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isMemberDeclaration(): Boolean = noImpl
        public open fun isPropertyAssignment(): Boolean = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): GetAccessorSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): GetAccessorSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): GetAccessorSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): GetAccessorSyntax = noImpl
        public open fun withGetKeyword(getKeyword: ISyntaxToken): GetAccessorSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): GetAccessorSyntax = noImpl
        public open fun withParameterList(parameterList: ParameterListSyntax): GetAccessorSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetAccessorSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): GetAccessorSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): GetAccessorSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): GetAccessorSyntax = noImpl
        }
    }
    public open class SetAccessorSyntax(modifiers: ISyntaxList, setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberDeclarationSyntax, IPropertyAssignmentSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var setKeyword: ISyntaxToken = noImpl
        public open var propertyName: ISyntaxToken = noImpl
        public open var parameterList: ParameterListSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isMemberDeclaration(): Boolean = noImpl
        public open fun isPropertyAssignment(): Boolean = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetAccessorSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SetAccessorSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SetAccessorSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): SetAccessorSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): SetAccessorSyntax = noImpl
        public open fun withSetKeyword(setKeyword: ISyntaxToken): SetAccessorSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): SetAccessorSyntax = noImpl
        public open fun withParameterList(parameterList: ParameterListSyntax): SetAccessorSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): SetAccessorSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetAccessorSyntax = noImpl
            public fun create1(propertyName: ISyntaxToken): SetAccessorSyntax = noImpl
        }
    }
    public open class MemberVariableDeclarationSyntax(modifiers: ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberDeclarationSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var variableDeclarator: VariableDeclaratorSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isMemberDeclaration(): Boolean = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): MemberVariableDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
        public open fun withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax = noImpl
            public fun create1(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax = noImpl
        }
    }
    public open class IndexMemberDeclarationSyntax(modifiers: ISyntaxList, indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IClassElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var indexSignature: IndexSignatureSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isClassElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): IndexMemberDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): IndexMemberDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): IndexMemberDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
        public open fun withIndexSignature(indexSignature: IndexSignatureSyntax): IndexMemberDeclarationSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(indexSignature: IndexSignatureSyntax, semicolonToken: ISyntaxToken): IndexMemberDeclarationSyntax = noImpl
            public fun create1(indexSignature: IndexSignatureSyntax): IndexMemberDeclarationSyntax = noImpl
        }
    }
    public open class ThrowStatementSyntax(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var throwKeyword: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax = noImpl
        public open fun withThrowKeyword(throwKeyword: ISyntaxToken): ThrowStatementSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ThrowStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ThrowStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IExpressionSyntax): ThrowStatementSyntax = noImpl
        }
    }
    public open class ReturnStatementSyntax(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var returnKeyword: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax = noImpl
        public open fun withReturnKeyword(returnKeyword: ISyntaxToken): ReturnStatementSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ReturnStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ReturnStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(returnKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): ReturnStatementSyntax = noImpl
            public fun create1(): ReturnStatementSyntax = noImpl
        }
    }
    public class objectCreationExpressionSyntax(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IMemberExpressionSyntax {
        public open var newKeyword: ISyntaxToken = noImpl
        public open var expression: IMemberExpressionSyntax = noImpl
        public open var argumentList: ArgumentListSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax = noImpl
        public open fun withNewKeyword(newKeyword: ISyntaxToken): ObjectCreationExpressionSyntax = noImpl
        public open fun withExpression(expression: IMemberExpressionSyntax): ObjectCreationExpressionSyntax = noImpl
        public open fun withArgumentList(argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(newKeyword: ISyntaxToken, expression: IMemberExpressionSyntax): ObjectCreationExpressionSyntax = noImpl
            public fun create1(expression: IMemberExpressionSyntax): ObjectCreationExpressionSyntax = noImpl
        }
    }
    public open class SwitchStatementSyntax(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var switchKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var switchClauses: ISyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax = noImpl
        public open fun withSwitchKeyword(switchKeyword: ISyntaxToken): SwitchStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): SwitchStatementSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): SwitchStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): SwitchStatementSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
        public open fun withSwitchClauses(switchClauses: ISyntaxList): SwitchStatementSyntax = noImpl
        public open fun withSwitchClause(switchClause: ISwitchClauseSyntax): SwitchStatementSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): SwitchStatementSyntax = noImpl
            public fun create1(expression: IExpressionSyntax): SwitchStatementSyntax = noImpl
        }
    }
    public open class CaseSwitchClauseSyntax(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ISwitchClauseSyntax {
        public open var caseKeyword: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var colonToken: ISyntaxToken = noImpl
        override var statements: ISyntaxList = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isSwitchClause(): Boolean = noImpl
        public open fun update(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax = noImpl
        public open fun withCaseKeyword(caseKeyword: ISyntaxToken): CaseSwitchClauseSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): CaseSwitchClauseSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): CaseSwitchClauseSyntax = noImpl
        public open fun withStatements(statements: ISyntaxList): CaseSwitchClauseSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): CaseSwitchClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken): CaseSwitchClauseSyntax = noImpl
            public fun create1(expression: IExpressionSyntax): CaseSwitchClauseSyntax = noImpl
        }
    }
    public open class DefaultSwitchClauseSyntax(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), ISwitchClauseSyntax {
        public open var defaultKeyword: ISyntaxToken = noImpl
        public open var colonToken: ISyntaxToken = noImpl
        override var statements: ISyntaxList = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isSwitchClause(): Boolean = noImpl
        public open fun update(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax = noImpl
        public open fun withDefaultKeyword(defaultKeyword: ISyntaxToken): DefaultSwitchClauseSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): DefaultSwitchClauseSyntax = noImpl
        public open fun withStatements(statements: ISyntaxList): DefaultSwitchClauseSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): DefaultSwitchClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken): DefaultSwitchClauseSyntax = noImpl
            public fun create1(): DefaultSwitchClauseSyntax = noImpl
        }
    }
    public open class BreakStatementSyntax(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var breakKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax = noImpl
        public open fun withBreakKeyword(breakKeyword: ISyntaxToken): BreakStatementSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): BreakStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): BreakStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(breakKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax = noImpl
            public fun create1(): BreakStatementSyntax = noImpl
        }
    }
    public open class ContinueStatementSyntax(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var continueKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax = noImpl
        public open fun withContinueKeyword(continueKeyword: ISyntaxToken): ContinueStatementSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): ContinueStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): ContinueStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(continueKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax = noImpl
            public fun create1(): ContinueStatementSyntax = noImpl
        }
    }
    public open class ForStatementSyntax(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IIterationStatementSyntax {
        public open var forKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var variableDeclaration: VariableDeclarationSyntax = noImpl
        public open var initializer: IExpressionSyntax = noImpl
        public open var firstSemicolonToken: ISyntaxToken = noImpl
        public open var condition: IExpressionSyntax = noImpl
        public open var secondSemicolonToken: ISyntaxToken = noImpl
        public open var incrementor: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isIterationStatement(): Boolean = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax = noImpl
        public open fun withForKeyword(forKeyword: ISyntaxToken): ForStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ForStatementSyntax = noImpl
        public open fun withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForStatementSyntax = noImpl
        public open fun withInitializer(initializer: IExpressionSyntax): ForStatementSyntax = noImpl
        public open fun withFirstSemicolonToken(firstSemicolonToken: ISyntaxToken): ForStatementSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): ForStatementSyntax = noImpl
        public open fun withSecondSemicolonToken(secondSemicolonToken: ISyntaxToken): ForStatementSyntax = noImpl
        public open fun withIncrementor(incrementor: IExpressionSyntax): ForStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ForStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): ForStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, firstSemicolonToken: ISyntaxToken, secondSemicolonToken: ISyntaxToken, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax = noImpl
            public open fun create1(statement: IStatementSyntax): ForStatementSyntax = noImpl
        }
    }
    public open class ForInStatementSyntax(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IIterationStatementSyntax {
        public open var forKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var variableDeclaration: VariableDeclarationSyntax = noImpl
        public open var left: IExpressionSyntax = noImpl
        public open var inKeyword: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isIterationStatement(): Boolean = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax = noImpl
        public open fun withForKeyword(forKeyword: ISyntaxToken): ForInStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): ForInStatementSyntax = noImpl
        public open fun withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForInStatementSyntax = noImpl
        public open fun withLeft(left: IExpressionSyntax): ForInStatementSyntax = noImpl
        public open fun withInKeyword(inKeyword: ISyntaxToken): ForInStatementSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): ForInStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): ForInStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): ForInStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax = noImpl
            public open fun create1(expression: IExpressionSyntax, statement: IStatementSyntax): ForInStatementSyntax = noImpl
        }
    }
    public open class WhileStatementSyntax(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IIterationStatementSyntax {
        public open var whileKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var condition: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isIterationStatement(): Boolean = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax = noImpl
        public open fun withWhileKeyword(whileKeyword: ISyntaxToken): WhileStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): WhileStatementSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): WhileStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): WhileStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): WhileStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(condition: IExpressionSyntax, statement: IStatementSyntax): WhileStatementSyntax = noImpl
        }
    }
    public open class WithStatementSyntax(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var withKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var condition: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax = noImpl
        public open fun withWithKeyword(withKeyword: ISyntaxToken): WithStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): WithStatementSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): WithStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): WithStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): WithStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(condition: IExpressionSyntax, statement: IStatementSyntax): WithStatementSyntax = noImpl
        }
    }
    public open class EnumDeclarationSyntax(modifiers: ISyntaxList, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IModuleElementSyntax {
        public open var modifiers: ISyntaxList = noImpl
        public open var enumKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var enumElements: ISeparatedSyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(modifiers: ISyntaxList, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax = noImpl
        public open fun withModifiers(modifiers: ISyntaxList): EnumDeclarationSyntax = noImpl
        public open fun withModifier(modifier: ISyntaxToken): EnumDeclarationSyntax = noImpl
        public open fun withEnumKeyword(enumKeyword: ISyntaxToken): EnumDeclarationSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): EnumDeclarationSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
        public open fun withEnumElements(enumElements: ISeparatedSyntaxList): EnumDeclarationSyntax = noImpl
        public open fun withEnumElement(enumElement: EnumElementSyntax): EnumDeclarationSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax = noImpl
            public open fun create1(identifier: ISyntaxToken): EnumDeclarationSyntax = noImpl
        }
    }
    public open class EnumElementSyntax(propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var propertyName: ISyntaxToken = noImpl
        public open var equalsValueClause: EqualsValueClauseSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(propertyName: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): EnumElementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): EnumElementSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): EnumElementSyntax = noImpl
        public open fun withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(propertyName: ISyntaxToken): EnumElementSyntax = noImpl
            public open fun create1(propertyName: ISyntaxToken): EnumElementSyntax = noImpl
        }
    }
    public open class CastExpressionSyntax(lessThanToken: ISyntaxToken, `type`: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IUnaryExpressionSyntax {
        public open var lessThanToken: ISyntaxToken = noImpl
        public open var `type`: ITypeSyntax = noImpl
        public open var greaterThanToken: ISyntaxToken = noImpl
        public open var expression: IUnaryExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(lessThanToken: ISyntaxToken, `type`: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax = noImpl
        public open fun withLessThanToken(lessThanToken: ISyntaxToken): CastExpressionSyntax = noImpl
        public open fun withType(`type`: ITypeSyntax): CastExpressionSyntax = noImpl
        public open fun withGreaterThanToken(greaterThanToken: ISyntaxToken): CastExpressionSyntax = noImpl
        public open fun withExpression(expression: IUnaryExpressionSyntax): CastExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(`type`: ITypeSyntax, expression: IUnaryExpressionSyntax): CastExpressionSyntax = noImpl
        }
    }
    public open class ObjectLiteralExpressionSyntax(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPrimaryExpressionSyntax {
        public open var openBraceToken: ISyntaxToken = noImpl
        public open var propertyAssignments: ISeparatedSyntaxList = noImpl
        public open var closeBraceToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isPrimaryExpression(): Boolean = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax = noImpl
        public open fun withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
        public open fun withPropertyAssignments(propertyAssignments: ISeparatedSyntaxList): ObjectLiteralExpressionSyntax = noImpl
        public open fun withPropertyAssignment(propertyAssignment: IPropertyAssignmentSyntax): ObjectLiteralExpressionSyntax = noImpl
        public open fun withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(openBraceToken: ISyntaxToken, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax = noImpl
            public fun create1(): ObjectLiteralExpressionSyntax = noImpl
        }
    }
    public open class SimplePropertyAssignmentSyntax(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPropertyAssignmentSyntax {
        public open var propertyName: ISyntaxToken = noImpl
        public open var colonToken: ISyntaxToken = noImpl
        public open var expression: IExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isPropertyAssignment(): Boolean = noImpl
        public open fun update(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): SimplePropertyAssignmentSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): SimplePropertyAssignmentSyntax = noImpl
        public open fun withExpression(expression: IExpressionSyntax): SimplePropertyAssignmentSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(propertyName: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax = noImpl
        }
    }
    public open class FunctionPropertyAssignmentSyntax(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPropertyAssignmentSyntax {
        public open var propertyName: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun isPropertyAssignment(): Boolean = noImpl
        public open fun update(propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionPropertyAssignmentSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionPropertyAssignmentSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionPropertyAssignmentSyntax = noImpl
        public open fun withPropertyName(propertyName: ISyntaxToken): FunctionPropertyAssignmentSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): FunctionPropertyAssignmentSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): FunctionPropertyAssignmentSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(propertyName: ISyntaxToken): FunctionPropertyAssignmentSyntax = noImpl
        }
    }
    public open class FunctionExpressionSyntax(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IPrimaryExpressionSyntax {
        public open var functionKeyword: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var callSignature: CallSignatureSyntax = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isPrimaryExpression(): Boolean = noImpl
        override fun isMemberExpression(): Boolean = noImpl
        override fun isPostfixExpression(): Boolean = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax = noImpl
        public open fun withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionExpressionSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): FunctionExpressionSyntax = noImpl
        public open fun withCallSignature(callSignature: CallSignatureSyntax): FunctionExpressionSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): FunctionExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(functionKeyword: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax = noImpl
            public fun create1(): FunctionExpressionSyntax = noImpl
        }
    }
    public open class EmptyStatementSyntax(semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(semicolonToken: ISyntaxToken): EmptyStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): EmptyStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(): EmptyStatementSyntax = noImpl
        }
    }
    public open class TryStatementSyntax(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var tryKeyword: ISyntaxToken = noImpl
        public open var block: BlockSyntax = noImpl
        public open var catchClause: CatchClauseSyntax = noImpl
        public open var finallyClause: FinallyClauseSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax = noImpl
        public open fun withTryKeyword(tryKeyword: ISyntaxToken): TryStatementSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): TryStatementSyntax = noImpl
        public open fun withCatchClause(catchClause: CatchClauseSyntax): TryStatementSyntax = noImpl
        public open fun withFinallyClause(finallyClause: FinallyClauseSyntax): TryStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(tryKeyword: ISyntaxToken, block: BlockSyntax): TryStatementSyntax = noImpl
            public fun create1(): TryStatementSyntax = noImpl
        }
    }
    public open class CatchClauseSyntax(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var catchKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var identifier: ISyntaxToken = noImpl
        public open var typeAnnotation: TypeAnnotationSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax = noImpl
        public open fun withCatchKeyword(catchKeyword: ISyntaxToken): CatchClauseSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): CatchClauseSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): CatchClauseSyntax = noImpl
        public open fun withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CatchClauseSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): CatchClauseSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): CatchClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax = noImpl
            public open fun create1(identifier: ISyntaxToken): CatchClauseSyntax = noImpl
        }
    }
    public open class FinallyClauseSyntax(finallyKeyword: ISyntaxToken, block: BlockSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl) {
        public open var finallyKeyword: ISyntaxToken = noImpl
        public open var block: BlockSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        public open fun update(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax = noImpl
        public open fun withFinallyKeyword(finallyKeyword: ISyntaxToken): FinallyClauseSyntax = noImpl
        public open fun withBlock(block: BlockSyntax): FinallyClauseSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(): FinallyClauseSyntax = noImpl
        }
    }
    public open class LabeledStatementSyntax(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var identifier: ISyntaxToken = noImpl
        public open var colonToken: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax = noImpl
        public open fun withIdentifier(identifier: ISyntaxToken): LabeledStatementSyntax = noImpl
        public open fun withColonToken(colonToken: ISyntaxToken): LabeledStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): LabeledStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(identifier: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax = noImpl
        }
    }
    public open class DoStatementSyntax(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IIterationStatementSyntax {
        public open var doKeyword: ISyntaxToken = noImpl
        public open var statement: IStatementSyntax = noImpl
        public open var whileKeyword: ISyntaxToken = noImpl
        public open var openParenToken: ISyntaxToken = noImpl
        public open var condition: IExpressionSyntax = noImpl
        public open var closeParenToken: ISyntaxToken = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isIterationStatement(): Boolean = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax = noImpl
        public open fun withDoKeyword(doKeyword: ISyntaxToken): DoStatementSyntax = noImpl
        public open fun withStatement(statement: IStatementSyntax): DoStatementSyntax = noImpl
        public open fun withWhileKeyword(whileKeyword: ISyntaxToken): DoStatementSyntax = noImpl
        public open fun withOpenParenToken(openParenToken: ISyntaxToken): DoStatementSyntax = noImpl
        public open fun withCondition(condition: IExpressionSyntax): DoStatementSyntax = noImpl
        public open fun withCloseParenToken(closeParenToken: ISyntaxToken): DoStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): DoStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(statement: IStatementSyntax, condition: IExpressionSyntax): DoStatementSyntax = noImpl
        }
    }
    public open class TypeOfExpressionSyntax(typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IUnaryExpressionSyntax {
        public open var typeOfKeyword: ISyntaxToken = noImpl
        public open var expression: IUnaryExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(typeOfKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax = noImpl
        public open fun withTypeOfKeyword(typeOfKeyword: ISyntaxToken): TypeOfExpressionSyntax = noImpl
        public open fun withExpression(expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IUnaryExpressionSyntax): TypeOfExpressionSyntax = noImpl
        }
    }
    public open class DeleteExpressionSyntax(deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IUnaryExpressionSyntax {
        public open var deleteKeyword: ISyntaxToken = noImpl
        public open var expression: IUnaryExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(deleteKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): DeleteExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax = noImpl
        public open fun withDeleteKeyword(deleteKeyword: ISyntaxToken): DeleteExpressionSyntax = noImpl
        public open fun withExpression(expression: IUnaryExpressionSyntax): DeleteExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IUnaryExpressionSyntax): DeleteExpressionSyntax = noImpl
        }
    }
    public open class VoidExpressionSyntax(voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IUnaryExpressionSyntax {
        public open var voidKeyword: ISyntaxToken = noImpl
        public open var expression: IUnaryExpressionSyntax = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isUnaryExpression(): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
        public open fun update(voidKeyword: ISyntaxToken, expression: IUnaryExpressionSyntax): VoidExpressionSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax = noImpl
        public open fun withVoidKeyword(voidKeyword: ISyntaxToken): VoidExpressionSyntax = noImpl
        public open fun withExpression(expression: IUnaryExpressionSyntax): VoidExpressionSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(expression: IUnaryExpressionSyntax): VoidExpressionSyntax = noImpl
        }
    }
    public open class DebuggerStatementSyntax(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken, parsedInStrictMode: Boolean) : SyntaxNode(noImpl), IStatementSyntax {
        public open var debuggerKeyword: ISyntaxToken = noImpl
        public open var semicolonToken: ISyntaxToken = noImpl
        override fun accept(visitor: ISyntaxVisitor): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun childCount(): Number = noImpl
        override fun childAt(slot: Number): ISyntaxElement = noImpl
        override fun isStatement(): Boolean = noImpl
        override fun isModuleElement(): Boolean = noImpl
        public open fun update(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax = noImpl
        override fun withLeadingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax = noImpl
        override fun withTrailingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax = noImpl
        public open fun withDebuggerKeyword(debuggerKeyword: ISyntaxToken): DebuggerStatementSyntax = noImpl
        public open fun withSemicolonToken(semicolonToken: ISyntaxToken): DebuggerStatementSyntax = noImpl
        override fun isTypeScriptSpecific(): Boolean = noImpl
        public class object {
            public fun create1(): DebuggerStatementSyntax = noImpl
        }
    }
    public open class SyntaxRewriter : ISyntaxVisitor {
        override fun visitToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public open fun visitNode(node: SyntaxNode): SyntaxNode = noImpl
        public open fun visitNodeOrToken(node: ISyntaxNodeOrToken): ISyntaxNodeOrToken = noImpl
        public open fun visitList(list: ISyntaxList): ISyntaxList = noImpl
        public open fun visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList = noImpl
        override fun visitSourceUnit(node: SourceUnitSyntax): Any = noImpl
        override fun visitExternalModuleReference(node: ExternalModuleReferenceSyntax): Any = noImpl
        override fun visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): Any = noImpl
        override fun visitImportDeclaration(node: ImportDeclarationSyntax): Any = noImpl
        override fun visitExportAssignment(node: ExportAssignmentSyntax): Any = noImpl
        override fun visitClassDeclaration(node: ClassDeclarationSyntax): Any = noImpl
        override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Any = noImpl
        override fun visitHeritageClause(node: HeritageClauseSyntax): Any = noImpl
        override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Any = noImpl
        override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Any = noImpl
        override fun visitVariableStatement(node: VariableStatementSyntax): Any = noImpl
        override fun visitVariableDeclaration(node: VariableDeclarationSyntax): Any = noImpl
        override fun visitVariableDeclarator(node: VariableDeclaratorSyntax): Any = noImpl
        override fun visitEqualsValueClause(node: EqualsValueClauseSyntax): Any = noImpl
        override fun visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): Any = noImpl
        override fun visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): Any = noImpl
        override fun visitOmittedExpression(node: OmittedExpressionSyntax): Any = noImpl
        override fun visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): Any = noImpl
        override fun visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): Any = noImpl
        override fun visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): Any = noImpl
        override fun visitQualifiedName(node: QualifiedNameSyntax): Any = noImpl
        override fun visitTypeArgumentList(node: TypeArgumentListSyntax): Any = noImpl
        override fun visitConstructorType(node: ConstructorTypeSyntax): Any = noImpl
        override fun visitFunctionType(node: FunctionTypeSyntax): Any = noImpl
        override fun visitObjectType(node: ObjectTypeSyntax): Any = noImpl
        override fun visitArrayType(node: ArrayTypeSyntax): Any = noImpl
        override fun visitGenericType(node: GenericTypeSyntax): Any = noImpl
        override fun visitTypeQuery(node: TypeQuerySyntax): Any = noImpl
        override fun visitTypeAnnotation(node: TypeAnnotationSyntax): Any = noImpl
        override fun visitBlock(node: BlockSyntax): Any = noImpl
        override fun visitParameter(node: ParameterSyntax): Any = noImpl
        override fun visitMemberAccessExpression(node: MemberAccessExpressionSyntax): Any = noImpl
        override fun visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): Any = noImpl
        override fun visitElementAccessExpression(node: ElementAccessExpressionSyntax): Any = noImpl
        override fun visitInvocationExpression(node: InvocationExpressionSyntax): Any = noImpl
        override fun visitArgumentList(node: ArgumentListSyntax): Any = noImpl
        override fun visitBinaryExpression(node: BinaryExpressionSyntax): Any = noImpl
        override fun visitConditionalExpression(node: ConditionalExpressionSyntax): Any = noImpl
        override fun visitConstructSignature(node: ConstructSignatureSyntax): Any = noImpl
        override fun visitMethodSignature(node: MethodSignatureSyntax): Any = noImpl
        override fun visitIndexSignature(node: IndexSignatureSyntax): Any = noImpl
        override fun visitPropertySignature(node: PropertySignatureSyntax): Any = noImpl
        override fun visitCallSignature(node: CallSignatureSyntax): Any = noImpl
        override fun visitParameterList(node: ParameterListSyntax): Any = noImpl
        override fun visitTypeParameterList(node: TypeParameterListSyntax): Any = noImpl
        override fun visitTypeParameter(node: TypeParameterSyntax): Any = noImpl
        override fun visitConstraint(node: ConstraintSyntax): Any = noImpl
        override fun visitElseClause(node: ElseClauseSyntax): Any = noImpl
        override fun visitIfStatement(node: IfStatementSyntax): Any = noImpl
        override fun visitExpressionStatement(node: ExpressionStatementSyntax): Any = noImpl
        override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Any = noImpl
        override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Any = noImpl
        override fun visitGetAccessor(node: GetAccessorSyntax): Any = noImpl
        override fun visitSetAccessor(node: SetAccessorSyntax): Any = noImpl
        override fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): Any = noImpl
        override fun visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): Any = noImpl
        override fun visitThrowStatement(node: ThrowStatementSyntax): Any = noImpl
        override fun visitReturnStatement(node: ReturnStatementSyntax): Any = noImpl
        override fun visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): Any = noImpl
        override fun visitSwitchStatement(node: SwitchStatementSyntax): Any = noImpl
        override fun visitCaseSwitchClause(node: CaseSwitchClauseSyntax): Any = noImpl
        override fun visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): Any = noImpl
        override fun visitBreakStatement(node: BreakStatementSyntax): Any = noImpl
        override fun visitContinueStatement(node: ContinueStatementSyntax): Any = noImpl
        override fun visitForStatement(node: ForStatementSyntax): Any = noImpl
        override fun visitForInStatement(node: ForInStatementSyntax): Any = noImpl
        override fun visitWhileStatement(node: WhileStatementSyntax): Any = noImpl
        override fun visitWithStatement(node: WithStatementSyntax): Any = noImpl
        override fun visitEnumDeclaration(node: EnumDeclarationSyntax): Any = noImpl
        override fun visitEnumElement(node: EnumElementSyntax): Any = noImpl
        override fun visitCastExpression(node: CastExpressionSyntax): Any = noImpl
        override fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): Any = noImpl
        override fun visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): Any = noImpl
        override fun visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): Any = noImpl
        override fun visitFunctionExpression(node: FunctionExpressionSyntax): Any = noImpl
        override fun visitEmptyStatement(node: EmptyStatementSyntax): Any = noImpl
        override fun visitTryStatement(node: TryStatementSyntax): Any = noImpl
        override fun visitCatchClause(node: CatchClauseSyntax): Any = noImpl
        override fun visitFinallyClause(node: FinallyClauseSyntax): Any = noImpl
        override fun visitLabeledStatement(node: LabeledStatementSyntax): Any = noImpl
        override fun visitDoStatement(node: DoStatementSyntax): Any = noImpl
        override fun visitTypeOfExpression(node: TypeOfExpressionSyntax): Any = noImpl
        override fun visitDeleteExpression(node: DeleteExpressionSyntax): Any = noImpl
        override fun visitVoidExpression(node: VoidExpressionSyntax): Any = noImpl
        override fun visitDebuggerStatement(node: DebuggerStatementSyntax): Any = noImpl
    }
    public open class SyntaxDedenter(dedentFirstToken: Boolean, dedentationAmount: Number, minimumIndent: Number, options: FormattingOptions) : SyntaxRewriter() {
        public open var dedentationAmount: Any = noImpl
        public open var minimumIndent: Any = noImpl
        public open var options: Any = noImpl
        public open var lastTriviaWasNewLine: Any = noImpl
        public open fun abort(): Unit = noImpl
        public open fun isAborted(): Unit = noImpl
        override fun visitToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public open fun dedentTriviaList(triviaList: Any): Unit = noImpl
        public open fun dedentSegment(segment: Any, hasFollowingNewLineTrivia: Any): Unit = noImpl
        public open fun dedentWhitespace(trivia: Any, hasFollowingNewLineTrivia: Any): Unit = noImpl
        public open fun dedentMultiLineComment(trivia: Any): Unit = noImpl
        public class object {
            public open fun dedentNode(node: ISyntaxNode, dedentFirstToken: Boolean, dedentAmount: Number, minimumIndent: Number, options: FormattingOptions): ISyntaxNode = noImpl
        }
    }
    public open class SyntaxIndenter(indentFirstToken: Boolean, indentationAmount: Number, options: FormattingOptions) : SyntaxRewriter() {
        public open var indentationAmount: Any = noImpl
        public open var options: Any = noImpl
        public open var lastTriviaWasNewLine: Any = noImpl
        public open var indentationTrivia: Any = noImpl
        override fun visitToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public open fun indentTriviaList(triviaList: ISyntaxTriviaList): ISyntaxTriviaList = noImpl
        public open fun indentSegment(segment: Any): Unit = noImpl
        public open fun indentWhitespace(trivia: Any, indentThisTrivia: Any, result: Any): Unit = noImpl
        public open fun indentSingleLineOrSkippedText(trivia: Any, indentThisTrivia: Any, result: Any): Unit = noImpl
        public open fun indentMultiLineComment(trivia: Any, indentThisTrivia: Any, result: Any): Unit = noImpl
        public class object {
            public fun indentNode(node: ISyntaxNode, indentFirstToken: Boolean, indentAmount: Number, options: FormattingOptions): SyntaxNode = noImpl
            public fun indentNodes(nodes: Array<SyntaxNode>, indentFirstToken: Boolean, indentAmount: Number, options: FormattingOptions): Array<SyntaxNode> = noImpl
        }
    }
    public trait ISyntaxToken : ISyntaxNodeOrToken, INameSyntax, IPrimaryExpressionSyntax {
        public var tokenKind: SyntaxKind
        public fun text(): String
        public fun value(): Any
        public fun valueText(): String
        public fun hasLeadingTrivia(): Boolean
        public fun hasLeadingComment(): Boolean
        public fun hasLeadingNewLine(): Boolean
        public fun hasLeadingSkippedText(): Boolean
        public fun hasTrailingTrivia(): Boolean
        public fun hasTrailingComment(): Boolean
        public fun hasTrailingNewLine(): Boolean
        public fun hasTrailingSkippedText(): Boolean
        public fun hasSkippedToken(): Boolean
        override fun leadingTrivia(): ISyntaxTriviaList
        override fun trailingTrivia(): ISyntaxTriviaList
        override fun withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken
        override fun withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken
        public fun clone(): ISyntaxToken
    }
    public trait ITokenInfo {
        public var leadingTrivia: Array<ISyntaxTrivia>?
        public var text: String?
        public var trailingTrivia: Array<ISyntaxTrivia>?
    }
    public open class SyntaxTokenReplacer(token1: ISyntaxToken, token2: ISyntaxToken) : SyntaxRewriter() {
        public open var token1: Any = noImpl
        public open var token2: Any = noImpl
        override fun visitToken(token: ISyntaxToken): ISyntaxToken = noImpl
        override fun visitNode(node: SyntaxNode): SyntaxNode = noImpl
        override fun visitList(list: ISyntaxList): ISyntaxList = noImpl
        override fun visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList = noImpl
    }
    public trait ISyntaxTrivia {
        public fun kind(): SyntaxKind
        public fun isWhitespace(): Boolean
        public fun isComment(): Boolean
        public fun isNewLine(): Boolean
        public fun isSkippedToken(): Boolean
        public fun fullWidth(): Number
        public fun fullText(): String
        public fun skippedToken(): ISyntaxToken
    }
    public trait ISyntaxTriviaList {
        public fun count(): Number
        public fun syntaxTriviaAt(index: Number): ISyntaxTrivia
        public fun fullWidth(): Number
        public fun fullText(): String
        public fun hasComment(): Boolean
        public fun hasNewLine(): Boolean
        public fun hasSkippedToken(): Boolean
        public fun last(): ISyntaxTrivia
        public fun toArray(): Array<ISyntaxTrivia>
        public fun concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList
        public fun collectTextElements(elements: Array<String>)
    }
    public open class SyntaxUtilities {
        public class object {
            public fun isAngleBracket(positionedElement: PositionedElement): Boolean = noImpl
            public fun getToken(list: ISyntaxList, kind: SyntaxKind): ISyntaxToken = noImpl
            public fun containsToken(list: ISyntaxList, kind: SyntaxKind): Boolean = noImpl
            public fun hasExportKeyword(moduleElement: IModuleElementSyntax): Boolean = noImpl
            public fun getExportKeyword(moduleElement: IModuleElementSyntax): ISyntaxToken = noImpl
            public fun isAmbientDeclarationSyntax(positionNode: PositionedNode): Boolean = noImpl
        }
    }
    public trait ISyntaxVisitor {
        public fun visitToken(token: ISyntaxToken): Any
        public fun visitSourceUnit(node: SourceUnitSyntax): Any
        public fun visitExternalModuleReference(node: ExternalModuleReferenceSyntax): Any
        public fun visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): Any
        public fun visitImportDeclaration(node: ImportDeclarationSyntax): Any
        public fun visitExportAssignment(node: ExportAssignmentSyntax): Any
        public fun visitClassDeclaration(node: ClassDeclarationSyntax): Any
        public fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Any
        public fun visitHeritageClause(node: HeritageClauseSyntax): Any
        public fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Any
        public fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Any
        public fun visitVariableStatement(node: VariableStatementSyntax): Any
        public fun visitVariableDeclaration(node: VariableDeclarationSyntax): Any
        public fun visitVariableDeclarator(node: VariableDeclaratorSyntax): Any
        public fun visitEqualsValueClause(node: EqualsValueClauseSyntax): Any
        public fun visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): Any
        public fun visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): Any
        public fun visitOmittedExpression(node: OmittedExpressionSyntax): Any
        public fun visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): Any
        public fun visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): Any
        public fun visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): Any
        public fun visitQualifiedName(node: QualifiedNameSyntax): Any
        public fun visitTypeArgumentList(node: TypeArgumentListSyntax): Any
        public fun visitConstructorType(node: ConstructorTypeSyntax): Any
        public fun visitFunctionType(node: FunctionTypeSyntax): Any
        public fun visitObjectType(node: ObjectTypeSyntax): Any
        public fun visitArrayType(node: ArrayTypeSyntax): Any
        public fun visitGenericType(node: GenericTypeSyntax): Any
        public fun visitTypeQuery(node: TypeQuerySyntax): Any
        public fun visitTypeAnnotation(node: TypeAnnotationSyntax): Any
        public fun visitBlock(node: BlockSyntax): Any
        public fun visitParameter(node: ParameterSyntax): Any
        public fun visitMemberAccessExpression(node: MemberAccessExpressionSyntax): Any
        public fun visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): Any
        public fun visitElementAccessExpression(node: ElementAccessExpressionSyntax): Any
        public fun visitInvocationExpression(node: InvocationExpressionSyntax): Any
        public fun visitArgumentList(node: ArgumentListSyntax): Any
        public fun visitBinaryExpression(node: BinaryExpressionSyntax): Any
        public fun visitConditionalExpression(node: ConditionalExpressionSyntax): Any
        public fun visitConstructSignature(node: ConstructSignatureSyntax): Any
        public fun visitMethodSignature(node: MethodSignatureSyntax): Any
        public fun visitIndexSignature(node: IndexSignatureSyntax): Any
        public fun visitPropertySignature(node: PropertySignatureSyntax): Any
        public fun visitCallSignature(node: CallSignatureSyntax): Any
        public fun visitParameterList(node: ParameterListSyntax): Any
        public fun visitTypeParameterList(node: TypeParameterListSyntax): Any
        public fun visitTypeParameter(node: TypeParameterSyntax): Any
        public fun visitConstraint(node: ConstraintSyntax): Any
        public fun visitElseClause(node: ElseClauseSyntax): Any
        public fun visitIfStatement(node: IfStatementSyntax): Any
        public fun visitExpressionStatement(node: ExpressionStatementSyntax): Any
        public fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Any
        public fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Any
        public fun visitGetAccessor(node: GetAccessorSyntax): Any
        public fun visitSetAccessor(node: SetAccessorSyntax): Any
        public fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): Any
        public fun visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): Any
        public fun visitThrowStatement(node: ThrowStatementSyntax): Any
        public fun visitReturnStatement(node: ReturnStatementSyntax): Any
        public fun visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): Any
        public fun visitSwitchStatement(node: SwitchStatementSyntax): Any
        public fun visitCaseSwitchClause(node: CaseSwitchClauseSyntax): Any
        public fun visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): Any
        public fun visitBreakStatement(node: BreakStatementSyntax): Any
        public fun visitContinueStatement(node: ContinueStatementSyntax): Any
        public fun visitForStatement(node: ForStatementSyntax): Any
        public fun visitForInStatement(node: ForInStatementSyntax): Any
        public fun visitWhileStatement(node: WhileStatementSyntax): Any
        public fun visitWithStatement(node: WithStatementSyntax): Any
        public fun visitEnumDeclaration(node: EnumDeclarationSyntax): Any
        public fun visitEnumElement(node: EnumElementSyntax): Any
        public fun visitCastExpression(node: CastExpressionSyntax): Any
        public fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): Any
        public fun visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): Any
        public fun visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): Any
        public fun visitFunctionExpression(node: FunctionExpressionSyntax): Any
        public fun visitEmptyStatement(node: EmptyStatementSyntax): Any
        public fun visitTryStatement(node: TryStatementSyntax): Any
        public fun visitCatchClause(node: CatchClauseSyntax): Any
        public fun visitFinallyClause(node: FinallyClauseSyntax): Any
        public fun visitLabeledStatement(node: LabeledStatementSyntax): Any
        public fun visitDoStatement(node: DoStatementSyntax): Any
        public fun visitTypeOfExpression(node: TypeOfExpressionSyntax): Any
        public fun visitDeleteExpression(node: DeleteExpressionSyntax): Any
        public fun visitVoidExpression(node: VoidExpressionSyntax): Any
        public fun visitDebuggerStatement(node: DebuggerStatementSyntax): Any
    }
    public open class SyntaxVisitor : ISyntaxVisitor {
        public open fun defaultVisit(node: ISyntaxNodeOrToken): Any = noImpl
        override fun visitToken(token: ISyntaxToken): Any = noImpl
        override fun visitSourceUnit(node: SourceUnitSyntax): Any = noImpl
        override fun visitExternalModuleReference(node: ExternalModuleReferenceSyntax): Any = noImpl
        override fun visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): Any = noImpl
        override fun visitImportDeclaration(node: ImportDeclarationSyntax): Any = noImpl
        override fun visitExportAssignment(node: ExportAssignmentSyntax): Any = noImpl
        override fun visitClassDeclaration(node: ClassDeclarationSyntax): Any = noImpl
        override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Any = noImpl
        override fun visitHeritageClause(node: HeritageClauseSyntax): Any = noImpl
        override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Any = noImpl
        override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Any = noImpl
        override fun visitVariableStatement(node: VariableStatementSyntax): Any = noImpl
        override fun visitVariableDeclaration(node: VariableDeclarationSyntax): Any = noImpl
        override fun visitVariableDeclarator(node: VariableDeclaratorSyntax): Any = noImpl
        override fun visitEqualsValueClause(node: EqualsValueClauseSyntax): Any = noImpl
        override fun visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): Any = noImpl
        override fun visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): Any = noImpl
        override fun visitOmittedExpression(node: OmittedExpressionSyntax): Any = noImpl
        override fun visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): Any = noImpl
        override fun visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): Any = noImpl
        override fun visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): Any = noImpl
        override fun visitQualifiedName(node: QualifiedNameSyntax): Any = noImpl
        override fun visitTypeArgumentList(node: TypeArgumentListSyntax): Any = noImpl
        override fun visitConstructorType(node: ConstructorTypeSyntax): Any = noImpl
        override fun visitFunctionType(node: FunctionTypeSyntax): Any = noImpl
        override fun visitObjectType(node: ObjectTypeSyntax): Any = noImpl
        override fun visitArrayType(node: ArrayTypeSyntax): Any = noImpl
        override fun visitGenericType(node: GenericTypeSyntax): Any = noImpl
        override fun visitTypeQuery(node: TypeQuerySyntax): Any = noImpl
        override fun visitTypeAnnotation(node: TypeAnnotationSyntax): Any = noImpl
        override fun visitBlock(node: BlockSyntax): Any = noImpl
        override fun visitParameter(node: ParameterSyntax): Any = noImpl
        override fun visitMemberAccessExpression(node: MemberAccessExpressionSyntax): Any = noImpl
        override fun visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): Any = noImpl
        override fun visitElementAccessExpression(node: ElementAccessExpressionSyntax): Any = noImpl
        override fun visitInvocationExpression(node: InvocationExpressionSyntax): Any = noImpl
        override fun visitArgumentList(node: ArgumentListSyntax): Any = noImpl
        override fun visitBinaryExpression(node: BinaryExpressionSyntax): Any = noImpl
        override fun visitConditionalExpression(node: ConditionalExpressionSyntax): Any = noImpl
        override fun visitConstructSignature(node: ConstructSignatureSyntax): Any = noImpl
        override fun visitMethodSignature(node: MethodSignatureSyntax): Any = noImpl
        override fun visitIndexSignature(node: IndexSignatureSyntax): Any = noImpl
        override fun visitPropertySignature(node: PropertySignatureSyntax): Any = noImpl
        override fun visitCallSignature(node: CallSignatureSyntax): Any = noImpl
        override fun visitParameterList(node: ParameterListSyntax): Any = noImpl
        override fun visitTypeParameterList(node: TypeParameterListSyntax): Any = noImpl
        override fun visitTypeParameter(node: TypeParameterSyntax): Any = noImpl
        override fun visitConstraint(node: ConstraintSyntax): Any = noImpl
        override fun visitElseClause(node: ElseClauseSyntax): Any = noImpl
        override fun visitIfStatement(node: IfStatementSyntax): Any = noImpl
        override fun visitExpressionStatement(node: ExpressionStatementSyntax): Any = noImpl
        override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Any = noImpl
        override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Any = noImpl
        override fun visitGetAccessor(node: GetAccessorSyntax): Any = noImpl
        override fun visitSetAccessor(node: SetAccessorSyntax): Any = noImpl
        override fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): Any = noImpl
        override fun visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): Any = noImpl
        override fun visitThrowStatement(node: ThrowStatementSyntax): Any = noImpl
        override fun visitReturnStatement(node: ReturnStatementSyntax): Any = noImpl
        override fun visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): Any = noImpl
        override fun visitSwitchStatement(node: SwitchStatementSyntax): Any = noImpl
        override fun visitCaseSwitchClause(node: CaseSwitchClauseSyntax): Any = noImpl
        override fun visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): Any = noImpl
        override fun visitBreakStatement(node: BreakStatementSyntax): Any = noImpl
        override fun visitContinueStatement(node: ContinueStatementSyntax): Any = noImpl
        override fun visitForStatement(node: ForStatementSyntax): Any = noImpl
        override fun visitForInStatement(node: ForInStatementSyntax): Any = noImpl
        override fun visitWhileStatement(node: WhileStatementSyntax): Any = noImpl
        override fun visitWithStatement(node: WithStatementSyntax): Any = noImpl
        override fun visitEnumDeclaration(node: EnumDeclarationSyntax): Any = noImpl
        override fun visitEnumElement(node: EnumElementSyntax): Any = noImpl
        override fun visitCastExpression(node: CastExpressionSyntax): Any = noImpl
        override fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): Any = noImpl
        override fun visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): Any = noImpl
        override fun visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): Any = noImpl
        override fun visitFunctionExpression(node: FunctionExpressionSyntax): Any = noImpl
        override fun visitEmptyStatement(node: EmptyStatementSyntax): Any = noImpl
        override fun visitTryStatement(node: TryStatementSyntax): Any = noImpl
        override fun visitCatchClause(node: CatchClauseSyntax): Any = noImpl
        override fun visitFinallyClause(node: FinallyClauseSyntax): Any = noImpl
        override fun visitLabeledStatement(node: LabeledStatementSyntax): Any = noImpl
        override fun visitDoStatement(node: DoStatementSyntax): Any = noImpl
        override fun visitTypeOfExpression(node: TypeOfExpressionSyntax): Any = noImpl
        override fun visitDeleteExpression(node: DeleteExpressionSyntax): Any = noImpl
        override fun visitVoidExpression(node: VoidExpressionSyntax): Any = noImpl
        override fun visitDebuggerStatement(node: DebuggerStatementSyntax): Any = noImpl
    }
    public open class SyntaxWalker : ISyntaxVisitor {
        override fun visitToken(token: ISyntaxToken): Unit = noImpl
        public open fun visitNode(node: SyntaxNode): Unit = noImpl
        public open fun visitNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): Unit = noImpl
        public open fun visitOptionalToken(token: Any): Unit = noImpl
        public open fun visitOptionalNode(node: SyntaxNode): Unit = noImpl
        public open fun visitOptionalNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): Unit = noImpl
        public open fun visitList(list: ISyntaxList): Unit = noImpl
        public open fun visitSeparatedList(list: ISeparatedSyntaxList): Unit = noImpl
        override fun visitSourceUnit(node: SourceUnitSyntax): Unit = noImpl
        override fun visitExternalModuleReference(node: ExternalModuleReferenceSyntax): Unit = noImpl
        override fun visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): Unit = noImpl
        override fun visitImportDeclaration(node: ImportDeclarationSyntax): Unit = noImpl
        override fun visitExportAssignment(node: ExportAssignmentSyntax): Unit = noImpl
        override fun visitClassDeclaration(node: ClassDeclarationSyntax): Unit = noImpl
        override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Unit = noImpl
        override fun visitHeritageClause(node: HeritageClauseSyntax): Unit = noImpl
        override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Unit = noImpl
        override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Unit = noImpl
        override fun visitVariableStatement(node: VariableStatementSyntax): Unit = noImpl
        override fun visitVariableDeclaration(node: VariableDeclarationSyntax): Unit = noImpl
        override fun visitVariableDeclarator(node: VariableDeclaratorSyntax): Unit = noImpl
        override fun visitEqualsValueClause(node: EqualsValueClauseSyntax): Unit = noImpl
        override fun visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): Unit = noImpl
        override fun visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): Unit = noImpl
        override fun visitOmittedExpression(node: OmittedExpressionSyntax): Unit = noImpl
        override fun visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): Unit = noImpl
        override fun visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): Unit = noImpl
        override fun visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): Unit = noImpl
        override fun visitQualifiedName(node: QualifiedNameSyntax): Unit = noImpl
        override fun visitTypeArgumentList(node: TypeArgumentListSyntax): Unit = noImpl
        override fun visitConstructorType(node: ConstructorTypeSyntax): Unit = noImpl
        override fun visitFunctionType(node: FunctionTypeSyntax): Unit = noImpl
        override fun visitObjectType(node: ObjectTypeSyntax): Unit = noImpl
        override fun visitArrayType(node: ArrayTypeSyntax): Unit = noImpl
        override fun visitGenericType(node: GenericTypeSyntax): Unit = noImpl
        override fun visitTypeQuery(node: TypeQuerySyntax): Unit = noImpl
        override fun visitTypeAnnotation(node: TypeAnnotationSyntax): Unit = noImpl
        override fun visitBlock(node: BlockSyntax): Unit = noImpl
        override fun visitParameter(node: ParameterSyntax): Unit = noImpl
        override fun visitMemberAccessExpression(node: MemberAccessExpressionSyntax): Unit = noImpl
        override fun visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): Unit = noImpl
        override fun visitElementAccessExpression(node: ElementAccessExpressionSyntax): Unit = noImpl
        override fun visitInvocationExpression(node: InvocationExpressionSyntax): Unit = noImpl
        override fun visitArgumentList(node: ArgumentListSyntax): Unit = noImpl
        override fun visitBinaryExpression(node: BinaryExpressionSyntax): Unit = noImpl
        override fun visitConditionalExpression(node: ConditionalExpressionSyntax): Unit = noImpl
        override fun visitConstructSignature(node: ConstructSignatureSyntax): Unit = noImpl
        override fun visitMethodSignature(node: MethodSignatureSyntax): Unit = noImpl
        override fun visitIndexSignature(node: IndexSignatureSyntax): Unit = noImpl
        override fun visitPropertySignature(node: PropertySignatureSyntax): Unit = noImpl
        override fun visitCallSignature(node: CallSignatureSyntax): Unit = noImpl
        override fun visitParameterList(node: ParameterListSyntax): Unit = noImpl
        override fun visitTypeParameterList(node: TypeParameterListSyntax): Unit = noImpl
        override fun visitTypeParameter(node: TypeParameterSyntax): Unit = noImpl
        override fun visitConstraint(node: ConstraintSyntax): Unit = noImpl
        override fun visitElseClause(node: ElseClauseSyntax): Unit = noImpl
        override fun visitIfStatement(node: IfStatementSyntax): Unit = noImpl
        override fun visitExpressionStatement(node: ExpressionStatementSyntax): Unit = noImpl
        override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Unit = noImpl
        override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Unit = noImpl
        override fun visitGetAccessor(node: GetAccessorSyntax): Unit = noImpl
        override fun visitSetAccessor(node: SetAccessorSyntax): Unit = noImpl
        override fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): Unit = noImpl
        override fun visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): Unit = noImpl
        override fun visitThrowStatement(node: ThrowStatementSyntax): Unit = noImpl
        override fun visitReturnStatement(node: ReturnStatementSyntax): Unit = noImpl
        override fun visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): Unit = noImpl
        override fun visitSwitchStatement(node: SwitchStatementSyntax): Unit = noImpl
        override fun visitCaseSwitchClause(node: CaseSwitchClauseSyntax): Unit = noImpl
        override fun visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): Unit = noImpl
        override fun visitBreakStatement(node: BreakStatementSyntax): Unit = noImpl
        override fun visitContinueStatement(node: ContinueStatementSyntax): Unit = noImpl
        override fun visitForStatement(node: ForStatementSyntax): Unit = noImpl
        override fun visitForInStatement(node: ForInStatementSyntax): Unit = noImpl
        override fun visitWhileStatement(node: WhileStatementSyntax): Unit = noImpl
        override fun visitWithStatement(node: WithStatementSyntax): Unit = noImpl
        override fun visitEnumDeclaration(node: EnumDeclarationSyntax): Unit = noImpl
        override fun visitEnumElement(node: EnumElementSyntax): Unit = noImpl
        override fun visitCastExpression(node: CastExpressionSyntax): Unit = noImpl
        override fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): Unit = noImpl
        override fun visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): Unit = noImpl
        override fun visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): Unit = noImpl
        override fun visitFunctionExpression(node: FunctionExpressionSyntax): Unit = noImpl
        override fun visitEmptyStatement(node: EmptyStatementSyntax): Unit = noImpl
        override fun visitTryStatement(node: TryStatementSyntax): Unit = noImpl
        override fun visitCatchClause(node: CatchClauseSyntax): Unit = noImpl
        override fun visitFinallyClause(node: FinallyClauseSyntax): Unit = noImpl
        override fun visitLabeledStatement(node: LabeledStatementSyntax): Unit = noImpl
        override fun visitDoStatement(node: DoStatementSyntax): Unit = noImpl
        override fun visitTypeOfExpression(node: TypeOfExpressionSyntax): Unit = noImpl
        override fun visitDeleteExpression(node: DeleteExpressionSyntax): Unit = noImpl
        override fun visitVoidExpression(node: VoidExpressionSyntax): Unit = noImpl
        override fun visitDebuggerStatement(node: DebuggerStatementSyntax): Unit = noImpl
    }
    public open class PositionTrackingWalker : SyntaxWalker() {
        public open var _position: Any = noImpl
        override fun visitToken(token: ISyntaxToken): Unit = noImpl
        public open fun position(): Number = noImpl
        public open fun skip(element: ISyntaxElement): Unit = noImpl
    }
    public trait ITokenInformation {
        public var previousToken: ISyntaxToken
        public var nextToken: ISyntaxToken
    }
    public open class SyntaxInformationMap(trackParents: Boolean, trackPreviousToken: Boolean) : SyntaxWalker() {
        public open var trackParents: Any = noImpl
        public open var trackPreviousToken: Any = noImpl
        public open var tokenToInformation: Any = noImpl
        public open var elementToPosition: Any = noImpl
        public open var _previousToken: Any = noImpl
        public open var _previousTokenInformation: Any = noImpl
        public open var _currentPosition: Any = noImpl
        public open var _elementToParent: Any = noImpl
        public open var _parentStack: Any = noImpl
        override fun visitNode(node: SyntaxNode): Unit = noImpl
        override fun visitToken(token: ISyntaxToken): Unit = noImpl
        public open fun parent(element: ISyntaxElement): SyntaxNode = noImpl
        public open fun fullStart(element: ISyntaxElement): Number = noImpl
        public open fun start(element: ISyntaxElement): Number = noImpl
        public open fun end(element: ISyntaxElement): Number = noImpl
        public open fun previousToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public open fun tokenInformation(token: ISyntaxToken): ITokenInformation = noImpl
        public open fun firstTokenInLineContainingToken(token: ISyntaxToken): ISyntaxToken = noImpl
        public open fun isFirstTokenInLine(token: ISyntaxToken): Boolean = noImpl
        public open fun isFirstTokenInLineWorker(information: Any): Unit = noImpl
        public class object {
            public fun create(node: SyntaxNode, trackParents: Boolean, trackPreviousToken: Boolean): SyntaxInformationMap = noImpl
        }
    }
    public open class SyntaxNodeInvariantsChecker : SyntaxWalker() {
        public open var tokenTable: Any = noImpl
        override fun visitToken(token: ISyntaxToken): Unit = noImpl
        public class object {
            public open fun checkInvariants(node: SyntaxNode): Unit = noImpl
        }
    }
    public open class DepthLimitedWalker(maximumDepth: Number) : PositionTrackingWalker() {
        public open var _depth: Any = noImpl
        public open var _maximumDepth: Any = noImpl
        override fun visitNode(node: SyntaxNode): Unit = noImpl
    }
    module
    public object Parser {
        public fun parse(fileName: String, text: ISimpleText, isDeclaration: Boolean, options: ParseOptions): SyntaxTree = noImpl
        public fun incrementalParse(oldSyntaxTree: SyntaxTree, textChangeRange: TextChangeRange, newText: ISimpleText): SyntaxTree = noImpl
    }
    public open class SyntaxTree(sourceUnit: SourceUnitSyntax, isDeclaration: Boolean, diagnostics: Array<Diagnostic>, fileName: String, lineMap: LineMap, parseOtions: ParseOptions) {
        public open var _sourceUnit: Any = noImpl
        public open var _isDeclaration: Any = noImpl
        public open var _parserDiagnostics: Any = noImpl
        public open var _allDiagnostics: Any = noImpl
        public open var _fileName: Any = noImpl
        public open var _lineMap: Any = noImpl
        public open var _parseOptions: Any = noImpl
        public open fun toJSON(key: Any): Any = noImpl
        public open fun sourceUnit(): SourceUnitSyntax = noImpl
        public open fun isDeclaration(): Boolean = noImpl
        public open fun computeDiagnostics(): Unit = noImpl
        public open fun diagnostics(): Array<Diagnostic> = noImpl
        public open fun fileName(): String = noImpl
        public open fun lineMap(): LineMap = noImpl
        public open fun parseOptions(): ParseOptions = noImpl
        public open fun structuralEquals(tree: SyntaxTree): Boolean = noImpl
    }
    public open class Unicode {
        public class object {
            public var unicodeES3IdentifierStart: Array<Number> = noImpl
            public var unicodeES3IdentifierPart: Array<Number> = noImpl
            public var unicodeES5IdentifierStart: Array<Number> = noImpl
            public var unicodeES5IdentifierPart: Array<Number> = noImpl
            public fun lookupInUnicodeMap(code: Number, map: Array<Number>): Boolean = noImpl
            public fun isIdentifierStart(code: Number, languageVersion: LanguageVersion): Boolean = noImpl
            public fun isIdentifierPart(code: Number, languageVersion: LanguageVersion): Boolean = noImpl
        }
    }
    module
    public object CompilerDiagnostics {
        public var debug: Boolean = noImpl
        public trait IDiagnosticWriter {
            public fun Alert(output: String)
        }
        public var diagnosticWriter: IDiagnosticWriter = noImpl
        public var analysisPass: Number = noImpl
        public fun Alert(output: String): Unit = noImpl
        public fun debugPrint(s: String): Unit = noImpl
        public fun assert(condition: Boolean, s: String): Unit = noImpl
    }
    public trait ILogger {
        public fun information(): Boolean
        public fun debug(): Boolean
        public fun warning(): Boolean
        public fun error(): Boolean
        public fun fatal(): Boolean
        public fun log(s: String)
    }
    public open class NullLogger : ILogger {
        override fun information(): Boolean = noImpl
        override fun debug(): Boolean = noImpl
        override fun warning(): Boolean = noImpl
        override fun error(): Boolean = noImpl
        override fun fatal(): Boolean = noImpl
        override fun log(s: String): Unit = noImpl
    }
    public open fun timeFunction(logger: ILogger, funcDescription: String, func: () -> Any): Any = noImpl
    public open class Document(_compiler: TypeScriptCompiler, _semanticInfoChain: SemanticInfoChain, fileName: String, referencedFiles: Array<String>, _scriptSnapshot: IScriptSnapshot, byteOrderMark: ByteOrderMark, version: Number, isOpen: Boolean, _syntaxTree: SyntaxTree, _topLevelDecl: PullDecl) {
        public open var _compiler: Any = noImpl
        public open var _semanticInfoChain: Any = noImpl
        public open var fileName: String = noImpl
        public open var referencedFiles: Array<String> = noImpl
        public open var _scriptSnapshot: Any = noImpl
        public open var byteOrderMark: ByteOrderMark = noImpl
        public open var version: Number = noImpl
        public open var isOpen: Boolean = noImpl
        public open var _syntaxTree: Any = noImpl
        public open var _topLevelDecl: Any = noImpl
        public open var _diagnostics: Any = noImpl
        public open var _bloomFilter: Any = noImpl
        public open var _sourceUnit: Any = noImpl
        public open var _lineMap: Any = noImpl
        public open var _declASTMap: Any = noImpl
        public open var _astDeclMap: Any = noImpl
        public open var _amdDependencies: Any = noImpl
        public open var _externalModuleIndicatorSpan: Any = noImpl
        public open fun invalidate(): Unit = noImpl
        public open fun isDeclareFile(): Boolean = noImpl
        public open fun cacheSyntaxTreeInfo(syntaxTree: Any): Unit = noImpl
        public open fun getAmdDependency(comment: Any): Unit = noImpl
        public open fun getImplicitImportSpan(sourceUnitLeadingTrivia: Any): Unit = noImpl
        public open fun getImplicitImportSpanWorker(trivia: Any, position: Any): Unit = noImpl
        public open fun getTopLevelImportOrExportSpan(node: Any): Unit = noImpl
        public open fun sourceUnit(): SourceUnit = noImpl
        public open fun diagnostics(): Array<Diagnostic> = noImpl
        public open fun lineMap(): LineMap = noImpl
        public open fun isExternalModule(): Boolean = noImpl
        public open fun externalModuleIndicatorSpan(): TextSpan = noImpl
        public open fun amdDependencies(): Array<String> = noImpl
        public open fun syntaxTree(): SyntaxTree = noImpl
        public open fun bloomFilter(): BloomFilter = noImpl
        public open fun emitToOwnOutputFile(): Boolean = noImpl
        public open fun update(scriptSnapshot: IScriptSnapshot, version: Number, isOpen: Boolean, textChangeRange: TextChangeRange): Document = noImpl
        public open fun topLevelDecl(): PullDecl = noImpl
        public open fun _getDeclForAST(ast: AST): PullDecl = noImpl
        public open fun getEnclosingDecl(ast: AST): PullDecl = noImpl
        public open fun _setDeclForAST(ast: AST, decl: PullDecl): Unit = noImpl
        public open fun _getASTForDecl(decl: PullDecl): AST = noImpl
        public open fun _setASTForDecl(decl: PullDecl, ast: AST): Unit = noImpl
        public class object {
            public fun create(compiler: TypeScriptCompiler, semanticInfoChain: SemanticInfoChain, fileName: String, scriptSnapshot: IScriptSnapshot, byteOrderMark: ByteOrderMark, version: Number, isOpen: Boolean, referencedFiles: Array<String>): Document = noImpl
        }
    }
    public fun hasFlag(`val`: Number, flag: Number): Boolean = noImpl
    public fun createIntrinsicsObject<T>(): IIndexable<T> = noImpl
    public trait IHashTable<T> {
        public fun getAllKeys(): Array<String>
        public fun add(key: String, data: T): Boolean
        public fun addOrUpdate(key: String, data: T): Boolean
        public fun map(fn: (k: String, value: T, context: Any) -> Unit, context: Any)
        public fun every(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Boolean
        public fun some(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Boolean
        public fun count(): Number
        public fun lookup(key: String): T
    }
    public open class StringHashTable<T> : IHashTable<T> {
        public open var itemCount: Any = noImpl
        public open var table: Any = noImpl
        override fun getAllKeys(): Array<String> = noImpl
        override fun add(key: String, data: T): Boolean = noImpl
        override fun addOrUpdate(key: String, data: T): Boolean = noImpl
        override fun map(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Unit = noImpl
        override fun every(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Boolean = noImpl
        override fun some(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Boolean = noImpl
        override fun count(): Number = noImpl
        override fun lookup(key: String): T = noImpl
        public open fun remove(key: String): Unit = noImpl
    }
    public open class IdentiferNameHashTable<T> : StringHashTable<T>() {
        override fun getAllKeys(): Array<String> = noImpl
        override fun add(key: String, data: T): Boolean = noImpl
        override fun addOrUpdate(key: String, data: T): Boolean = noImpl
        override fun map(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Unit = noImpl
        override fun every(fn: (k: String, value: T, context: Any) -> Unit, context: Any): Boolean = noImpl
        override fun some(fn: (k: String, value: Any, context: Any) -> Unit, context: Any): Boolean = noImpl
        override fun lookup(key: String): T = noImpl
    }
    public trait IParameters {
        public var length: Number
        public fun lastParameterIsRest(): Boolean
        public var ast: AST
        public fun astAt(index: Number): AST
        public fun identifierAt(index: Number): Identifier
        public fun typeAt(index: Number): AST
        public fun initializerAt(index: Number): EqualsValueClause
        public fun isOptionalAt(index: Number): Boolean
    }
    module
    public object ASTHelpers {
        public fun scriptIsElided(sourceUnit: SourceUnit): Boolean = noImpl
        public fun moduleIsElided(declaration: ModuleDeclaration): Boolean = noImpl
        public fun enumIsElided(declaration: EnumDeclaration): Boolean = noImpl
        public fun isValidAstNode(ast: IASTSpan): Boolean = noImpl
        public fun getAstAtPosition(script: AST, pos: Number, useTrailingTriviaAsLimChar: Boolean? = null, forceInclusive: Boolean? = null): AST = noImpl
        public fun getExtendsHeritageClause(clauses: ISyntaxList2): HeritageClause = noImpl
        public fun getImplementsHeritageClause(clauses: ISyntaxList2): HeritageClause = noImpl
        public fun isCallExpression(ast: AST): Boolean = noImpl
        public fun isCallExpressionTarget(ast: AST): Boolean = noImpl
        public fun isDeclarationASTOrDeclarationNameAST(ast: AST): Boolean = noImpl
        public fun getEnclosingParameterForInitializer(ast: AST): Parameter = noImpl
        public fun getEnclosingMemberVariableDeclaration(ast: AST): MemberVariableDeclaration = noImpl
        public fun isNameOfFunction(ast: AST): Boolean = noImpl
        public fun isNameOfMemberFunction(ast: AST): Boolean = noImpl
        public fun isNameOfMemberAccessExpression(ast: AST): Boolean = noImpl
        public fun isRightSideOfQualifiedName(ast: AST): Boolean = noImpl
        public fun parentIsModuleDeclaration(ast: AST): Boolean = noImpl
        public fun parametersFromIdentifier(id: Identifier): IParameters = noImpl
        public fun parametersFromParameter(parameter: Parameter): IParameters = noImpl
        public fun parametersFromParameterList(list: ParameterList): IParameters = noImpl
        public fun isDeclarationAST(ast: AST): Boolean = noImpl
        public fun docComments(ast: AST): Array<Comment> = noImpl
        public fun getParameterList(ast: AST): ParameterList = noImpl
        public fun getType(ast: AST): AST = noImpl
        public fun getVariableDeclaratorModifiers(variableDeclarator: VariableDeclarator): Array<PullElementFlags> = noImpl
        public fun isIntegerLiteralAST(expression: AST): Boolean = noImpl
        public fun getEnclosingModuleDeclaration(ast: AST): ModuleDeclaration = noImpl
        public fun getModuleDeclarationFromNameAST(ast: AST): ModuleDeclaration = noImpl
        public fun isLastNameOfModule(ast: ModuleDeclaration, astName: AST): Boolean = noImpl
        public fun getNameOfIdenfierOrQualifiedName(name: AST): String = noImpl
        public fun getModuleNames(name: AST, result: Array<Identifier>? = null): Array<Identifier> = noImpl
    }
    public open class AstWalkOptions {
        public open var goChildren: Boolean = noImpl
        public open var stopWalking: Boolean = noImpl
    }
    public trait IAstWalker {
        public var options: AstWalkOptions
        public var state: Any
    }
    public open class AstWalkerFactory {
        public open fun walk(ast: AST, pre: (ast: AST, walker: IAstWalker) -> Unit, post: ((ast: AST, walker: IAstWalker) -> Unit)? = null, state: Any? = null): Unit = noImpl
        public open fun simpleWalk(ast: AST, pre: (ast: AST, state: Any) -> Unit, post: ((ast: AST, state: Any) -> Unit)? = null, state: Any? = null): Unit = noImpl
    }
    public fun getAstWalkerFactory(): AstWalkerFactory = noImpl
    public open class Base64VLQFormat {
        public class object {
            public fun encode(inValue: Number): String = noImpl
            public fun decode(inString: String): `T$4` = noImpl
        }
    }
    public open class SourceMapPosition {
        public open var sourceLine: Number = noImpl
        public open var sourceColumn: Number = noImpl
        public open var emittedLine: Number = noImpl
        public open var emittedColumn: Number = noImpl
    }
    public open class SourceMapping {
        public open var start: SourceMapPosition = noImpl
        public open var end: SourceMapPosition = noImpl
        public open var nameIndex: Number = noImpl
        public open var childMappings: Array<SourceMapping> = noImpl
    }
    public open class SourceMapEntry(emittedFile: String, emittedLine: Number, emittedColumn: Number, sourceFile: String, sourceLine: Number, sourceColumn: Number, sourceName: String) {
        public open var emittedFile: String = noImpl
        public open var emittedLine: Number = noImpl
        public open var emittedColumn: Number = noImpl
        public open var sourceFile: String = noImpl
        public open var sourceLine: Number = noImpl
        public open var sourceColumn: Number = noImpl
        public open var sourceName: String = noImpl
    }
    public open class SourceMapper(jsFile: TextWriter, sourceMapOut: TextWriter, document: Document, jsFilePath: String, emitOptions: EmitOptions, resolvePath: (path: String) -> String) {
        public open var jsFile: Any = noImpl
        public open var sourceMapOut: Any = noImpl
        public open var jsFileName: Any = noImpl
        public open var sourceMapPath: Any = noImpl
        public open var sourceMapDirectory: Any = noImpl
        public open var sourceRoot: Any = noImpl
        public open var names: Array<String> = noImpl
        public open var mappingLevel: Any = noImpl
        public open var tsFilePaths: Any = noImpl
        public open var allSourceMappings: Any = noImpl
        public open var currentMappings: Array<Array<SourceMapping>> = noImpl
        public open var currentNameIndex: Array<Number> = noImpl
        public open var sourceMapEntries: Any = noImpl
        public open fun getOutputFile(): OutputFile = noImpl
        public open fun increaseMappingLevel(ast: IASTSpan): Unit = noImpl
        public open fun decreaseMappingLevel(ast: IASTSpan): Unit = noImpl
        public open fun setNewSourceFile(document: Document, emitOptions: EmitOptions): Unit = noImpl
        public open fun setSourceMapOptions(document: Any, jsFilePath: Any, emitOptions: Any, resolvePath: Any): Unit = noImpl
        public open fun setNewSourceFilePath(document: Any, emitOptions: Any): Unit = noImpl
        public open fun emitSourceMapping(): Unit = noImpl
        public class object {
            public var MapFileExtension: String = noImpl
        }
    }

    enum class EmitContainer

    public open class EmitState {
        public open var column: Number = noImpl
        public open var line: Number = noImpl
        public open var container: EmitContainer = noImpl
    }
    public open class EmitOptions(compiler: TypeScriptCompiler, resolvePath: (path: String) -> String) {
        public open var resolvePath: (path: String) -> String = noImpl
        public open var _diagnostic: Any = noImpl
        public open var _settings: Any = noImpl
        public open var _commonDirectoryPath: Any = noImpl
        public open var _sharedOutputFile: Any = noImpl
        public open var _sourceRootDirectory: Any = noImpl
        public open var _sourceMapRootDirectory: Any = noImpl
        public open var _outputDirectory: Any = noImpl
        public open fun diagnostic(): Diagnostic = noImpl
        public open fun commonDirectoryPath(): String = noImpl
        public open fun sharedOutputFile(): String = noImpl
        public open fun sourceRootDirectory(): String = noImpl
        public open fun sourceMapRootDirectory(): String = noImpl
        public open fun outputDirectory(): String = noImpl
        public open fun compilationSettings(): ImmutableCompilationSettings = noImpl
        public open fun determineCommonDirectoryPath(compiler: Any): Unit = noImpl
    }
    public open class Indenter {
        public open var indentAmt: Number = noImpl
        public open fun increaseIndent(): Unit = noImpl
        public open fun decreaseIndent(): Unit = noImpl
        public open fun getIndent(): String = noImpl
        public class object {
            public var indentStep: Number = noImpl
            public var indentStepString: String = noImpl
            public var indentStrings: Array<String> = noImpl
        }
    }
    public fun lastParameterIsRest(parameterList: ParameterList): Boolean = noImpl
    public open class Emitter(emittingFileName: String, outfile: TextWriter, emitOptions: EmitOptions, semanticInfoChain: SemanticInfoChain) {
        public open var emittingFileName: String = noImpl
        public open var outfile: TextWriter = noImpl
        public open var emitOptions: EmitOptions = noImpl
        public open var semanticInfoChain: Any = noImpl
        public open var globalThisCapturePrologueEmitted: Boolean = noImpl
        public open var extendsPrologueEmitted: Boolean = noImpl
        public open var thisClassNode: ClassDeclaration = noImpl
        public open var inArrowFunction: Boolean = noImpl
        public open var moduleName: String = noImpl
        public open var emitState: EmitState = noImpl
        public open var indenter: Indenter = noImpl
        public open var sourceMapper: SourceMapper = noImpl
        public open var captureThisStmtString: String = noImpl
        public open var currentVariableDeclaration: Any = noImpl
        public open var declStack: Any = noImpl
        public open var exportAssignment: Any = noImpl
        public open var inWithBlock: Any = noImpl
        public open var document: Document = noImpl
        public open var detachedCommentsElement: Any = noImpl
        public open fun pushDecl(decl: Any): Unit = noImpl
        public open fun popDecl(decl: Any): Unit = noImpl
        public open fun getEnclosingDecl(): Unit = noImpl
        public open fun setExportAssignment(exportAssignment: ExportAssignment): Unit = noImpl
        public open fun getExportAssignment(): ExportAssignment = noImpl
        public open fun setDocument(document: Document): Unit = noImpl
        public open fun shouldEmitImportDeclaration(importDeclAST: ImportDeclaration): Boolean = noImpl
        public open fun emitImportDeclaration(importDeclAST: ImportDeclaration): Unit = noImpl
        public open fun createSourceMapper(document: Document, jsFileName: String, jsFile: TextWriter, sourceMapOut: TextWriter, resolvePath: (path: String) -> String): Unit = noImpl
        public open fun setSourceMapperNewSourceFile(document: Document): Unit = noImpl
        public open fun updateLineAndColumn(s: Any): Unit = noImpl
        public open fun writeToOutputWithSourceMapRecord(s: String, astSpan: IASTSpan): Unit = noImpl
        public open fun writeToOutput(s: String): Unit = noImpl
        public open fun writeLineToOutput(s: String, force: Boolean? = null): Unit = noImpl
        public open fun writeCaptureThisStatement(ast: AST): Unit = noImpl
        public open fun setContainer(c: Number): Number = noImpl
        public open fun getIndentString(): Unit = noImpl
        public open fun emitIndent(): Unit = noImpl
        public open fun emitComment(comment: Comment, trailing: Boolean, first: Boolean): Unit = noImpl
        public open fun emitComments(ast: AST, pre: Boolean, onlyPinnedOrTripleSlashComments: Boolean? = null): Unit = noImpl
        public open fun isPinnedOrTripleSlash(comment: Any): Unit = noImpl
        public open fun emitCommentsArray(comments: Array<Comment>, trailing: Boolean): Unit = noImpl
        public open fun emitObjectLiteralExpression(objectLiteral: ObjectLiteralExpression): Unit = noImpl
        public open fun emitArrayLiteralExpression(arrayLiteral: ArrayLiteralExpression): Unit = noImpl
        public open fun emitObjectCreationExpression(objectCreationExpression: ObjectCreationExpression): Unit = noImpl
        public open fun getConstantDecl(dotExpr: MemberAccessExpression): PullEnumElementDecl = noImpl
        public open fun tryEmitConstant(dotExpr: MemberAccessExpression): Boolean = noImpl
        public open fun emitInvocationExpression(callNode: InvocationExpression): Unit = noImpl
        public open fun emitParameterList(list: Any): Unit = noImpl
        public open fun emitFunctionParameters(parameters: Any): Unit = noImpl
        public open fun emitFunctionBodyStatements(name: Any, funcDecl: Any, parameterList: Any, block: Any, bodyExpression: Any): Unit = noImpl
        public open fun emitDefaultValueAssignments(parameters: Any): Unit = noImpl
        public open fun emitRestParameterInitializer(parameters: Any): Unit = noImpl
        public open fun getImportDecls(fileName: Any): Unit = noImpl
        public open fun getModuleImportAndDependencyList(sourceUnit: SourceUnit): `T$5` = noImpl
        public open fun shouldCaptureThis(ast: AST): Boolean = noImpl
        public open fun emitEnum(moduleDecl: EnumDeclaration): Unit = noImpl
        public open fun getModuleDeclToVerifyChildNameCollision(moduleDecl: Any, changeNameIfAnyDeclarationInContext: Any): Unit = noImpl
        public open fun hasChildNameCollision(moduleName: Any, parentDecl: Any): Unit = noImpl
        public open fun getModuleName(moduleDecl: Any, changeNameIfAnyDeclarationInContext: Any? = null): Unit = noImpl
        public open fun emitModuleDeclarationWorker(moduleDecl: Any): Unit = noImpl
        public open fun emitSingleModuleDeclaration(moduleDecl: ModuleDeclaration, moduleName: IASTToken): Unit = noImpl
        public open fun emitEnumElement(varDecl: EnumElement): Unit = noImpl
        public open fun emitElementAccessExpression(expression: ElementAccessExpression): Unit = noImpl
        public open fun emitSimpleArrowFunctionExpression(arrowFunction: SimpleArrowFunctionExpression): Unit = noImpl
        public open fun emitParenthesizedArrowFunctionExpression(arrowFunction: ParenthesizedArrowFunctionExpression): Unit = noImpl
        public open fun emitAnyArrowFunctionExpression(arrowFunction: Any, funcName: Any, parameters: Any, block: Any, expression: Any): Unit = noImpl
        public open fun emitConstructor(funcDecl: ConstructorDeclaration): Unit = noImpl
        public open fun emitGetAccessor(accessor: GetAccessor): Unit = noImpl
        public open fun emitSetAccessor(accessor: SetAccessor): Unit = noImpl
        public open fun emitFunctionExpression(funcDecl: FunctionExpression): Unit = noImpl
        public open fun emitFunction(funcDecl: FunctionDeclaration): Unit = noImpl
        public open fun emitAmbientVarDecl(varDecl: VariableDeclarator): Unit = noImpl
        public open fun emitVarDeclVar(): Unit = noImpl
        public open fun emitVariableDeclaration(declaration: VariableDeclaration): Unit = noImpl
        public open fun emitMemberVariableDeclaration(varDecl: Any): Unit = noImpl
        public open fun emitVariableDeclarator(varDecl: VariableDeclarator): Unit = noImpl
        public open fun symbolIsUsedInItsEnclosingContainer(symbol: Any, dynamic: Any? = null): Unit = noImpl
        public open fun shouldQualifySymbolNameWithParentName(symbol: Any): Unit = noImpl
        public open fun getSymbolForEmit(ast: Any): Unit = noImpl
        public open fun emitName(name: Identifier, addThis: Boolean): Unit = noImpl
        public open fun recordSourceMappingNameStart(name: String): Unit = noImpl
        public open fun recordSourceMappingNameEnd(): Unit = noImpl
        public open fun recordSourceMappingStart(ast: IASTSpan): Unit = noImpl
        public open fun recordSourceMappingEnd(ast: IASTSpan): Unit = noImpl
        public open fun getOutputFiles(): Array<OutputFile> = noImpl
        public open fun emitParameterPropertyAndMemberVariableAssignments(): Unit = noImpl
        public open fun isOnSameLine(pos1: Any, pos2: Any): Unit = noImpl
        public open fun emitCommaSeparatedList(parent: Any, list: Any, buffer: Any, preserveNewLines: Any): Unit = noImpl
        public open fun emitList(list: ISyntaxList2, useNewLineSeparator: Boolean? = null, startInclusive: Number? = null, endExclusive: Number? = null): Unit = noImpl
        public open fun emitSeparatedList(list: ISeparatedSyntaxList2, useNewLineSeparator: Boolean? = null, startInclusive: Number? = null, endExclusive: Number? = null): Unit = noImpl
        public open fun isDirectivePrologueElement(node: Any): Unit = noImpl
        public open fun emitSpaceBetweenConstructs(node1: AST, node2: AST): Unit = noImpl
        public open fun getDetachedComments(element: Any): Unit = noImpl
        public open fun emitPossibleCopyrightHeaders(script: Any): Unit = noImpl
        public open fun emitDetachedComments(list: Any): Unit = noImpl
        public open fun emitScriptElements(sourceUnit: SourceUnit): Unit = noImpl
        public open fun emitConstructorStatements(funcDecl: ConstructorDeclaration): Unit = noImpl
        public open fun emitJavascript(ast: AST, startLine: Boolean): Unit = noImpl
        public open fun emitAccessorMemberDeclaration(funcDecl: AST, name: IASTToken, className: String, isProto: Boolean): Unit = noImpl
        public open fun emitAccessorBody(funcDecl: Any, parameterList: Any, block: Any): Unit = noImpl
        public open fun emitClass(classDecl: ClassDeclaration): Unit = noImpl
        public open fun emitClassMembers(classDecl: Any): Unit = noImpl
        public open fun emitClassMemberFunctionDeclaration(classDecl: Any, funcDecl: Any): Unit = noImpl
        public open fun requiresExtendsBlock(moduleElements: Any): Unit = noImpl
        public open fun emitPrologue(sourceUnit: SourceUnit): Unit = noImpl
        public open fun emitThis(): Unit = noImpl
        public open fun emitBlockOrStatement(node: AST): Unit = noImpl
        public open fun emitLiteralExpression(expression: LiteralExpression): Unit = noImpl
        public open fun emitThisExpression(expression: ThisExpression): Unit = noImpl
        public open fun emitSuperExpression(expression: SuperExpression): Unit = noImpl
        public open fun emitParenthesizedExpression(parenthesizedExpression: ParenthesizedExpression): Unit = noImpl
        public open fun emitCastExpression(expression: CastExpression): Unit = noImpl
        public open fun emitPrefixUnaryExpression(expression: PrefixUnaryExpression): Unit = noImpl
        public open fun emitPostfixUnaryExpression(expression: PostfixUnaryExpression): Unit = noImpl
        public open fun emitTypeOfExpression(expression: TypeOfExpression): Unit = noImpl
        public open fun emitDeleteExpression(expression: DeleteExpression): Unit = noImpl
        public open fun emitVoidExpression(expression: VoidExpression): Unit = noImpl
        public open fun canEmitDottedNameMemberAccessExpression(expression: Any): Unit = noImpl
        public open fun emitDottedNameMemberAccessExpression(expression: Any): Unit = noImpl
        public open fun emitDottedNameMemberAccessExpressionRecurse(expression: Any): Unit = noImpl
        public open fun emitMemberAccessExpression(expression: MemberAccessExpression): Unit = noImpl
        public open fun emitQualifiedName(name: QualifiedName): Unit = noImpl
        public open fun emitBinaryExpression(expression: BinaryExpression): Unit = noImpl
        public open fun emitSimplePropertyAssignment(property: SimplePropertyAssignment): Unit = noImpl
        public open fun emitFunctionPropertyAssignment(funcProp: FunctionPropertyAssignment): Unit = noImpl
        public open fun emitConditionalExpression(expression: ConditionalExpression): Unit = noImpl
        public open fun emitThrowStatement(statement: ThrowStatement): Unit = noImpl
        public open fun emitExpressionStatement(statement: ExpressionStatement): Unit = noImpl
        public open fun emitLabeledStatement(statement: LabeledStatement): Unit = noImpl
        public open fun emitBlock(block: Block): Unit = noImpl
        public open fun emitBreakStatement(jump: BreakStatement): Unit = noImpl
        public open fun emitContinueStatement(jump: ContinueStatement): Unit = noImpl
        public open fun emitWhileStatement(statement: WhileStatement): Unit = noImpl
        public open fun emitDoStatement(statement: DoStatement): Unit = noImpl
        public open fun emitIfStatement(statement: IfStatement): Unit = noImpl
        public open fun emitElseClause(elseClause: ElseClause): Unit = noImpl
        public open fun emitReturnStatement(statement: ReturnStatement): Unit = noImpl
        public open fun emitForInStatement(statement: ForInStatement): Unit = noImpl
        public open fun emitForStatement(statement: ForStatement): Unit = noImpl
        public open fun emitWithStatement(statement: WithStatement): Unit = noImpl
        public open fun emitSwitchStatement(statement: SwitchStatement): Unit = noImpl
        public open fun emitCaseSwitchClause(clause: CaseSwitchClause): Unit = noImpl
        public open fun emitSwitchClauseBody(body: Any): Unit = noImpl
        public open fun emitDefaultSwitchClause(clause: DefaultSwitchClause): Unit = noImpl
        public open fun emitTryStatement(statement: TryStatement): Unit = noImpl
        public open fun emitCatchClause(clause: CatchClause): Unit = noImpl
        public open fun emitFinallyClause(clause: FinallyClause): Unit = noImpl
        public open fun emitDebuggerStatement(statement: DebuggerStatement): Unit = noImpl
        public open fun emitNumericLiteral(literal: NumericLiteral): Unit = noImpl
        public open fun emitRegularExpressionLiteral(literal: RegularExpressionLiteral): Unit = noImpl
        public open fun emitStringLiteral(literal: StringLiteral): Unit = noImpl
        public open fun emitEqualsValueClause(clause: EqualsValueClause): Unit = noImpl
        public open fun emitParameter(parameter: Parameter): Unit = noImpl
        public open fun emitConstructorDeclaration(declaration: ConstructorDeclaration): Unit = noImpl
        public open fun shouldEmitFunctionDeclaration(declaration: FunctionDeclaration): Boolean = noImpl
        public open fun emitFunctionDeclaration(declaration: FunctionDeclaration): Unit = noImpl
        public open fun emitSourceUnit(sourceUnit: Any): Unit = noImpl
        public open fun shouldEmitEnumDeclaration(declaration: EnumDeclaration): Boolean = noImpl
        public open fun emitEnumDeclaration(declaration: EnumDeclaration): Unit = noImpl
        public open fun shouldEmitModuleDeclaration(declaration: ModuleDeclaration): Boolean = noImpl
        public open fun emitModuleDeclaration(declaration: Any): Unit = noImpl
        public open fun shouldEmitClassDeclaration(declaration: ClassDeclaration): Boolean = noImpl
        public open fun emitClassDeclaration(declaration: ClassDeclaration): Unit = noImpl
        public open fun shouldEmitInterfaceDeclaration(declaration: InterfaceDeclaration): Boolean = noImpl
        public open fun emitInterfaceDeclaration(declaration: InterfaceDeclaration): Unit = noImpl
        public open fun firstVariableDeclarator(statement: Any): Unit = noImpl
        public open fun isNotAmbientOrHasInitializer(variableStatement: Any): Unit = noImpl
        public open fun shouldEmitVariableStatement(statement: VariableStatement): Boolean = noImpl
        public open fun emitVariableStatement(statement: VariableStatement): Unit = noImpl
        public open fun emitGenericType(`type`: GenericType): Unit = noImpl
        public open fun shouldEmit(ast: Any): Unit = noImpl
        public open fun emit(ast: Any): Unit = noImpl
        public open fun emitWorker(ast: Any): Unit = noImpl
    }
    public fun getLastConstructor(classDecl: ClassDeclaration): ConstructorDeclaration = noImpl
    public fun getTrimmedTextLines(comment: Comment): Array<String> = noImpl
    public open class MemberName {
        public open var prefix: String = noImpl
        public open var suffix: String = noImpl
        public open fun isString(): Boolean = noImpl
        public open fun isArray(): Boolean = noImpl
        public open fun isMarker(): Boolean = noImpl
        override fun toString(): String = noImpl
        public class object {
            public fun memberNameToString(memberName: MemberName, markerInfo: Array<Number>? = null, markerBaseLength: Number? = null): String = noImpl
            public fun create(text: String): MemberName = noImpl
            public fun create(entry: MemberName, prefix: String, suffix: String): MemberName = noImpl
        }
    }
    public open class MemberNameString(text: String) : MemberName() {
        public open var text: String = noImpl
        override fun isString(): Boolean = noImpl
    }
    public open class MemberNameArray : MemberName() {
        public open var delim: String = noImpl
        public open var entries: Array<MemberName> = noImpl
        override fun isArray(): Boolean = noImpl
        public open fun add(entry: MemberName): Unit = noImpl
        public open fun addAll(entries: Array<MemberName>): Unit = noImpl
    }
    public fun stripStartAndEndQuotes(str: String): String = noImpl
    public fun isSingleQuoted(str: String): Boolean = noImpl
    public fun isDoubleQuoted(str: String): Boolean = noImpl
    public fun isQuoted(str: String): Boolean = noImpl
    public fun quoteStr(str: String): String = noImpl
    public fun switchToForwardSlashes(path: String): String = noImpl
    public fun trimModName(modName: String): String = noImpl
    public fun getDeclareFilePath(fname: String): String = noImpl
    public fun isTSFile(fname: String): Boolean = noImpl
    public fun isDTSFile(fname: String): Boolean = noImpl
    public fun getPrettyName(modPath: String, quote: Boolean? = null, treatAsFileName: Boolean? = null): Any = noImpl
    public fun getPathComponents(path: String): Array<String> = noImpl
    public fun getRelativePathToFixedPath(fixedModFilePath: String, absoluteModPath: String, isAbsoultePathURL: Boolean? = null): String = noImpl
    public fun changePathToDTS(modPath: String): String = noImpl
    public fun isRelative(path: String): Boolean = noImpl
    public fun isRooted(path: String): Boolean = noImpl
    public fun getRootFilePath(outFname: String): String = noImpl
    public fun filePathComponents(fullPath: String): Array<String> = noImpl
    public fun filePath(fullPath: String): String = noImpl
    public fun convertToDirectoryPath(dirPath: String): String = noImpl
    public fun normalizePath(path: String): String = noImpl
    public trait IFileReference : ILineAndCharacter {
        public var path: String
        public var isResident: Boolean
        public var position: Number
        public var length: Number
    }
    public trait IPreProcessedFileInfo {
        public var referencedFiles: Array<IFileReference>
        public var importedFiles: Array<IFileReference>
        public var diagnostics: Array<Diagnostic>
        public var isLibFile: Boolean
    }
    public var tripleSlashReferenceRegExp: RegExp = noImpl
    public fun preProcessFile(fileName: String, sourceText: IScriptSnapshot, readImportFiles: Boolean? = null): IPreProcessedFileInfo = noImpl
    public fun getParseOptions(settings: ImmutableCompilationSettings): ParseOptions = noImpl
    public fun getReferencedFiles(fileName: String, sourceText: IScriptSnapshot): Array<IFileReference> = noImpl
    public trait IResolvedFile {
        public var path: String
        public var referencedFiles: Array<String>
        public var importedFiles: Array<String>
    }
    public trait IReferenceResolverHost {
        public fun getScriptSnapshot(fileName: String): IScriptSnapshot
        public fun resolveRelativePath(path: String, directory: String): String
        public fun fileExists(path: String): Boolean
        public fun directoryExists(path: String): Boolean
        public fun getParentDirectory(path: String): String
    }
    public open class ReferenceResolutionResult {
        public open var resolvedFiles: Array<IResolvedFile> = noImpl
        public open var diagnostics: Array<Diagnostic> = noImpl
        public open var seenNoDefaultLibTag: Boolean = noImpl
    }
    public open class ReferenceResolver(inputFileNames: Array<String>, host: IReferenceResolverHost, useCaseSensitiveFileResolution: Boolean) {
        public open var useCaseSensitiveFileResolution: Any = noImpl
        public open var inputFileNames: Any = noImpl
        public open var host: Any = noImpl
        public open var visited: Any = noImpl
        public open fun resolveInputFiles(): ReferenceResolutionResult = noImpl
        public open fun resolveIncludedFile(path: Any, referenceLocation: Any, resolutionResult: Any): Unit = noImpl
        public open fun resolveImportedFile(path: Any, referenceLocation: Any, resolutionResult: Any): Unit = noImpl
        public open fun resolveFile(normalizedPath: Any, resolutionResult: Any): Unit = noImpl
        public open fun getNormalizedFilePath(path: Any, parentFilePath: Any): Unit = noImpl
        public open fun getUniqueFileId(filePath: Any): Unit = noImpl
        public open fun recordVisitedFile(filePath: Any): Unit = noImpl
        public open fun isVisited(filePath: Any): Unit = noImpl
        public open fun isSameFile(filePath1: Any, filePath2: Any): Unit = noImpl
        public class object {
            public fun resolve(inputFileNames: Array<String>, host: IReferenceResolverHost, useCaseSensitiveFileResolution: Boolean): ReferenceResolutionResult = noImpl
        }
    }

    enum class OutputFileType

    public open class TextWriter(name: String, writeByteOrderMark: Boolean, outputFileType: OutputFileType) {
        public open var name: Any = noImpl
        public open var writeByteOrderMark: Any = noImpl
        public open var outputFileType: Any = noImpl
        public open var contents: Any = noImpl
        public open var onNewLine: Boolean = noImpl
        public open fun Write(s: String): Unit = noImpl
        public open fun WriteLine(s: String): Unit = noImpl
        public open fun Close(): Unit = noImpl
        public open fun getOutputFile(): OutputFile = noImpl
    }
    public open class DeclarationEmitter(emittingFileName: String, document: Document, compiler: TypeScriptCompiler, emitOptions: EmitOptions, semanticInfoChain: SemanticInfoChain) {
        public open var emittingFileName: Any = noImpl
        public open var document: Document = noImpl
        public open var compiler: Any = noImpl
        public open var emitOptions: Any = noImpl
        public open var semanticInfoChain: Any = noImpl
        public open var declFile: Any = noImpl
        public open var indenter: Any = noImpl
        public open var emittedReferencePaths: Any = noImpl
        public open fun getOutputFile(): OutputFile = noImpl
        public open fun emitDeclarations(sourceUnit: SourceUnit): Unit = noImpl
        public open fun emitDeclarationsForList(list: Any): Unit = noImpl
        public open fun emitSeparatedList(list: Any): Unit = noImpl
        public open fun emitDeclarationsForAST(ast: Any): Unit = noImpl
        public open fun getIndentString(declIndent: Any? = null): Unit = noImpl
        public open fun emitIndent(): Unit = noImpl
        public open fun canEmitDeclarations(declAST: Any): Unit = noImpl
        public open fun getDeclFlagsString(pullDecl: Any, typeString: Any): Unit = noImpl
        public open fun emitDeclFlags(declarationAST: Any, typeString: Any): Unit = noImpl
        public open fun emitTypeNamesMember(memberName: Any, emitIndent: Any? = null): Unit = noImpl
        public open fun emitTypeSignature(ast: Any, `type`: Any): Unit = noImpl
        public open fun emitComment(comment: Any): Unit = noImpl
        public open fun emitDeclarationComments(ast: Any, endLine: Any? = null): Unit = noImpl
        public open fun writeDeclarationComments(declComments: Any, endLine: Any? = null): Unit = noImpl
        public open fun emitTypeOfVariableDeclaratorOrParameter(boundDecl: Any): Unit = noImpl
        public open fun emitPropertySignature(varDecl: Any): Unit = noImpl
        public open fun emitVariableDeclarator(varDecl: Any, isFirstVarInList: Any, isLastVarInList: Any): Unit = noImpl
        public open fun emitClassElementModifiers(modifiers: Any): Unit = noImpl
        public open fun emitDeclarationsForMemberVariableDeclaration(varDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForVariableStatement(variableStatement: Any): Unit = noImpl
        public open fun emitDeclarationsForVariableDeclaration(variableDeclaration: Any): Unit = noImpl
        public open fun emitArgDecl(argDecl: Any, id: Any, isOptional: Any, isPrivate: Any): Unit = noImpl
        public open fun isOverloadedCallSignature(funcDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForConstructorDeclaration(funcDecl: Any): Unit = noImpl
        public open fun emitParameterList(isPrivate: Any, parameterList: Any): Unit = noImpl
        public open fun emitParameters(isPrivate: Any, parameterList: Any): Unit = noImpl
        public open fun emitMemberFunctionDeclaration(funcDecl: Any): Unit = noImpl
        public open fun emitCallSignature(funcDecl: Any): Unit = noImpl
        public open fun emitConstructSignature(funcDecl: Any): Unit = noImpl
        public open fun emitMethodSignature(funcDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForFunctionDeclaration(funcDecl: Any): Unit = noImpl
        public open fun emitIndexMemberDeclaration(funcDecl: Any): Unit = noImpl
        public open fun emitIndexSignature(funcDecl: Any): Unit = noImpl
        public open fun emitBaseList(bases: Any, useExtendsList: Any): Unit = noImpl
        public open fun emitAccessorDeclarationComments(funcDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForGetAccessor(funcDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForSetAccessor(funcDecl: Any): Unit = noImpl
        public open fun emitMemberAccessorDeclaration(funcDecl: Any, modifiers: Any, name: Any): Unit = noImpl
        public open fun emitClassMembersFromConstructorDefinition(funcDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForClassDeclaration(classDecl: Any): Unit = noImpl
        public open fun emitHeritageClauses(clauses: Any): Unit = noImpl
        public open fun emitHeritageClause(clause: Any): Unit = noImpl
        public open fun emitTypeParameters(typeParams: Any, funcSignature: Any? = null): Unit = noImpl
        public open fun emitDeclarationsForInterfaceDeclaration(interfaceDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForImportDeclaration(importDeclAST: Any): Unit = noImpl
        public open fun emitDeclarationsForEnumDeclaration(moduleDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForModuleDeclaration(moduleDecl: Any): Unit = noImpl
        public open fun emitDeclarationsForExportAssignment(ast: Any): Unit = noImpl
        public open fun resolveScriptReference(document: Any, reference: Any): Unit = noImpl
        public open fun emitReferencePaths(sourceUnit: Any): Unit = noImpl
        public open fun emitDeclarationsForSourceUnit(sourceUnit: Any): Unit = noImpl
        public class object {
            public fun getEnclosingContainer(ast: AST): AST = noImpl
        }
    }
    public open class BloomFilter(expectedCount: Number) {
        public open var bitArray: Any = noImpl
        public open var hashFunctionCount: Any = noImpl
        public open fun computeHash(key: Any, seed: Any): Unit = noImpl
        public open fun addKeys(keys: IIndexable<Any>): Unit = noImpl
        public open fun add(value: String): Unit = noImpl
        public open fun probablyContains(value: String): Boolean = noImpl
        public open fun isEquivalent(filter: BloomFilter): Boolean = noImpl
        public class object {
            public var falsePositiveProbability: Number = noImpl
            public fun computeM(expectedCount: Number): Number = noImpl
            public fun computeK(expectedCount: Number): Number = noImpl
            public fun isEquivalent(array1: Array<Boolean>, array2: Array<Boolean>): Boolean = noImpl
        }
    }
    public open class IdentifierWalker(list: IIndexable<Boolean>) : SyntaxWalker() {
        public open var list: IIndexable<Boolean> = noImpl
        override fun visitToken(token: ISyntaxToken): Unit = noImpl
    }
    public open class CompilationSettings {
        public open var propagateEnumConstants: Boolean = noImpl
        public open var removeComments: Boolean = noImpl
        public open var watch: Boolean = noImpl
        public open var noResolve: Boolean = noImpl
        public open var allowAutomaticSemicolonInsertion: Boolean = noImpl
        public open var noImplicitAny: Boolean = noImpl
        public open var noLib: Boolean = noImpl
        public open var codeGenTarget: LanguageVersion = noImpl
        public open var moduleGenTarget: ModuleGenTarget = noImpl
        public open var outFileOption: String = noImpl
        public open var outDirOption: String = noImpl
        public open var mapSourceFiles: Boolean = noImpl
        public open var mapRoot: String = noImpl
        public open var sourceRoot: String = noImpl
        public open var generateDeclarationFiles: Boolean = noImpl
        public open var useCaseSensitiveFileResolution: Boolean = noImpl
        public open var gatherDiagnostics: Boolean = noImpl
        public open var codepage: Number = noImpl
        public open var createFileLog: Boolean = noImpl
    }

    enum class ModuleGenTarget

    public open class ImmutableCompilationSettings(propagateEnumConstants: Boolean, removeComments: Boolean, watch: Boolean, noResolve: Boolean, allowAutomaticSemicolonInsertion: Boolean, noImplicitAny: Boolean, noLib: Boolean, codeGenTarget: LanguageVersion, moduleGenTarget: ModuleGenTarget, outFileOption: String, outDirOption: String, mapSourceFiles: Boolean, mapRoot: String, sourceRoot: String, generateDeclarationFiles: Boolean, useCaseSensitiveFileResolution: Boolean, gatherDiagnostics: Boolean, codepage: Number, createFileLog: Boolean) {
        public open var _propagateEnumConstants: Any = noImpl
        public open var _removeComments: Any = noImpl
        public open var _watch: Any = noImpl
        public open var _noResolve: Any = noImpl
        public open var _allowAutomaticSemicolonInsertion: Any = noImpl
        public open var _noImplicitAny: Any = noImpl
        public open var _noLib: Any = noImpl
        public open var _codeGenTarget: Any = noImpl
        public open var _moduleGenTarget: Any = noImpl
        public open var _outFileOption: Any = noImpl
        public open var _outDirOption: Any = noImpl
        public open var _mapSourceFiles: Any = noImpl
        public open var _mapRoot: Any = noImpl
        public open var _sourceRoot: Any = noImpl
        public open var _generateDeclarationFiles: Any = noImpl
        public open var _useCaseSensitiveFileResolution: Any = noImpl
        public open var _gatherDiagnostics: Any = noImpl
        public open var _codepage: Any = noImpl
        public open var _createFileLog: Any = noImpl
        public open fun propagateEnumConstants(): Boolean = noImpl
        public open fun removeComments(): Boolean = noImpl
        public open fun watch(): Boolean = noImpl
        public open fun noResolve(): Boolean = noImpl
        public open fun allowAutomaticSemicolonInsertion(): Boolean = noImpl
        public open fun noImplicitAny(): Boolean = noImpl
        public open fun noLib(): Boolean = noImpl
        public open fun codeGenTarget(): LanguageVersion = noImpl
        public open fun moduleGenTarget(): ModuleGenTarget = noImpl
        public open fun outFileOption(): String = noImpl
        public open fun outDirOption(): String = noImpl
        public open fun mapSourceFiles(): Boolean = noImpl
        public open fun mapRoot(): String = noImpl
        public open fun sourceRoot(): String = noImpl
        public open fun generateDeclarationFiles(): Boolean = noImpl
        public open fun useCaseSensitiveFileResolution(): Boolean = noImpl
        public open fun gatherDiagnostics(): Boolean = noImpl
        public open fun codepage(): Number = noImpl
        public open fun createFileLog(): Boolean = noImpl
        public open fun toCompilationSettings(): Any = noImpl
        public class object {
            public var _defaultSettings: Any = noImpl
            public fun defaultSettings(): ImmutableCompilationSettings = noImpl
            public fun fromCompilationSettings(settings: CompilationSettings): ImmutableCompilationSettings = noImpl
        }
    }

    enum class PullElementKind

    public fun hasModifier(modifiers: Array<PullElementFlags>, flag: PullElementFlags): Boolean = noImpl
    public open class PullDecl(declName: String, displayName: String, kind: PullElementKind, declFlags: PullElementFlags, semanticInfoChain: SemanticInfoChain) {
        public open var kind: PullElementKind = noImpl
        public open var name: String = noImpl
        public open var declDisplayName: Any = noImpl
        public open var semanticInfoChain: SemanticInfoChain = noImpl
        public open var declID: Number = noImpl
        public open var flags: PullElementFlags = noImpl
        public open var declGroups: Any = noImpl
        public open var childDecls: Any = noImpl
        public open var typeParameters: Any = noImpl
        public open var synthesizedValDecl: Any = noImpl
        public open var containerDecl: Any = noImpl
        public open var childDeclTypeCache: IIndexable<Array<PullDecl>> = noImpl
        public open var childDeclValueCache: IIndexable<Array<PullDecl>> = noImpl
        public open var childDeclNamespaceCache: IIndexable<Array<PullDecl>> = noImpl
        public open var childDeclTypeParameterCache: IIndexable<Array<PullDecl>> = noImpl
        public open fun fileName(): String = noImpl
        public open fun getParentPath(): Array<PullDecl> = noImpl
        public open fun getParentDecl(): PullDecl = noImpl
        public open fun isExternalModule(): Boolean = noImpl
        public open fun getEnclosingDecl(): PullDecl = noImpl
        public open fun _getEnclosingDeclFromParentDecl(): PullDecl = noImpl
        public open fun getDisplayName(): String = noImpl
        public open fun setSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun ensureSymbolIsBound(): Unit = noImpl
        public open fun getSymbol(): PullSymbol = noImpl
        public open fun hasSymbol(): Boolean = noImpl
        public open fun setSignatureSymbol(signatureSymbol: PullSignatureSymbol): Unit = noImpl
        public open fun getSignatureSymbol(): PullSignatureSymbol = noImpl
        public open fun hasSignatureSymbol(): Boolean = noImpl
        public open fun setFlags(flags: PullElementFlags): Unit = noImpl
        public open fun setFlag(flags: PullElementFlags): Unit = noImpl
        public open fun setValueDecl(valDecl: PullDecl): Unit = noImpl
        public open fun getValueDecl(): PullDecl = noImpl
        public open fun getContainerDecl(): PullDecl = noImpl
        public open fun getChildDeclCache(declKind: Any): Unit = noImpl
        public open fun addChildDecl(childDecl: PullDecl): Unit = noImpl
        public open fun searchChildDecls(declName: String, searchKind: PullElementKind): Array<PullDecl> = noImpl
        public open fun getChildDecls(): Array<PullDecl> = noImpl
        public open fun getTypeParameters(): Array<PullDecl> = noImpl
        public open fun addVariableDeclToGroup(decl: PullDecl): Unit = noImpl
        public open fun getVariableDeclGroups(): Array<Array<PullDecl>> = noImpl
        public open fun hasBeenBound(): Boolean = noImpl
        public open fun isSynthesized(): Boolean = noImpl
        public open fun ast(): AST = noImpl
        // Error in declaration with return type
        public open fun isRootDecl(): Boolean = noImpl
    }
    public open class RootPullDecl(name: String, fileName: String, kind: PullElementKind, declFlags: PullElementFlags, semanticInfoChain: SemanticInfoChain, isExternalModule: Boolean) : PullDecl(noImpl, noImpl, noImpl,noImpl,noImpl) {
        public open var _isExternalModule: Any = noImpl
        public open var _fileName: Any = noImpl
        override fun fileName(): String = noImpl
        override fun getParentPath(): Array<PullDecl> = noImpl
        override fun getParentDecl(): PullDecl = noImpl
        override fun isExternalModule(): Boolean = noImpl
        override fun getEnclosingDecl(): RootPullDecl = noImpl
        override fun isRootDecl(): Boolean = noImpl
    }
    public open class NormalPullDecl(declName: String, displayName: String, kind: PullElementKind, declFlags: PullElementFlags, parentDecl: PullDecl, addToParent: Boolean? = null) : PullDecl(noImpl, noImpl, noImpl,noImpl,noImpl) {
        public open var parentDecl: Any = noImpl
        public open var _rootDecl: RootPullDecl = noImpl
        public open var parentPath: Any = noImpl
        override fun fileName(): String = noImpl
        override fun getParentDecl(): PullDecl = noImpl
        override fun getParentPath(): Array<PullDecl> = noImpl
        override fun isExternalModule(): Boolean = noImpl
        override fun getEnclosingDecl(): PullDecl = noImpl
        override fun isRootDecl(): Boolean = noImpl
    }
    public open class PullEnumElementDecl(declName: String, displayName: String, parentDecl: PullDecl) : NormalPullDecl(noImpl, noImpl, noImpl,noImpl,noImpl, noImpl) {
        public open var constantValue: Number = noImpl
    }
    public open class PullFunctionExpressionDecl(expressionName: String, declFlags: PullElementFlags, parentDecl: PullDecl, displayName: String? = null) : NormalPullDecl(noImpl, noImpl, noImpl,noImpl,noImpl, noImpl) {
        public open var functionExpressionName: Any = noImpl
        public open fun getFunctionExpressionName(): String = noImpl
    }
    public open class PullSynthesizedDecl(declName: String, displayName: String, kind: PullElementKind, declFlags: PullElementFlags, parentDecl: PullDecl, semanticInfoChain: SemanticInfoChain) : NormalPullDecl(noImpl, noImpl, noImpl,noImpl,noImpl, noImpl) {
        override fun isSynthesized(): Boolean = noImpl
        override fun fileName(): String = noImpl
    }
    public open class PullDeclGroup(name: String) {
        public open var name: String = noImpl
        public open var _decls: Any = noImpl
        public open fun addDecl(decl: PullDecl): Unit = noImpl
        public open fun getDecls(): Array<PullDecl> = noImpl
    }
    public var pullSymbolID: Number = noImpl
    public var sentinelEmptyArray: Array<Any> = noImpl
    public open class PullSymbol(name: String, declKind: PullElementKind) {
        public open var pullSymbolID: Number = noImpl
        public open var name: String = noImpl
        public open var kind: PullElementKind = noImpl
        public open var _container: Any = noImpl
        public open var `type`: PullTypeSymbol = noImpl
        public open var _declarations: Any = noImpl
        public open var isResolved: Boolean = noImpl
        public open var isOptional: Boolean = noImpl
        public open var inResolution: Boolean = noImpl
        public open var isSynthesized: Any = noImpl
        public open var isVarArg: Boolean = noImpl
        public open var rootSymbol: Any = noImpl
        public open var _enclosingSignature: Any = noImpl
        public open var _docComments: Any = noImpl
        public open var isPrinting: Boolean = noImpl
        public open fun isAny(): Boolean = noImpl
        public open fun isType(): Boolean = noImpl
        public open fun isTypeReference(): Boolean = noImpl
        public open fun isSignature(): Boolean = noImpl
        public open fun isArrayNamedTypeReference(): Boolean = noImpl
        public open fun isPrimitive(): Boolean = noImpl
        public open fun isAccessor(): Boolean = noImpl
        public open fun isError(): Boolean = noImpl
        public open fun isInterface(): Boolean = noImpl
        public open fun isMethod(): Boolean = noImpl
        public open fun isProperty(): Boolean = noImpl
        public open fun isAlias(): Boolean = noImpl
        public open fun isContainer(): Boolean = noImpl
        public open fun findAliasedTypeSymbols(scopeSymbol: Any, skipScopeSymbolAliasesLookIn: Any? = null, lookIntoOnlyExportedAlias: Any? = null, aliasSymbols: Any? = null, visitedScopeDeclarations: Any? = null): Unit = noImpl
        public open fun getExternalAliasedSymbols(scopeSymbol: PullSymbol): Array<PullTypeAliasSymbol> = noImpl
        public open fun getExportedInternalAliasSymbol(scopeSymbol: Any): Unit = noImpl
        public open fun getAliasSymbolName(scopeSymbol: PullSymbol, aliasNameGetter: (symbol: PullTypeAliasSymbol) -> String, aliasPartsNameGetter: (symbol: PullTypeAliasSymbol) -> String, skipInternalAlias: Boolean? = null): String = noImpl
        public open fun _getResolver(): PullTypeResolver = noImpl
        public open fun _resolveDeclaredSymbol(): PullSymbol = noImpl
        public open fun getName(scopeSymbol: PullSymbol? = null, useConstraintInName: Boolean? = null): String = noImpl
        public open fun getDisplayName(scopeSymbol: PullSymbol? = null, useConstraintInName: Boolean? = null, skipInternalAliasName: Boolean? = null): String = noImpl
        public open fun getIsSpecialized(): Boolean = noImpl
        public open fun getRootSymbol(): PullSymbol = noImpl
        public open fun setRootSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun setIsSynthesized(value: Boolean? = null): Unit = noImpl
        public open fun getIsSynthesized(): Any = noImpl
        public open fun setEnclosingSignature(signature: PullSignatureSymbol): Unit = noImpl
        public open fun getEnclosingSignature(): PullSignatureSymbol = noImpl
        public open fun addDeclaration(decl: PullDecl): Unit = noImpl
        public open fun getDeclarations(): Array<PullDecl> = noImpl
        public open fun hasDeclaration(decl: PullDecl): Boolean = noImpl
        public open fun setContainer(containerSymbol: PullTypeSymbol): Unit = noImpl
        public open fun getContainer(): PullTypeSymbol = noImpl
        public open fun setResolved(): Unit = noImpl
        public open fun startResolving(): Unit = noImpl
        public open fun setUnresolved(): Unit = noImpl
        public open fun anyDeclHasFlag(flag: PullElementFlags): Boolean = noImpl
        public open fun allDeclsHaveFlag(flag: PullElementFlags): Boolean = noImpl
        public open fun pathToRoot(): Array<PullSymbol> = noImpl
        public open fun findQualifyingSymbolPathInScopeSymbol(scopeSymbol: Any): Unit = noImpl
        public open fun toString(scopeSymbol: PullSymbol? = null, useConstraintInName: Boolean? = null): String = noImpl
        public open fun getNamePartForFullName(): String = noImpl
        public open fun fullName(scopeSymbol: PullSymbol? = null): String = noImpl
        public open fun getScopedName(scopeSymbol: PullSymbol? = null, skipTypeParametersInName: Boolean? = null, useConstraintInName: Boolean? = null, skipInternalAliasName: Boolean? = null): String = noImpl
        public open fun getScopedNameEx(scopeSymbol: PullSymbol? = null, skipTypeParametersInName: Boolean? = null, useConstraintInName: Boolean? = null, getPrettyTypeName: Boolean? = null, getTypeParamMarkerInfo: Boolean? = null, skipInternalAliasName: Boolean? = null): MemberName = noImpl
        public open fun getTypeName(scopeSymbol: PullSymbol? = null, getPrettyTypeName: Boolean? = null): String = noImpl
        public open fun getTypeNameEx(scopeSymbol: PullSymbol? = null, getPrettyTypeName: Boolean? = null): MemberName = noImpl
        public open fun getTypeNameForFunctionSignature(prefix: Any, scopeSymbol: Any? = null, getPrettyTypeName: Any? = null): Unit = noImpl
        public open fun getNameAndTypeName(scopeSymbol: PullSymbol? = null): String = noImpl
        public open fun getNameAndTypeNameEx(scopeSymbol: PullSymbol? = null): MemberName = noImpl
        public open fun isExternallyVisible(inIsExternallyVisibleSymbols: Array<PullSymbol>? = null): Boolean = noImpl
        public open fun getDocCommentsOfDecl(decl: Any): Unit = noImpl
        public open fun getDocCommentArray(symbol: Any): Unit = noImpl
        public open fun getDocCommentText(comments: Any): Unit = noImpl
        public open fun getDocCommentTextValue(comment: Any): Unit = noImpl
        public open fun docComments(useConstructorAsClass: Boolean? = null): String = noImpl
        public open fun getParameterDocCommentText(param: Any, fncDocComments: Any): Unit = noImpl
        public open fun cleanJSDocComment(content: Any, spacesToRemove: Any? = null): Unit = noImpl
        public open fun consumeLeadingSpace(line: Any, startIndex: Any, maxSpacesToRemove: Any? = null): Unit = noImpl
        public open fun isSpaceChar(line: Any, index: Any): Unit = noImpl
        public open fun cleanDocCommentLine(line: Any, jsDocStyleComment: Any, jsDocLineSpaceToRemove: Any? = null): Unit = noImpl
        public class object {
            public fun _isExternalModuleReferenceAlias(aliasSymbol: PullTypeAliasSymbol): Boolean = noImpl
            public fun unqualifiedNameReferencesDifferentSymbolInScope(symbol: Any, scopePath: Any, endScopePathIndex: Any): Unit = noImpl
            public fun getTypeParameterString(typars: Array<PullTypeSymbol>, scopeSymbol: PullSymbol? = null, useContraintInName: Boolean? = null): String = noImpl
            public fun getTypeParameterStringEx(typeParameters: Array<PullTypeSymbol>, scopeSymbol: PullSymbol? = null, getTypeParamMarkerInfo: Boolean? = null, useContraintInName: Boolean? = null): MemberNameArray = noImpl
            public fun getIsExternallyVisible(symbol: PullSymbol, fromIsExternallyVisibleSymbol: PullSymbol, inIsExternallyVisibleSymbols: Array<PullSymbol>): Boolean = noImpl
            public fun getDefaultConstructorSymbolForDocComments(classSymbol: Any): Unit = noImpl
        }
    }
    public trait InstantiableSymbol {
        public fun getIsSpecialized(): Boolean
        public fun getAllowedToReferenceTypeParameters(): Array<PullTypeParameterSymbol>
        public fun getTypeParameterArgumentMap(): TypeArgumentMap
    }
    public open class PullSignatureSymbol(kind: PullElementKind, _isDefinition: Boolean? = null) : PullSymbol(noImpl, noImpl), InstantiableSymbol {
        public open var _isDefinition: Any = noImpl
        public open var _memberTypeParameterNameCache: Any = noImpl
        public open var _stringConstantOverload: Any = noImpl
        public open var parameters: Array<PullSymbol> = noImpl
        public open var _typeParameters: Array<PullTypeParameterSymbol> = noImpl
        public open var returnType: PullTypeSymbol = noImpl
        public open var functionType: PullTypeSymbol = noImpl
        public open var hasOptionalParam: Boolean = noImpl
        public open var nonOptionalParamCount: Number = noImpl
        public open var hasVarArgs: Boolean = noImpl
        public open var _allowedToReferenceTypeParameters: Any = noImpl
        public open var _instantiationCache: Any = noImpl
        public open var hasBeenChecked: Boolean = noImpl
        public open var inWrapCheck: Boolean = noImpl
        public open var inWrapInfiniteExpandingReferenceCheck: Boolean = noImpl
        public open var _wrapsTypeParameterCache: Any = noImpl
        public open fun isDefinition(): Boolean = noImpl
        public open fun isGeneric(): Boolean = noImpl
        public open fun addParameter(parameter: PullSymbol, isOptional: Boolean? = null): Unit = noImpl
        public open fun addTypeParameter(typeParameter: PullTypeParameterSymbol): Unit = noImpl
        public open fun addTypeParametersFromReturnType(): Unit = noImpl
        public open fun getTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        public open fun findTypeParameter(name: String): PullTypeParameterSymbol = noImpl
        override fun getTypeParameterArgumentMap(): TypeArgumentMap = noImpl
        override fun getAllowedToReferenceTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        public open fun addSpecialization(specializedVersionOfThisSignature: PullSignatureSymbol, typeArgumentMap: TypeArgumentMap): Unit = noImpl
        public open fun getSpecialization(typeArgumentMap: TypeArgumentMap): PullSignatureSymbol = noImpl
        public open fun isStringConstantOverloadSignature(): Boolean = noImpl
        public open fun getParameterTypeAtIndex(iParam: Number): PullTypeSymbol = noImpl
        override fun toString(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?): String = noImpl
        public open fun getSignatureTypeNameEx(prefix: String, shortform: Boolean, brackets: Boolean, scopeSymbol: PullSymbol? = null, getParamMarkerInfo: Boolean? = null, getTypeParamMarkerInfo: Boolean? = null): MemberNameArray = noImpl
        public open fun forAllParameterTypes(length: Number, predicate: (parameterType: PullTypeSymbol, iterationIndex: Number) -> Boolean): Boolean = noImpl
        public open fun forAllCorrespondingParameterTypesInThisAndOtherSignature(otherSignature: PullSignatureSymbol, predicate: (thisSignatureParameterType: PullTypeSymbol, otherSignatureParameterType: PullTypeSymbol, iterationIndex: Number) -> Boolean): Boolean = noImpl
        public open fun wrapsSomeTypeParameter(typeParameterArgumentMap: TypeArgumentMap): Boolean = noImpl
        public open fun getWrappingTypeParameterID(typeParameterArgumentMap: TypeArgumentMap): Number = noImpl
        public open fun getWrappingTypeParameterIDWorker(typeParameterArgumentMap: TypeArgumentMap): Number = noImpl
        public open fun _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix): Boolean = noImpl
        public open fun _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix): Boolean = noImpl
        public class object {
            public fun getSignatureTypeMemberName(candidateSignature: PullSignatureSymbol, signatures: Array<PullSignatureSymbol>, scopeSymbol: PullSymbol): MemberNameArray = noImpl
            public fun getSignaturesTypeNameEx(signatures: Array<PullSignatureSymbol>, prefix: String, shortform: Boolean, brackets: Boolean, scopeSymbol: PullSymbol? = null, getPrettyTypeName: Boolean? = null, candidateSignature: PullSignatureSymbol? = null): Array<MemberName> = noImpl
        }
    }

    enum class GetAllMembersVisiblity
    enum class GenerativeTypeClassification

    public open class PullTypeSymbol(name: String, kind: PullElementKind) : PullSymbol(noImpl, noImpl), InstantiableSymbol {
        public open var _members: Any = noImpl
        public open var _enclosedMemberTypes: Any = noImpl
        public open var _enclosedMemberContainers: Any = noImpl
        public open var _typeParameters: Any = noImpl
        public open var _allowedToReferenceTypeParameters: Any = noImpl
        public open var _specializedVersionsOfThisType: Any = noImpl
        public open var _arrayVersionOfThisType: Any = noImpl
        public open var _implementedTypes: Any = noImpl
        public open var _extendedTypes: Any = noImpl
        public open var _typesThatExplicitlyImplementThisType: Any = noImpl
        public open var _typesThatExtendThisType: Any = noImpl
        public open var _callSignatures: Any = noImpl
        public open var _allCallSignatures: Any = noImpl
        public open var _constructSignatures: Any = noImpl
        public open var _allConstructSignatures: Any = noImpl
        public open var _indexSignatures: Any = noImpl
        public open var _allIndexSignatures: Any = noImpl
        public open var _allIndexSignaturesOfAugmentedType: Any = noImpl
        public open var _memberNameCache: Any = noImpl
        public open var _enclosedTypeNameCache: Any = noImpl
        public open var _enclosedContainerCache: Any = noImpl
        public open var _typeParameterNameCache: Any = noImpl
        public open var _containedNonMemberNameCache: Any = noImpl
        public open var _containedNonMemberTypeNameCache: Any = noImpl
        public open var _containedNonMemberContainerCache: Any = noImpl
        public open var _simpleInstantiationCache: Any = noImpl
        public open var _complexInstantiationCache: Any = noImpl
        public open var _hasGenericSignature: Any = noImpl
        public open var _hasGenericMember: Any = noImpl
        public open var _hasBaseTypeConflict: Any = noImpl
        public open var _knownBaseTypeCount: Any = noImpl
        public open var _associatedContainerTypeSymbol: Any = noImpl
        public open var _constructorMethod: Any = noImpl
        public open var _hasDefaultConstructor: Any = noImpl
        public open var _functionSymbol: Any = noImpl
        public open var _inMemberTypeNameEx: Any = noImpl
        public open var inSymbolPrivacyCheck: Boolean = noImpl
        public open var inWrapCheck: Boolean = noImpl
        public open var inWrapInfiniteExpandingReferenceCheck: Boolean = noImpl
        public open var typeReference: PullTypeReferenceSymbol = noImpl
        public open var _widenedType: Any = noImpl
        public open var _wrapsTypeParameterCache: Any = noImpl
        public open var _isArrayNamedTypeReference: Any = noImpl
        override fun isArrayNamedTypeReference(): Boolean = noImpl
        public open fun computeIsArrayNamedTypeReference(): Unit = noImpl
        override fun isType(): Boolean = noImpl
        public open fun isClass(): Boolean = noImpl
        public open fun isFunction(): Boolean = noImpl
        public open fun isConstructor(): Boolean = noImpl
        public open fun isTypeParameter(): Boolean = noImpl
        public open fun isTypeVariable(): Boolean = noImpl
        override fun isError(): Boolean = noImpl
        public open fun isEnum(): Boolean = noImpl
        override fun getTypeParameterArgumentMap(): TypeArgumentMap = noImpl
        public open fun isObject(): Boolean = noImpl
        public open fun isFunctionType(): Boolean = noImpl
        public open fun getKnownBaseTypeCount(): Number = noImpl
        public open fun resetKnownBaseTypeCount(): Unit = noImpl
        public open fun incrementKnownBaseCount(): Unit = noImpl
        public open fun setHasBaseTypeConflict(): Unit = noImpl
        public open fun hasBaseTypeConflict(): Boolean = noImpl
        public open fun hasMembers(): Boolean = noImpl
        public open fun setHasGenericSignature(): Unit = noImpl
        public open fun getHasGenericSignature(): Boolean = noImpl
        public open fun setHasGenericMember(): Unit = noImpl
        public open fun getHasGenericMember(): Boolean = noImpl
        public open fun setAssociatedContainerType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun getAssociatedContainerType(): PullTypeSymbol = noImpl
        public open fun getArrayType(): PullTypeSymbol = noImpl
        public open fun getElementType(): PullTypeSymbol = noImpl
        public open fun setArrayType(arrayType: PullTypeSymbol): Unit = noImpl
        public open fun getFunctionSymbol(): PullSymbol = noImpl
        public open fun setFunctionSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun findContainedNonMember(name: String): PullSymbol = noImpl
        public open fun findContainedNonMemberType(typeName: String, kind: PullElementKind? = null): PullTypeSymbol = noImpl
        public open fun findContainedNonMemberContainer(containerName: String, kind: PullElementKind? = null): PullTypeSymbol = noImpl
        public open fun addMember(memberSymbol: PullSymbol): Unit = noImpl
        public open fun addEnclosedMemberType(enclosedType: PullTypeSymbol): Unit = noImpl
        public open fun addEnclosedMemberContainer(enclosedContainer: PullTypeSymbol): Unit = noImpl
        public open fun addEnclosedNonMember(enclosedNonMember: PullSymbol): Unit = noImpl
        public open fun addEnclosedNonMemberType(enclosedNonMemberType: PullTypeSymbol): Unit = noImpl
        public open fun addEnclosedNonMemberContainer(enclosedNonMemberContainer: PullTypeSymbol): Unit = noImpl
        public open fun addTypeParameter(typeParameter: PullTypeParameterSymbol): Unit = noImpl
        public open fun getMembers(): Array<PullSymbol> = noImpl
        public open fun setHasDefaultConstructor(hasOne: Boolean? = null): Unit = noImpl
        public open fun getHasDefaultConstructor(): Boolean = noImpl
        public open fun getConstructorMethod(): PullSymbol = noImpl
        public open fun setConstructorMethod(constructorMethod: PullSymbol): Unit = noImpl
        public open fun getTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        override fun getAllowedToReferenceTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        public open fun isGeneric(): Boolean = noImpl
        public open fun canUseSimpleInstantiationCache(typeArgumentMap: Any): Unit = noImpl
        public open fun getSimpleInstantiationCacheId(typeArgumentMap: Any): Unit = noImpl
        public open fun addSpecialization(specializedVersionOfThisType: PullTypeSymbol, typeArgumentMap: TypeArgumentMap): Unit = noImpl
        public open fun getSpecialization(typeArgumentMap: TypeArgumentMap): PullTypeSymbol = noImpl
        public open fun getKnownSpecializations(): Array<PullTypeSymbol> = noImpl
        public open fun getTypeArguments(): Array<PullTypeSymbol> = noImpl
        public open fun getTypeArgumentsOrTypeParameters(): Array<PullTypeSymbol> = noImpl
        public open fun addCallOrConstructSignaturePrerequisiteBase(signature: Any): Unit = noImpl
        public open fun addCallSignaturePrerequisite(callSignature: Any): Unit = noImpl
        public open fun appendCallSignature(callSignature: PullSignatureSymbol): Unit = noImpl
        public open fun insertCallSignatureAtIndex(callSignature: PullSignatureSymbol, index: Number): Unit = noImpl
        public open fun addConstructSignaturePrerequisite(constructSignature: Any): Unit = noImpl
        public open fun appendConstructSignature(constructSignature: PullSignatureSymbol): Unit = noImpl
        public open fun insertConstructSignatureAtIndex(constructSignature: PullSignatureSymbol, index: Number): Unit = noImpl
        public open fun addIndexSignature(indexSignature: PullSignatureSymbol): Unit = noImpl
        public open fun hasOwnCallSignatures(): Boolean = noImpl
        public open fun getOwnCallSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun getCallSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun hasOwnConstructSignatures(): Boolean = noImpl
        public open fun getOwnDeclaredConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun getConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun hasOwnIndexSignatures(): Boolean = noImpl
        public open fun getOwnIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun getIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        public open fun getIndexSignaturesOfAugmentedType(resolver: PullTypeResolver, globalFunctionInterface: PullTypeSymbol, globalObjectInterface: PullTypeSymbol): Array<PullSignatureSymbol> = noImpl
        public open fun getBaseClassConstructSignatures(baseType: Any): Unit = noImpl
        public open fun getDefaultClassConstructSignature(): Unit = noImpl
        public open fun addImplementedType(implementedType: PullTypeSymbol): Unit = noImpl
        public open fun getImplementedTypes(): Array<PullTypeSymbol> = noImpl
        public open fun addExtendedType(extendedType: PullTypeSymbol): Unit = noImpl
        public open fun getExtendedTypes(): Array<PullTypeSymbol> = noImpl
        public open fun addTypeThatExtendsThisType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun getTypesThatExtendThisType(): Array<PullTypeSymbol> = noImpl
        public open fun addTypeThatExplicitlyImplementsThisType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun getTypesThatExplicitlyImplementThisType(): Array<PullTypeSymbol> = noImpl
        public open fun hasBase(potentialBase: PullTypeSymbol, visited: Array<PullSymbol>? = null): Boolean = noImpl
        public open fun isValidBaseKind(baseType: PullTypeSymbol, isExtendedType: Boolean): Boolean = noImpl
        public open fun findMember(name: String, lookInParent: Boolean): PullSymbol = noImpl
        public open fun findNestedType(name: String, kind: PullElementKind? = null): PullTypeSymbol = noImpl
        public open fun findNestedContainer(name: String, kind: PullElementKind? = null): PullTypeSymbol = noImpl
        public open fun getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): Array<PullSymbol> = noImpl
        public open fun findTypeParameter(name: String): PullTypeParameterSymbol = noImpl
        override fun setResolved(): Unit = noImpl
        override fun getNamePartForFullName(): String = noImpl
        override fun getScopedName(scopeSymbol: PullSymbol?, skipTypeParametersInName: Boolean?, useConstraintInName: Boolean?, skipInternalAliasName: Boolean?): String = noImpl
        public open fun isNamedTypeSymbol(): Boolean = noImpl
        override fun toString(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?): String = noImpl
        override fun getScopedNameEx(scopeSymbol: PullSymbol?, skipTypeParametersInName: Boolean?, useConstraintInName: Boolean?, getPrettyTypeName: Boolean?, getTypeParamMarkerInfo: Boolean?, skipInternalAliasName: Boolean?, shouldAllowArrayType: Boolean?): MemberName = noImpl
        public open fun hasOnlyOverloadCallSignatures(): Boolean = noImpl
        public open fun getTypeOfSymbol(): PullSymbol = noImpl
        public open fun getMemberTypeNameEx(topLevel: Any, scopeSymbol: Any? = null, getPrettyTypeName: Any? = null): Unit = noImpl
        public open fun getGenerativeTypeClassification(enclosingType: PullTypeSymbol): GenerativeTypeClassification = noImpl
        public open fun wrapsSomeTypeParameter(typeParameterArgumentMap: Array<CandidateInferenceInfo>): Boolean = noImpl
        public open fun wrapsSomeTypeParameter(typeParameterArgumentMap: TypeArgumentMap, skipTypeArgumentCheck: Boolean? = null): Boolean = noImpl
        public open fun getWrappingTypeParameterID(typeParameterArgumentMap: TypeArgumentMap, skipTypeArgumentCheck: Boolean? = null): Number = noImpl
        public open fun getWrappingTypeParameterIDFromSignatures(signatures: Any, typeParameterArgumentMap: Any): Unit = noImpl
        public open fun getWrappingTypeParameterIDWorker(typeParameterArgumentMap: Any, skipTypeArgumentCheck: Any): Unit = noImpl
        public open fun wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReference(enclosingType: PullTypeSymbol): Boolean = noImpl
        public open fun _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceRecurse(enclosingType: PullTypeSymbol, knownWrapMap: IBitMatrix): Boolean = noImpl
        public open fun _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceWorker(enclosingType: Any, knownWrapMap: Any): Unit = noImpl
        public open fun _wrapsSomeTypeParameterIntoInfinitelyExpandingTypeReferenceStructure(enclosingType: Any, knownWrapMap: Any): Unit = noImpl
        public open fun widenedType(resolver: PullTypeResolver, ast: AST, context: PullTypeResolutionContext): PullTypeSymbol = noImpl
    }
    public open class PullPrimitiveTypeSymbol(name: String) : PullTypeSymbol(noImpl, noImpl) {
        override fun isAny(): Boolean = noImpl
        public open fun isNull(): Boolean = noImpl
        public open fun isUndefined(): Boolean = noImpl
        public open fun isStringConstant(): Boolean = noImpl
        override fun setUnresolved(): Unit = noImpl
        override fun getDisplayName(): String = noImpl
    }
    public open class PullStringConstantTypeSymbol(name: String) : PullPrimitiveTypeSymbol(noImpl) {
        override fun isStringConstant(): Boolean = noImpl
    }
    public open class PullErrorTypeSymbol(_anyType: PullTypeSymbol, name: String) : PullPrimitiveTypeSymbol(noImpl) {
        public open var _anyType: PullTypeSymbol = noImpl
        override fun isError(): Boolean = noImpl
        override fun _getResolver(): PullTypeResolver = noImpl
        override fun getName(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?): String = noImpl
        override fun getDisplayName(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?, skipInternalAliasName: Boolean?): String = noImpl
        override fun toString(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?): String = noImpl
    }
    public open class PullContainerSymbol(name: String, kind: PullElementKind) : PullTypeSymbol(noImpl, noImpl) {
        public open var instanceSymbol: PullSymbol = noImpl
        public open var assignedValue: Any = noImpl
        public open var assignedType: Any = noImpl
        public open var assignedContainer: Any = noImpl
        override fun isContainer(): Boolean = noImpl
        public open fun setInstanceSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun getInstanceSymbol(): PullSymbol = noImpl
        public open fun setExportAssignedValueSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun getExportAssignedValueSymbol(): PullSymbol = noImpl
        public open fun setExportAssignedTypeSymbol(`type`: PullTypeSymbol): Unit = noImpl
        public open fun getExportAssignedTypeSymbol(): PullTypeSymbol = noImpl
        public open fun setExportAssignedContainerSymbol(container: PullContainerSymbol): Unit = noImpl
        public open fun getExportAssignedContainerSymbol(): PullContainerSymbol = noImpl
        public open fun hasExportAssignment(): Boolean = noImpl
        public open fun getInstanceType(): PullTypeSymbol = noImpl
        public class object {
            public fun usedAsSymbol(containerSymbol: PullSymbol, symbol: PullSymbol): Boolean = noImpl
        }
    }
    public open class PullTypeAliasSymbol(name: String) : PullTypeSymbol(noImpl,noImpl) {
        public open var _assignedValue: Any = noImpl
        public open var _assignedType: Any = noImpl
        public open var _assignedContainer: Any = noImpl
        public open var _isUsedAsValue: Any = noImpl
        public open var _typeUsedExternally: Any = noImpl
        public open var _isUsedInExportAlias: Any = noImpl
        public open var retrievingExportAssignment: Any = noImpl
        public open var linkedAliasSymbols: Any = noImpl
        public open fun isUsedInExportedAlias(): Boolean = noImpl
        public open fun typeUsedExternally(): Boolean = noImpl
        public open fun isUsedAsValue(): Boolean = noImpl
        public open fun setTypeUsedExternally(): Unit = noImpl
        public open fun setIsUsedInExportedAlias(): Unit = noImpl
        public open fun addLinkedAliasSymbol(contingentValueSymbol: PullTypeAliasSymbol): Unit = noImpl
        public open fun setIsUsedAsValue(): Unit = noImpl
        public open fun assignedValue(): PullSymbol = noImpl
        public open fun assignedType(): PullTypeSymbol = noImpl
        public open fun assignedContainer(): PullContainerSymbol = noImpl
        override fun isAlias(): Boolean = noImpl
        override fun isContainer(): Boolean = noImpl
        public open fun setAssignedValueSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun getExportAssignedValueSymbol(): PullSymbol = noImpl
        public open fun setAssignedTypeSymbol(`type`: PullTypeSymbol): Unit = noImpl
        public open fun getExportAssignedTypeSymbol(): PullTypeSymbol = noImpl
        public open fun setAssignedContainerSymbol(container: PullContainerSymbol): Unit = noImpl
        public open fun getExportAssignedContainerSymbol(): PullContainerSymbol = noImpl
        override fun getMembers(): Array<PullSymbol> = noImpl
        override fun getCallSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun findMember(name: String): PullSymbol = noImpl
        override fun findNestedType(name: String): PullTypeSymbol = noImpl
        override fun findNestedContainer(name: String): PullTypeSymbol = noImpl
        override fun getAllMembers(searchDeclKind: PullElementKind, memberVisibility: GetAllMembersVisiblity): Array<PullSymbol> = noImpl
    }
    public open class PullTypeParameterSymbol(name: String) : PullTypeSymbol(noImpl,noImpl) {
        public open var _constraint: Any = noImpl
        override fun isTypeParameter(): Boolean = noImpl
        public open fun setConstraint(constraintType: PullTypeSymbol): Unit = noImpl
        public open fun getConstraint(): PullTypeSymbol = noImpl
        public open fun getBaseConstraint(semanticInfoChain: SemanticInfoChain): PullTypeSymbol = noImpl
        public open fun getConstraintRecursively(visitedTypeParameters: Any): Unit = noImpl
        public open fun getDefaultConstraint(semanticInfoChain: SemanticInfoChain): PullTypeSymbol = noImpl
        override fun getCallSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun isGeneric(): Boolean = noImpl
        override fun fullName(scopeSymbol: PullSymbol?): String = noImpl
        override fun getName(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?): String = noImpl
        override fun getDisplayName(scopeSymbol: PullSymbol?, useConstraintInName: Boolean?, skipInternalAliasName: Boolean?): String = noImpl
        override fun isExternallyVisible(inIsExternallyVisibleSymbols: Array<PullSymbol>?): Boolean = noImpl
    }
    public open class PullAccessorSymbol(name: String) : PullSymbol(noImpl,noImpl) {
        public open var _getterSymbol: Any = noImpl
        public open var _setterSymbol: Any = noImpl
        override fun isAccessor(): Boolean = noImpl
        public open fun setSetter(setter: PullSymbol): Unit = noImpl
        public open fun getSetter(): PullSymbol = noImpl
        public open fun setGetter(getter: PullSymbol): Unit = noImpl
        public open fun getGetter(): PullSymbol = noImpl
    }
    public fun getIDForTypeSubstitutions(instantiatingType: PullTypeSymbol, typeArgumentMap: TypeArgumentMap): String = noImpl
    public fun getIDForTypeSubstitutions(instantiatingSignature: PullSignatureSymbol, typeArgumentMap: TypeArgumentMap): String = noImpl
    public open class EnclosingTypeWalkerState {
        public open var _hasSetEnclosingType: Boolean = noImpl
        public open var _currentSymbols: Array<PullSymbol> = noImpl
        public class object {
            public fun getDefaultEnclosingTypeWalkerState(): EnclosingTypeWalkerState = noImpl
            public fun getNonGenericEnclosingTypeWalkerState(): EnclosingTypeWalkerState = noImpl
            public fun getGenericEnclosingTypeWalkerState(genericEnclosingType: PullTypeSymbol): EnclosingTypeWalkerState = noImpl
        }
    }
    public open class PullTypeEnclosingTypeWalker {
        public open var enclosingTypeWalkerState: Any = noImpl
        public open fun setDefaultTypeWalkerState(): Unit = noImpl
        public open fun setNonGenericEnclosingTypeWalkerState(): Unit = noImpl
        public open fun canSymbolOrDeclBeUsedAsEnclosingTypeHelper(name: Any, kind: Any): Unit = noImpl
        public open fun canDeclBeUsedAsEnclosingType(decl: Any): Unit = noImpl
        public open fun canSymbolBeUsedAsEnclosingType(symbol: Any): Unit = noImpl
        public open fun getEnclosingType(): PullTypeSymbol = noImpl
        public open fun _canWalkStructure(): Boolean = noImpl
        public open fun _getCurrentSymbol(): PullSymbol = noImpl
        public open fun getGenerativeClassification(): GenerativeTypeClassification = noImpl
        public open fun _pushSymbol(symbol: Any): Unit = noImpl
        public open fun _popSymbol(): Unit = noImpl
        public open fun setSymbolAsEnclosingType(`type`: Any): Unit = noImpl
        public open fun _setEnclosingTypeOfParentDecl(decl: Any, setSignature: Any): Unit = noImpl
        public open fun setEnclosingTypeForSymbol(symbol: PullSymbol): EnclosingTypeWalkerState = noImpl
        public open fun startWalkingType(symbol: PullTypeSymbol): EnclosingTypeWalkerState = noImpl
        public open fun endWalkingType(stateWhenStartedWalkingTypes: EnclosingTypeWalkerState): Unit = noImpl
        public open fun walkMemberType(memberName: String, resolver: PullTypeResolver): Unit = noImpl
        public open fun postWalkMemberType(): Unit = noImpl
        public open fun walkSignature(kind: PullElementKind, index: Number): Unit = noImpl
        public open fun postWalkSignature(): Unit = noImpl
        public open fun walkTypeArgument(index: Number): Unit = noImpl
        public open fun postWalkTypeArgument(): Unit = noImpl
        public open fun walkTypeParameterConstraint(index: Number): Unit = noImpl
        public open fun postWalkTypeParameterConstraint(): Unit = noImpl
        public open fun walkReturnType(): Unit = noImpl
        public open fun postWalkReturnType(): Unit = noImpl
        public open fun walkParameterType(iParam: Number): Unit = noImpl
        public open fun postWalkParameterType(): Unit = noImpl
        public open fun getBothKindOfIndexSignatures(resolver: PullTypeResolver, context: PullTypeResolutionContext, includeAugmentedType: Boolean): IndexSignatureInfo = noImpl
        public open fun walkIndexSignatureReturnType(indexSigInfo: IndexSignatureInfo, useStringIndexSignature: Boolean, onlySignature: Boolean? = null): Unit = noImpl
        public open fun postWalkIndexSignatureReturnType(onlySignature: Boolean? = null): Unit = noImpl
        public open fun resetEnclosingTypeWalkerState(): EnclosingTypeWalkerState = noImpl
        public open fun setEnclosingTypeWalkerState(enclosingTypeWalkerState: EnclosingTypeWalkerState): Unit = noImpl
        public class object {
            public var _defaultEnclosingTypeWalkerState: Any = noImpl
            public var _nonGenericEnclosingTypeWalkerState: Any = noImpl
        }
    }
    public open class CandidateInferenceInfo {
        public open var typeParameter: PullTypeParameterSymbol = noImpl
        public open var _inferredTypeAfterFixing: PullTypeSymbol = noImpl
        public open var inferenceCandidates: Array<PullTypeSymbol> = noImpl
        public open fun addCandidate(candidate: PullTypeSymbol): Unit = noImpl
        public open fun isFixed(): Boolean = noImpl
        public open fun fixTypeParameter(resolver: PullTypeResolver, context: PullTypeResolutionContext): Unit = noImpl
    }
    public open class TypeArgumentInferenceContext(resolver: PullTypeResolver, context: PullTypeResolutionContext, signatureBeingInferred: PullSignatureSymbol) {
        public open var resolver: PullTypeResolver = noImpl
        public open var context: PullTypeResolutionContext = noImpl
        public open var signatureBeingInferred: PullSignatureSymbol = noImpl
        public open var inferenceCache: IBitMatrix = noImpl
        public open var candidateCache: Array<CandidateInferenceInfo> = noImpl
        public open fun alreadyRelatingTypes(objectType: PullTypeSymbol, parameterType: PullTypeSymbol): Boolean = noImpl
        public open fun resetRelationshipCache(): Unit = noImpl
        public open fun addInferenceRoot(param: PullTypeParameterSymbol): Unit = noImpl
        public open fun getInferenceInfo(param: PullTypeParameterSymbol): CandidateInferenceInfo = noImpl
        public open fun addCandidateForInference(param: PullTypeParameterSymbol, candidate: PullTypeSymbol): Unit = noImpl
        public open fun inferTypeArguments(): Array<PullTypeSymbol> = noImpl
        public open fun fixTypeParameter(typeParameter: PullTypeParameterSymbol): Unit = noImpl
        public open fun _finalizeInferredTypeArguments(): Array<PullTypeSymbol> = noImpl
        public open fun isInvocationInferenceContext(): Boolean = noImpl
    }
    public open class InvocationTypeArgumentInferenceContext(resolver: PullTypeResolver, context: PullTypeResolutionContext, signatureBeingInferred: PullSignatureSymbol, argumentASTs: ISeparatedSyntaxList2) : TypeArgumentInferenceContext(noImpl, noImpl,noImpl) {
        public open var argumentASTs: ISeparatedSyntaxList2 = noImpl
        override fun isInvocationInferenceContext(): Boolean = noImpl
        override fun inferTypeArguments(): Array<PullTypeSymbol> = noImpl
    }
    public open class ContextualSignatureInstantiationTypeArgumentInferenceContext(resolver: PullTypeResolver, context: PullTypeResolutionContext, signatureBeingInferred: PullSignatureSymbol, contextualSignature: PullSignatureSymbol, shouldFixContextualSignatureParameterTypes: Boolean) : TypeArgumentInferenceContext(noImpl, noImpl,noImpl) {
        public open var contextualSignature: Any = noImpl
        public open var shouldFixContextualSignatureParameterTypes: Any = noImpl
        override fun isInvocationInferenceContext(): Boolean = noImpl
        override fun inferTypeArguments(): Array<PullTypeSymbol> = noImpl
    }
    public open class PullContextualTypeContext(contextualType: PullTypeSymbol, provisional: Boolean, isInferentiallyTyping: Boolean, typeArgumentInferenceContext: TypeArgumentInferenceContext) {
        public open var contextualType: PullTypeSymbol = noImpl
        public open var provisional: Boolean = noImpl
        public open var isInferentiallyTyping: Boolean = noImpl
        public open var typeArgumentInferenceContext: TypeArgumentInferenceContext = noImpl
        public open var provisionallyTypedSymbols: Array<PullSymbol> = noImpl
        public open var hasProvisionalErrors: Boolean = noImpl
        public open var astSymbolMap: Any = noImpl
        public open fun recordProvisionallyTypedSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun invalidateProvisionallyTypedSymbols(): Unit = noImpl
        public open fun setSymbolForAST(ast: AST, symbol: PullSymbol): Unit = noImpl
        public open fun getSymbolForAST(ast: AST): PullSymbol = noImpl
    }
    public open class PullTypeResolutionContext(resolver: PullTypeResolver, inTypeCheck: Boolean? = null, fileName: String? = null) {
        public open var resolver: Any = noImpl
        public open var inTypeCheck: Boolean = noImpl
        public open var fileName: String = noImpl
        public open var contextStack: Any = noImpl
        public open var typeCheckedNodes: Any = noImpl
        public open var enclosingTypeWalker1: Any = noImpl
        public open var enclosingTypeWalker2: Any = noImpl
        public open fun setTypeChecked(ast: AST): Unit = noImpl
        public open fun canTypeCheckAST(ast: AST): Boolean = noImpl
        public open fun _pushAnyContextualType(`type`: Any, provisional: Any, isInferentiallyTyping: Any, argContext: Any): Unit = noImpl
        public open fun pushNewContextualType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun propagateContextualType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun pushInferentialType(`type`: PullTypeSymbol, typeArgumentInferenceContext: TypeArgumentInferenceContext): Unit = noImpl
        public open fun pushProvisionalType(`type`: PullTypeSymbol): Unit = noImpl
        public open fun popAnyContextualType(): PullContextualTypeContext = noImpl
        public open fun hasProvisionalErrors(): Boolean = noImpl
        public open fun getContextualType(): PullTypeSymbol = noImpl
        public open fun fixAllTypeParametersReferencedByType(`type`: PullTypeSymbol, resolver: PullTypeResolver, argContext: TypeArgumentInferenceContext? = null): PullTypeSymbol = noImpl
        public open fun getCurrentTypeArgumentInferenceContext(): Unit = noImpl
        public open fun isInferentiallyTyping(): Boolean = noImpl
        public open fun inProvisionalResolution(): Boolean = noImpl
        public open var inBaseTypeResolution: Any = noImpl
        public open fun isInBaseTypeResolution(): Boolean = noImpl
        public open fun startBaseTypeResolution(): Boolean = noImpl
        public open fun doneBaseTypeResolution(wasInBaseTypeResolution: Boolean): Unit = noImpl
        public open fun setTypeInContext(symbol: PullSymbol, `type`: PullTypeSymbol): Unit = noImpl
        public open fun postDiagnostic(diagnostic: Diagnostic): Unit = noImpl
        public open fun typeCheck(): Boolean = noImpl
        public open fun setSymbolForAST(ast: AST, symbol: PullSymbol): Unit = noImpl
        public open fun getSymbolForAST(ast: AST): PullSymbol = noImpl
        public open fun startWalkingTypes(symbol1: PullTypeSymbol, symbol2: PullTypeSymbol): `T$6` = noImpl
        public open fun endWalkingTypes(statesWhenStartedWalkingTypes: `T$6`): Unit = noImpl
        public open fun setEnclosingTypeForSymbols(symbol1: PullSymbol, symbol2: PullSymbol): `T$7` = noImpl
        public open fun walkMemberTypes(memberName: String): Unit = noImpl
        public open fun postWalkMemberTypes(): Unit = noImpl
        public open fun walkSignatures(kind: PullElementKind, index: Number, index2: Number? = null): Unit = noImpl
        public open fun postWalkSignatures(): Unit = noImpl
        public open fun walkTypeParameterConstraints(index: Number): Unit = noImpl
        public open fun postWalkTypeParameterConstraints(): Unit = noImpl
        public open fun walkTypeArgument(index: Number): Unit = noImpl
        public open fun postWalkTypeArgument(): Unit = noImpl
        public open fun walkReturnTypes(): Unit = noImpl
        public open fun postWalkReturnTypes(): Unit = noImpl
        public open fun walkParameterTypes(iParam: Number): Unit = noImpl
        public open fun postWalkParameterTypes(): Unit = noImpl
        public open fun getBothKindOfIndexSignatures(includeAugmentedType1: Boolean, includeAugmentedType2: Boolean): `T$8` = noImpl
        public open fun walkIndexSignatureReturnTypes(indexSigs: `T$8`, useStringIndexSignature1: Boolean, useStringIndexSignature2: Boolean, onlySignature: Boolean? = null): Unit = noImpl
        public open fun postWalkIndexSignatureReturnTypes(onlySignature: Boolean? = null): Unit = noImpl
        public open fun swapEnclosingTypeWalkers(): Unit = noImpl
        public open fun oneOfClassificationsIsInfinitelyExpanding(): Boolean = noImpl
        public open fun resetEnclosingTypeWalkerStates(): `T$7` = noImpl
        public open fun setEnclosingTypeWalkerStates(enclosingTypeWalkerStates: `T$7`): Unit = noImpl
    }
    public trait IPullTypeCollection {
        public fun getLength(): Number
        public fun getTypeAtIndex(index: Number): PullTypeSymbol
    }
    public open class PullAdditionalCallResolutionData {
        public open var targetSymbol: PullSymbol = noImpl
        public open var resolvedSignatures: Array<PullSignatureSymbol> = noImpl
        public open var candidateSignature: PullSignatureSymbol = noImpl
        public open var actualParametersContextTypeSymbols: Array<PullTypeSymbol> = noImpl
        public open var diagnosticsFromOverloadResolution: Array<Diagnostic> = noImpl
    }
    public open class PullAdditionalObjectLiteralResolutionData {
        public open var membersContextTypeSymbols: Array<PullTypeSymbol> = noImpl
    }
    public trait IndexSignatureInfo {
        public var numericSignature: PullSignatureSymbol
        public var stringSignature: PullSignatureSymbol
    }
    public open class PullTypeResolver(compilationSettings: ImmutableCompilationSettings, semanticInfoChain: SemanticInfoChain) {
        public open var compilationSettings: Any = noImpl
        public open var semanticInfoChain: SemanticInfoChain = noImpl
        public open var _cachedArrayInterfaceType: Any = noImpl
        public open var _cachedNumberInterfaceType: Any = noImpl
        public open var _cachedStringInterfaceType: Any = noImpl
        public open var _cachedBooleanInterfaceType: Any = noImpl
        public open var _cachedObjectInterfaceType: Any = noImpl
        public open var _cachedFunctionInterfaceType: Any = noImpl
        public open var _cachedIArgumentsInterfaceType: Any = noImpl
        public open var _cachedRegExpInterfaceType: Any = noImpl
        public open var _cachedAnyTypeArgs: Any = noImpl
        public open var typeCheckCallBacks: Any = noImpl
        public open var postTypeCheckWorkitems: Any = noImpl
        public open var _cachedFunctionArgumentsSymbol: Any = noImpl
        public open var assignableCache: Any = noImpl
        public open var subtypeCache: Any = noImpl
        public open var identicalCache: Any = noImpl
        public open var inResolvingOtherDeclsWalker: Any = noImpl
        public open fun cachedArrayInterfaceType(): Unit = noImpl
        public open fun getArrayNamedType(): PullTypeSymbol = noImpl
        public open fun cachedNumberInterfaceType(): Unit = noImpl
        public open fun cachedStringInterfaceType(): Unit = noImpl
        public open fun cachedBooleanInterfaceType(): Unit = noImpl
        public open fun cachedObjectInterfaceType(): Unit = noImpl
        public open fun cachedFunctionInterfaceType(): Unit = noImpl
        public open fun cachedIArgumentsInterfaceType(): Unit = noImpl
        public open fun cachedRegExpInterfaceType(): Unit = noImpl
        public open fun cachedFunctionArgumentsSymbol(): Unit = noImpl
        public open fun getApparentType(`type`: Any): Unit = noImpl
        public open fun setTypeChecked(ast: Any, context: Any): Unit = noImpl
        public open fun canTypeCheckAST(ast: Any, context: Any): Unit = noImpl
        public open fun setSymbolForAST(ast: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun getSymbolForAST(ast: Any, context: Any): Unit = noImpl
        public open fun getASTForDecl(decl: PullDecl): AST = noImpl
        public open fun getNewErrorTypeSymbol(name: String? = null): PullErrorTypeSymbol = noImpl
        public open fun getEnclosingDecl(decl: PullDecl): PullDecl = noImpl
        public open fun getExportedMemberSymbol(symbol: Any, parent: Any): Unit = noImpl
        public open fun _getNamedPropertySymbolOfAugmentedType(symbolName: String, parent: PullTypeSymbol): PullSymbol = noImpl
        public open fun getNamedPropertySymbol(symbolName: Any, declSearchKind: Any, parent: Any): Unit = noImpl
        public open fun getSymbolFromDeclPath(symbolName: Any, declPath: Any, declSearchKind: Any): Unit = noImpl
        public open fun getVisibleDeclsFromDeclPath(declPath: Any, declSearchKind: Any): Unit = noImpl
        public open fun addFilteredDecls(decls: Any, declSearchKind: Any, result: Any): Unit = noImpl
        public open fun getVisibleDecls(enclosingDecl: PullDecl): Array<PullDecl> = noImpl
        public open fun getVisibleContextSymbols(enclosingDecl: PullDecl, context: PullTypeResolutionContext): Array<PullSymbol> = noImpl
        public open fun getVisibleMembersFromExpression(expression: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext): Array<PullSymbol> = noImpl
        public open fun isAnyOrEquivalent(`type`: Any): Unit = noImpl
        public open fun resolveExternalModuleReference(idText: Any, currentFileName: Any): Unit = noImpl
        public open fun resolveDeclaredSymbol<TSymbol : PullSymbol>(symbol: TSymbol, context: PullTypeResolutionContext? = null): TSymbol = noImpl
        public open fun resolveDeclaredSymbolWorker<TSymbol : PullSymbol>(symbol: Any, context: Any): Unit = noImpl
        public open fun resolveOtherDecl(otherDecl: Any, context: Any): Unit = noImpl
        public open fun resolveOtherDeclarations(astName: Any, context: Any): Unit = noImpl
        public open fun resolveSourceUnit(sourceUnit: Any, context: Any): Unit = noImpl
        public open fun typeCheckSourceUnit(sourceUnit: Any, context: Any): Unit = noImpl
        public open fun verifyUniquenessOfImportNamesInSourceUnit(sourceUnit: Any): Unit = noImpl
        public open fun resolveEnumDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckEnumDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun postTypeCheckEnumDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun checkInitializersInEnumDeclarations(decl: Any, context: Any): Unit = noImpl
        public open fun resolveModuleDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun ensureAllSymbolsAreBound(containerSymbol: Any): Unit = noImpl
        public open fun resolveModuleSymbol(containerSymbol: Any, context: Any, moduleDeclAST: Any, moduleDeclNameAST: Any, sourceUnitAST: Any): Unit = noImpl
        public open fun resolveFirstExportAssignmentStatement(moduleElements: Any, context: Any): Unit = noImpl
        public open fun resolveSingleModuleDeclaration(ast: Any, astName: Any, context: Any): Unit = noImpl
        public open fun typeCheckModuleDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckSingleModuleDeclaration(ast: Any, astName: Any, context: Any): Unit = noImpl
        public open fun verifyUniquenessOfImportNamesInModule(decl: Any): Unit = noImpl
        public open fun checkUniquenessOfImportNames(decls: Any, doesNameExistOutside: Any? = null): Unit = noImpl
        public open fun scanVariableDeclarationGroups(enclosingDecl: Any, firstDeclHandler: Any, subsequentDeclHandler: Any? = null): Unit = noImpl
        public open fun postTypeCheckModuleDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun isTypeRefWithoutTypeArgs(term: Any): Unit = noImpl
        public open fun createInstantiatedType(`type`: PullTypeSymbol, typeArguments: Array<PullTypeSymbol>): PullTypeSymbol = noImpl
        public open fun resolveReferenceTypeDeclaration(classOrInterface: Any, name: Any, heritageClauses: Any, context: Any): Unit = noImpl
        public open fun resolveClassDeclaration(classDeclAST: Any, context: Any): Unit = noImpl
        public open fun typeCheckTypeParametersOfTypeDeclaration(classOrInterface: Any, context: Any): Unit = noImpl
        public open fun typeCheckClassDeclaration(classDeclAST: Any, context: Any): Unit = noImpl
        public open fun postTypeCheckClassDeclaration(classDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveTypeSymbolSignatures(typeSymbol: Any, context: Any): Unit = noImpl
        public open fun resolveInterfaceDeclaration(interfaceDeclAST: Any, context: Any): Unit = noImpl
        public open fun typeCheckInterfaceDeclaration(interfaceDeclAST: Any, context: Any): Unit = noImpl
        public open fun checkInterfaceDeclForIdenticalTypeParameters(interfaceDeclAST: Any, context: Any): Unit = noImpl
        public open fun checkTypeForDuplicateIndexSignatures(enclosingTypeSymbol: Any): Unit = noImpl
        public open fun filterSymbol(symbol: Any, kind: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun getMemberSymbolOfKind(symbolName: Any, kind: Any, pullTypeSymbol: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun resolveIdentifierOfInternalModuleReference(importDecl: Any, identifier: Any, moduleSymbol: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun resolveModuleReference(importDecl: Any, moduleNameExpr: Any, enclosingDecl: Any, context: Any, declPath: Any): Unit = noImpl
        public open fun resolveInternalModuleReference(importStatementAST: Any, context: Any): Unit = noImpl
        public open fun resolveImportDeclaration(importStatementAST: Any, context: Any): Unit = noImpl
        public open fun typeCheckImportDeclaration(importStatementAST: Any, context: Any): Unit = noImpl
        public open fun postTypeCheckImportDeclaration(importStatementAST: Any, context: Any): Unit = noImpl
        public open fun resolveExportAssignmentStatement(exportAssignmentAST: Any, context: Any): Unit = noImpl
        public open fun resolveAnyFunctionTypeSignature(funcDeclAST: Any, typeParameters: Any, parameterList: Any, returnTypeAnnotation: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionTypeSignatureParameter(argDeclAST: Any, signature: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionExpressionParameter(argDeclAST: Any, id: Any, typeExpr: Any, equalsValueClause: Any, contextParam: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun checkNameForCompilerGeneratedDeclarationCollision(astWithName: Any, isDeclaration: Any, name: Any, context: Any): Unit = noImpl
        public open fun hasRestParameterCodeGen(someFunctionDecl: Any): Unit = noImpl
        public open fun checkArgumentsCollides(ast: Any, context: Any): Unit = noImpl
        public open fun checkIndexOfRestArgumentInitializationCollides(ast: Any, isDeclaration: Any, context: Any): Unit = noImpl
        public open fun checkExternalModuleRequireExportsCollides(ast: Any, name: Any, context: Any): Unit = noImpl
        public open fun resolveObjectTypeTypeReference(objectType: Any, context: Any): Unit = noImpl
        public open fun typeCheckObjectTypeTypeReference(objectType: Any, context: Any): Unit = noImpl
        public open fun resolveTypeAnnotation(typeAnnotation: Any, context: Any): Unit = noImpl
        public open fun resolveTypeReference(typeRef: AST, context: PullTypeResolutionContext): PullTypeSymbol = noImpl
        public open fun getArrayType(elementType: Any): Unit = noImpl
        public open fun computeTypeReferenceSymbol(term: Any, context: Any): Unit = noImpl
        public open fun genericTypeIsUsedWithoutRequiredTypeArguments(typeSymbol: Any, term: Any, context: Any): Unit = noImpl
        public open fun resolveMemberVariableDeclaration(varDecl: Any, context: Any): Unit = noImpl
        public open fun resolvePropertySignature(varDecl: Any, context: Any): Unit = noImpl
        public open fun resolveVariableDeclarator(varDecl: Any, context: Any): Unit = noImpl
        public open fun resolveParameterList(list: Any, context: Any): Unit = noImpl
        public open fun resolveParameter(parameter: Any, context: Any): Unit = noImpl
        public open fun getEnumTypeSymbol(enumElement: Any, context: Any): Unit = noImpl
        public open fun resolveEnumElement(enumElement: Any, context: Any): Unit = noImpl
        public open fun typeCheckEnumElement(enumElement: Any, context: Any): Unit = noImpl
        public open fun resolveEqualsValueClause(clause: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveVariableDeclaratorOrParameterOrEnumElement(varDeclOrParameter: Any, modifiers: Any, name: Any, typeExpr: Any, init: Any, context: Any): Unit = noImpl
        public open fun resolveAndTypeCheckVariableDeclarationTypeExpr(varDeclOrParameter: Any, name: Any, typeExpr: Any, context: Any): Unit = noImpl
        public open fun resolveAndTypeCheckVariableDeclaratorOrParameterInitExpr(varDeclOrParameter: Any, name: Any, typeExpr: Any, init: Any, context: Any, typeExprSymbol: Any): Unit = noImpl
        public open fun typeCheckPropertySignature(varDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckMemberVariableDeclaration(varDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckVariableDeclarator(varDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckParameter(parameter: Any, context: Any): Unit = noImpl
        public open fun typeCheckVariableDeclaratorOrParameterOrEnumElement(varDeclOrParameter: Any, modifiers: Any, name: Any, typeExpr: Any, init: Any, context: Any): Unit = noImpl
        public open fun isForInVariableDeclarator(ast: Any): Unit = noImpl
        public open fun checkSuperCaptureVariableCollides(superAST: Any, isDeclaration: Any, context: Any): Unit = noImpl
        public open fun checkThisCaptureVariableCollides(_thisAST: Any, isDeclaration: Any, context: Any): Unit = noImpl
        public open fun postTypeCheckVariableDeclaratorOrParameter(varDeclOrParameter: Any, context: Any): Unit = noImpl
        public open fun resolveTypeParameterDeclaration(typeParameterAST: Any, context: Any): Unit = noImpl
        public open fun resolveFirstTypeParameterDeclaration(typeParameterSymbol: Any, context: Any): Unit = noImpl
        public open fun typeCheckTypeParameterDeclaration(typeParameterAST: Any, context: Any): Unit = noImpl
        public open fun resolveConstraint(constraint: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionBodyReturnTypes(funcDeclAST: Any, block: Any, bodyExpression: Any, signature: Any, useContextualType: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckConstructorDeclaration(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun constructorHasSuperCall(constructorDecl: Any): Unit = noImpl
        public open fun typeCheckFunctionExpression(funcDecl: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckCallSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckConstructSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckMethodSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckMemberFunctionDeclaration(funcDecl: Any, context: Any): Unit = noImpl
        public open fun containsSingleThrowStatement(block: Any): Unit = noImpl
        public open fun typeCheckAnyFunctionDeclaration(funcDeclAST: Any, isStatic: Any, name: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, context: Any): Unit = noImpl
        public open fun checkThatNonVoidFunctionHasReturnExpressionOrThrowStatement(functionDecl: Any, returnTypeAnnotation: Any, returnTypeSymbol: Any, block: Any, context: Any): Unit = noImpl
        public open fun typeCheckIndexSignature(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun postTypeCheckFunctionDeclaration(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveReturnTypeAnnotationOfFunctionDeclaration(funcDeclAST: Any, returnTypeAnnotation: Any, context: Any): Unit = noImpl
        public open fun resolveMemberFunctionDeclaration(funcDecl: Any, context: Any): Unit = noImpl
        public open fun resolveCallSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun resolveConstructSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun resolveMethodSignature(funcDecl: Any, context: Any): Unit = noImpl
        public open fun resolveAnyFunctionDeclaration(funcDecl: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionExpression(funcDecl: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveSimpleArrowFunctionExpression(funcDecl: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveParenthesizedArrowFunctionExpression(funcDecl: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun getEnclosingClassDeclaration(ast: Any): Unit = noImpl
        public open fun resolveConstructorDeclaration(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveIndexMemberDeclaration(ast: Any, context: Any): Unit = noImpl
        public open fun resolveIndexSignature(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionDeclaration(funcDeclAST: Any, isStatic: Any, name: Any, typeParameters: Any, parameterList: Any, returnTypeAnnotation: Any, block: Any, context: Any): Unit = noImpl
        public open fun resolveGetterReturnTypeAnnotation(getterFunctionDeclarationAst: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun resolveSetterArgumentTypeAnnotation(setterFunctionDeclarationAst: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun resolveAccessorDeclaration(funcDeclAst: Any, context: Any): Unit = noImpl
        public open fun typeCheckAccessorDeclaration(funcDeclAst: Any, context: Any): Unit = noImpl
        public open fun resolveGetAccessorDeclaration(funcDeclAST: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, setterAnnotatedType: Any, context: Any): Unit = noImpl
        public open fun checkIfGetterAndSetterTypeMatch(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun typeCheckGetAccessorDeclaration(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveSetAccessorDeclaration(funcDeclAST: Any, parameterList: Any, context: Any): Unit = noImpl
        public open fun typeCheckSetAccessorDeclaration(funcDeclAST: Any, context: Any): Unit = noImpl
        public open fun resolveList(list: Any, context: Any): Unit = noImpl
        public open fun resolveSeparatedList(list: Any, context: Any): Unit = noImpl
        public open fun resolveVoidExpression(ast: Any, context: Any): Unit = noImpl
        public open fun resolveLogicalOperation(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckLogicalOperation(binex: Any, context: Any): Unit = noImpl
        public open fun resolveLogicalNotExpression(ast: Any, context: Any): Unit = noImpl
        public open fun resolveUnaryArithmeticOperation(ast: Any, context: Any): Unit = noImpl
        public open fun resolvePostfixUnaryExpression(ast: Any, context: Any): Unit = noImpl
        public open fun isAnyOrNumberOrEnum(`type`: Any): Unit = noImpl
        public open fun typeCheckUnaryArithmeticOperation(unaryExpression: Any, context: Any): Unit = noImpl
        public open fun typeCheckPostfixUnaryExpression(unaryExpression: Any, context: Any): Unit = noImpl
        public open fun resolveBinaryArithmeticExpression(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun typeCheckBinaryArithmeticExpression(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun resolveTypeOfExpression(ast: Any, context: Any): Unit = noImpl
        public open fun resolveThrowStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveDeleteExpression(ast: Any, context: Any): Unit = noImpl
        public open fun resolveInstanceOfExpression(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckInstanceOfExpression(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun resolveCommaExpression(commaExpression: Any, context: Any): Unit = noImpl
        public open fun resolveInExpression(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckInExpression(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun resolveForStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveForInStatement(forInStatement: Any, context: Any): Unit = noImpl
        public open fun typeCheckForInStatement(forInStatement: Any, context: Any): Unit = noImpl
        public open fun resolveWhileStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckWhileStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveDoStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckDoStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveIfStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckIfStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveElseClause(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckElseClause(ast: Any, context: Any): Unit = noImpl
        public open fun resolveBlock(ast: Any, context: Any): Unit = noImpl
        public open fun resolveVariableStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveVariableDeclarationList(ast: Any, context: Any): Unit = noImpl
        public open fun resolveWithStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckWithStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveTryStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckTryStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveCatchClause(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckCatchClause(ast: Any, context: Any): Unit = noImpl
        public open fun resolveFinallyClause(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckFinallyClause(ast: Any, context: Any): Unit = noImpl
        public open fun getEnclosingFunctionDeclaration(ast: Any): Unit = noImpl
        public open fun resolveReturnExpression(expression: Any, enclosingFunction: Any, context: Any): Unit = noImpl
        public open fun typeCheckReturnExpression(expression: Any, expressionType: Any, enclosingFunction: Any, context: Any): Unit = noImpl
        public open fun resolveReturnStatement(returnAST: Any, context: Any): Unit = noImpl
        public open fun resolveSwitchStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckSwitchStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveLabeledStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckLabeledStatement(ast: Any, context: Any): Unit = noImpl
        public open fun labelIsOnContinuableConstruct(statement: Any): Unit = noImpl
        public open fun resolveContinueStatement(ast: Any, context: Any): Unit = noImpl
        public open fun isIterationStatement(ast: Any): Unit = noImpl
        public open fun isAnyFunctionExpressionOrDeclaration(ast: Any): Unit = noImpl
        public open fun inSwitchStatement(ast: Any): Unit = noImpl
        public open fun inIterationStatement(ast: Any, crossFunctions: Any): Unit = noImpl
        public open fun getEnclosingLabels(ast: Any, breakable: Any, crossFunctions: Any): Unit = noImpl
        public open fun typeCheckContinueStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveBreakStatement(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckBreakStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveAST(ast: AST, isContextuallyTyped: Boolean, context: PullTypeResolutionContext): PullSymbol = noImpl
        public open fun resolveExpressionAST(ast: Any, isContextuallyOrInferentiallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveExpressionWorker(ast: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckAST(ast: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun processPostTypeCheckWorkItems(context: Any): Unit = noImpl
        public open fun postTypeCheck(ast: Any, context: Any): Unit = noImpl
        public open fun resolveRegularExpressionLiteral(): Unit = noImpl
        public open fun postTypeCheckNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun typeCheckNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun resolveNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun isInEnumDecl(decl: Any): Unit = noImpl
        public open fun getSomeInnermostFunctionScopeDecl(declPath: Any): Unit = noImpl
        public open fun isFromFunctionScope(nameSymbol: Any, functionScopeDecl: Any): Unit = noImpl
        public open fun findConstructorDeclOfEnclosingType(decl: Any): Unit = noImpl
        public open fun checkNameAsPartOfInitializerExpressionForInstanceMemberVariable(nameAST: Any, nameSymbol: Any, context: Any): Unit = noImpl
        public open fun computeNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun getCurrentParameterIndexForFunction(parameter: Any, funcDecl: Any): Unit = noImpl
        public open fun resolveMemberAccessExpression(dottedNameAST: Any, context: Any): Unit = noImpl
        public open fun resolveDottedNameExpression(dottedNameAST: Any, expression: Any, name: Any, context: Any): Unit = noImpl
        public open fun computeDottedNameExpression(expression: Any, name: Any, context: Any, checkSuperPrivateAndStaticAccess: Any): Unit = noImpl
        public open fun computeDottedNameExpressionFromLHS(lhs: Any, expression: Any, name: Any, context: Any, checkSuperPrivateAndStaticAccess: Any): Unit = noImpl
        public open fun resolveTypeNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun computeTypeNameExpression(nameAST: Any, context: Any): Unit = noImpl
        public open fun isInStaticMemberContext(decl: Any): Unit = noImpl
        public open fun isLeftSideOfQualifiedName(ast: Any): Unit = noImpl
        public open fun resolveGenericTypeReference(genericTypeAST: Any, context: Any): Unit = noImpl
        public open fun resolveQualifiedName(dottedNameAST: Any, context: Any): Unit = noImpl
        public open fun isLastNameOfModuleNameModuleReference(ast: Any): Unit = noImpl
        public open fun computeQualifiedName(dottedNameAST: Any, context: Any): Unit = noImpl
        public open fun shouldContextuallyTypeAnyFunctionExpression(functionExpressionAST: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, context: Any): Unit = noImpl
        public open fun resolveAnyFunctionExpression(funcDeclAST: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, bodyExpression: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveAnyFunctionExpressionParameters(funcDeclAST: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckSimpleArrowFunctionExpression(arrowFunction: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckParenthesizedArrowFunctionExpression(arrowFunction: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckAnyFunctionExpression(funcDeclAST: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, bodyExpression: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveThisExpression(thisExpression: Any, context: Any): Unit = noImpl
        public open fun inTypeArgumentList(ast: Any): Unit = noImpl
        public open fun inClassExtendsHeritageClause(ast: Any): Unit = noImpl
        public open fun inTypeQuery(ast: Any): Unit = noImpl
        public open fun inArgumentListOfSuperInvocation(ast: Any): Unit = noImpl
        public open fun inConstructorParameterList(ast: Any): Unit = noImpl
        public open fun isFunctionAccessorOrNonArrowFunctionExpression(decl: Any): Unit = noImpl
        public open fun isFunctionOrNonArrowFunctionExpression(decl: Any): Unit = noImpl
        public open fun typeCheckThisExpression(thisExpression: Any, context: Any, enclosingDecl: Any): Unit = noImpl
        public open fun getContextualClassSymbolForEnclosingDecl(ast: Any, enclosingDecl: Any): Unit = noImpl
        public open fun inStaticMemberVariableDeclaration(ast: Any): Unit = noImpl
        public open fun resolveSuperExpression(ast: Any, context: Any): Unit = noImpl
        public open fun typeCheckSuperExpression(ast: Any, context: Any, enclosingDecl: Any): Unit = noImpl
        public open fun resolveSimplePropertyAssignment(propertyAssignment: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveFunctionPropertyAssignment(funcProp: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun typeCheckFunctionPropertyAssignment(funcProp: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveObjectLiteralExpression(expressionAST: ObjectLiteralExpression, isContextuallyTyped: Boolean, context: PullTypeResolutionContext, additionalResults: PullAdditionalObjectLiteralResolutionData? = null): PullSymbol = noImpl
        public open fun bindObjectLiteralMembers(objectLiteralDeclaration: Any, objectLiteralTypeSymbol: Any, objectLiteralMembers: Any, isUsingExistingSymbol: Any, pullTypeContext: Any): Unit = noImpl
        public open fun resolveObjectLiteralMembers(objectLiteralDeclaration: Any, objectLiteralTypeSymbol: Any, objectLiteralContextualType: Any, objectLiteralMembers: Any, stringIndexerSignature: Any, numericIndexerSignature: Any, allMemberTypes: Any, allNumericMemberTypes: Any, boundMemberSymbols: Any, isUsingExistingSymbol: Any, pullTypeContext: Any, additionalResults: Any? = null): Unit = noImpl
        public open fun computeObjectLiteralExpression(objectLitAST: Any, isContextuallyTyped: Any, context: Any, additionalResults: Any? = null): Unit = noImpl
        public open fun getPropertyAssignmentName(propertyAssignment: Any): Unit = noImpl
        public open fun stampObjectLiteralWithIndexSignature(objectLiteralSymbol: Any, indexerTypeCandidates: Any, contextualIndexSignature: Any, context: Any): Unit = noImpl
        public open fun resolveArrayLiteralExpression(arrayLit: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun computeArrayLiteralExpressionSymbol(arrayLit: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveElementAccessExpression(callEx: Any, context: Any): Unit = noImpl
        public open fun typeCheckElementAccessExpression(callEx: Any, context: Any, symbolAndDiagnostic: Any): Unit = noImpl
        public open fun computeElementAccessExpressionSymbolAndDiagnostic(callEx: Any, context: Any): Unit = noImpl
        public open fun getBothKindsOfIndexSignaturesIncludingAugmentedType(enclosingType: Any, context: Any): Unit = noImpl
        public open fun getBothKindsOfIndexSignaturesExcludingAugmentedType(enclosingType: Any, context: Any): Unit = noImpl
        public open fun _getBothKindsOfIndexSignatures(enclosingType: PullTypeSymbol, context: PullTypeResolutionContext, includeAugmentedType: Boolean): IndexSignatureInfo = noImpl
        public open fun _addUnhiddenSignaturesFromBaseType(derivedTypeSignatures: Array<PullSignatureSymbol>, baseTypeSignatures: Array<PullSignatureSymbol>, signaturesBeingAggregated: Array<PullSignatureSymbol>): Unit = noImpl
        public open fun resolveBinaryAdditionOperation(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun bestCommonTypeOfTwoTypes(type1: Any, type2: Any, context: Any): Unit = noImpl
        public open fun bestCommonTypeOfThreeTypes(type1: Any, type2: Any, type3: Any, context: Any): Unit = noImpl
        public open fun resolveLogicalOrExpression(binex: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveLogicalAndExpression(binex: Any, context: Any): Unit = noImpl
        public open fun computeTypeOfConditionalExpression(leftType: Any, rightType: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveConditionalExpression(trinex: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun conditionExpressionTypesAreValid(leftType: Any, rightType: Any, expressionType: Any, isContextuallyTyped: Any, context: Any): Unit = noImpl
        public open fun resolveParenthesizedExpression(ast: Any, context: Any): Unit = noImpl
        public open fun resolveExpressionStatement(ast: Any, context: Any): Unit = noImpl
        public open fun resolveInvocationExpression(callEx: InvocationExpression, context: PullTypeResolutionContext, additionalResults: PullAdditionalCallResolutionData? = null): PullSymbol = noImpl
        public open fun typeCheckInvocationExpression(callEx: Any, context: Any): Unit = noImpl
        public open fun computeInvocationExpressionSymbol(callEx: Any, context: Any, additionalResults: Any): Unit = noImpl
        public open fun resolveObjectCreationExpression(callEx: ObjectCreationExpression, context: PullTypeResolutionContext, additionalResults: PullAdditionalCallResolutionData? = null): PullSymbol = noImpl
        public open fun typeCheckObjectCreationExpression(callEx: Any, context: Any): Unit = noImpl
        public open fun postOverloadResolutionDiagnostics(diagnostic: Any, additionalResults: Any, context: Any): Unit = noImpl
        public open fun computeObjectCreationExpressionSymbol(callEx: Any, context: Any, additionalResults: Any): Unit = noImpl
        public open fun instantiateSignatureInContext(signatureAToInstantiate: Any, contextualSignatureB: Any, context: Any, shouldFixContextualSignatureParameterTypes: Any): Unit = noImpl
        public open fun resolveCastExpression(assertionExpression: Any, context: Any): Unit = noImpl
        public open fun typeCheckCastExpression(assertionExpression: Any, context: Any, typeAssertionType: Any): Unit = noImpl
        public open fun resolveAssignmentExpression(binaryExpression: Any, context: Any): Unit = noImpl
        public open fun getInstanceTypeForAssignment(lhs: Any, `type`: Any, context: Any): Unit = noImpl
        public open fun widenType(`type`: PullTypeSymbol, ast: AST, context: PullTypeResolutionContext): PullTypeSymbol = noImpl
        public open fun widenArrayType(`type`: Any, ast: Any, context: Any): Unit = noImpl
        public open fun widenObjectLiteralType(`type`: Any, ast: Any, context: Any): Unit = noImpl
        public open fun needsToWidenObjectLiteralType(`type`: Any, ast: Any, context: Any): Unit = noImpl
        public open fun findBestCommonType(collection: IPullTypeCollection, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo? = null): PullTypeSymbol = noImpl
        public open fun typeIsBestCommonTypeCandidate(candidateType: Any, collection: Any, context: Any): Unit = noImpl
        public open fun typesAreIdenticalInEnclosingTypes(t1: Any, t2: Any, context: Any): Unit = noImpl
        public open fun typesAreIdenticalWithNewEnclosingTypes(t1: Any, t2: Any, context: Any): Unit = noImpl
        public open fun typesAreIdentical(t1: PullTypeSymbol, t2: PullTypeSymbol, context: PullTypeResolutionContext): Boolean = noImpl
        public open fun typesAreIdenticalWorker(t1: Any, t2: Any, context: Any): Unit = noImpl
        public open fun propertiesAreIdentical(propertySymbol1: Any, propertySymbol2: Any, context: Any): Unit = noImpl
        public open fun propertiesAreIdenticalWithNewEnclosingTypes(type1: Any, type2: Any, property1: Any, property2: Any, context: Any): Unit = noImpl
        public open fun signatureGroupsAreIdentical(sg1: Any, sg2: Any, context: Any): Unit = noImpl
        public open fun typeParametersAreIdentical(tp1: Any, tp2: Any, context: Any): Unit = noImpl
        public open fun typeParametersAreIdenticalWorker(tp1: Any, tp2: Any, context: Any): Unit = noImpl
        public open fun setTypeParameterIdentity(tp1: Any, tp2: Any, `val`: Any): Unit = noImpl
        public open fun signaturesAreIdenticalWithNewEnclosingTypes(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, includingReturnType: Boolean? = null): Boolean = noImpl
        public open fun signaturesAreIdentical(s1: Any, s2: Any, context: Any, includingReturnType: Any? = null): Unit = noImpl
        public open fun signaturesAreIdenticalWorker(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, includingReturnType: Boolean? = null): Boolean = noImpl
        public open fun signatureTypeParametersParametersAndReturnTypesAreIdentical(s1: Any, s2: Any, context: Any, includingReturnType: Any? = null): Unit = noImpl
        public open fun signatureReturnTypesAreIdentical(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext): Boolean = noImpl
        public open fun symbolsShareDeclaration(symbol1: Any, symbol2: Any): Unit = noImpl
        public open fun sourceIsSubtypeOfTarget(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any? = null, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceMembersAreAssignableToTargetMembers(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourcePropertyIsAssignableToTargetProperty(source: Any, target: Any, sourceProp: Any, targetProp: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceCallSignaturesAreAssignableToTargetCallSignatures(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceConstructSignaturesAreAssignableToTargetConstructSignatures(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceIndexSignaturesAreAssignableToTargetIndexSignatures(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun typeIsAssignableToFunction(source: Any, ast: Any, context: Any): Unit = noImpl
        public open fun signatureIsAssignableToTarget(s1: Any, s2: Any, ast: Any, context: Any, comparisonInfo: Any? = null, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceIsAssignableToTarget(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any? = null, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun sourceIsAssignableToTargetWithNewEnclosingTypes(source: Any, target: Any, ast: Any, context: Any, comparisonInfo: Any? = null, isComparingInstantiatedSignatures: Any? = null): Unit = noImpl
        public open fun getSymbolForRelationshipCheck(symbol: Any): Unit = noImpl
        public open fun sourceIsRelatableToTargetInEnclosingTypes(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceIsRelatableToTargetWithNewEnclosingTypes(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceIsRelatableToTargetInCache(source: Any, target: Any, comparisonCache: Any, comparisonInfo: Any): Unit = noImpl
        public open fun sourceIsRelatableToTarget(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun isSourceTypeParameterConstrainedToTargetTypeParameter(source: Any, target: Any): Unit = noImpl
        public open fun sourceIsRelatableToTargetWorker(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceMembersAreRelatableToTargetMembers(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun infinitelyExpandingSourceTypeIsRelatableToTargetType(sourceType: Any, targetType: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun infinitelyExpandingTypesAreIdentical(sourceType: Any, targetType: Any, context: Any): Unit = noImpl
        public open fun sourcePropertyIsRelatableToTargetProperty(source: Any, target: Any, sourceProp: Any, targetProp: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceCallSignaturesAreRelatableToTargetCallSignatures(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source: Any, target: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun signatureGroupIsRelatableToTarget(source: Any, target: Any, sourceSG: Any, targetSG: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun signatureIsRelatableToTarget(sourceSig: Any, targetSig: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun signatureIsRelatableToTargetWorker(sourceSig: Any, targetSig: Any, assignableTo: Any, comparisonCache: Any, ast: Any, context: Any, comparisonInfo: Any, isComparingInstantiatedSignatures: Any): Unit = noImpl
        public open fun resolveOverloads(application: Any, group: Any, haveTypeArgumentsAtCallSite: Any, context: Any, diagnostics: Any): Unit = noImpl
        public open fun getCallTargetErrorSpanAST(callEx: Any): Unit = noImpl
        public open fun overloadHasCorrectArity(signature: Any, args: Any): Unit = noImpl
        public open fun overloadIsApplicable(signature: Any, args: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForArgument(paramType: Any, arg: Any, argIndex: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForAnyFunctionExpressionArgument(paramType: Any, arg: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, bodyExpression: Any, argIndex: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForObjectLiteralArgument(paramType: Any, arg: Any, argIndex: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForArrayLiteralArgument(paramType: Any, arg: Any, argIndex: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForOtherArgument(paramType: Any, arg: Any, argIndex: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun overloadIsApplicableForArgumentHelper(paramType: Any, argSym: Any, argumentIndex: Any, comparisonInfo: Any, arg: Any, context: Any): Unit = noImpl
        public open fun inferArgumentTypesForSignature(argContext: Any, comparisonInfo: Any, context: Any): Unit = noImpl
        public open fun typeParametersAreInScopeAtArgumentList(typeParameters: Any, args: Any): Unit = noImpl
        public open fun relateTypeToTypeParametersInEnclosingType(expressionType: Any, parameterType: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun relateTypeToTypeParametersWithNewEnclosingTypes(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol, argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext): Unit = noImpl
        public open fun relateTypeToTypeParameters(expressionType: PullTypeSymbol, parameterType: PullTypeSymbol, argContext: TypeArgumentInferenceContext, context: PullTypeResolutionContext): Unit = noImpl
        public open fun relateTypeArgumentsOfTypeToTypeParameters(expressionType: Any, parameterType: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun relateInifinitelyExpandingTypeToTypeParameters(expressionType: Any, parameterType: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun relateFunctionSignatureToTypeParameters(expressionSignature: Any, parameterSignature: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun relateObjectTypeToTypeParameters(objectType: Any, parameterType: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun relateSignatureGroupToTypeParameters(argumentSignatures: Any, parameterSignatures: Any, signatureKind: Any, argContext: Any, context: Any): Unit = noImpl
        public open fun alterPotentialGenericFunctionTypeToInstantiatedFunctionTypeForTypeArgumentInference(expressionSymbol: Any, context: Any): Unit = noImpl
        public open fun isFunctionTypeWithExactlyOneCallSignatureAndNoOtherMembers(`type`: Any, callSignatureShouldBeGeneric: Any): Unit = noImpl
        public open fun instantiateTypeToAny(typeToSpecialize: PullTypeSymbol, context: PullTypeResolutionContext): PullTypeSymbol = noImpl
        public open fun instantiateSignatureToAny(signature: PullSignatureSymbol): PullSignatureSymbol = noImpl
        public open fun validateVariableDeclarationGroups(enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckFunctionOverloads(funcDecl: Any, context: Any, signature: Any? = null, allSignatures: Any? = null): Unit = noImpl
        public open fun checkSymbolPrivacy(declSymbol: Any, symbol: Any, privacyErrorReporter: Any): Unit = noImpl
        public open fun checkTypePrivacyOfSignatures(declSymbol: Any, signatures: Any, privacyErrorReporter: Any): Unit = noImpl
        public open fun typeParameterOfTypeDeclarationPrivacyErrorReporter(classOrInterface: Any, typeParameterAST: Any, typeParameter: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun baseListPrivacyErrorReporter(classOrInterface: Any, declSymbol: Any, baseAst: Any, isExtendedType: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun variablePrivacyErrorReporter(declAST: Any, declSymbol: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun checkFunctionTypePrivacy(funcDeclAST: Any, isStatic: Any, typeParameters: Any, parameters: Any, returnTypeAnnotation: Any, block: Any, context: Any): Unit = noImpl
        public open fun functionTypeArgumentArgumentTypePrivacyErrorReporter(declAST: Any, isStatic: Any, typeParameterAST: Any, typeParameter: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun functionArgumentTypePrivacyErrorReporter(declAST: Any, isStatic: Any, parameters: Any, argIndex: Any, paramSymbol: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun functionReturnTypePrivacyErrorReporter(declAST: Any, isStatic: Any, returnTypeAnnotation: Any, block: Any, funcReturnType: Any, symbol: Any, context: Any): Unit = noImpl
        public open fun enclosingClassIsDerived(classDecl: Any): Unit = noImpl
        public open fun isSuperInvocationExpression(ast: Any): Unit = noImpl
        public open fun isSuperInvocationExpressionStatement(node: Any): Unit = noImpl
        public open fun getFirstStatementOfBlockOrNull(block: Any): Unit = noImpl
        public open fun superCallMustBeFirstStatementInConstructor(constructorDecl: Any): Unit = noImpl
        public open fun checkForThisCaptureInArrowFunction(expression: Any): Unit = noImpl
        public open fun typeCheckMembersAgainstIndexer(containerType: Any, containerTypeDecl: Any, context: Any): Unit = noImpl
        public open fun determineRelevantIndexerForMember(member: Any, numberIndexSignature: Any, stringIndexSignature: Any): Unit = noImpl
        public open fun reportErrorThatMemberIsNotSubtypeOfIndexer(member: Any, indexSignature: Any, astForError: Any, context: Any, comparisonInfo: Any): Unit = noImpl
        public open fun typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol: Any, extendedType: Any, typeMember: Any, extendedTypeMember: Any, enclosingDecl: Any, comparisonInfo: Any): Unit = noImpl
        public open fun typeCheckIfTypeExtendsType(classOrInterface: Any, name: Any, typeSymbol: Any, extendedType: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckIfClassImplementsType(classDecl: Any, classSymbol: Any, implementedType: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun computeValueSymbolFromAST(valueDeclAST: Any, context: Any): Unit = noImpl
        public open fun hasClassTypeSymbolConflictAsValue(baseDeclAST: Any, typeSymbol: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckBase(classOrInterface: Any, name: Any, typeSymbol: Any, baseDeclAST: Any, isExtendedType: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun typeCheckBases(classOrInterface: Any, name: Any, heritageClauses: Any, typeSymbol: Any, enclosingDecl: Any, context: Any): Unit = noImpl
        public open fun checkTypeCompatibilityBetweenBases(name: Any, typeSymbol: Any, context: Any): Unit = noImpl
        public open fun checkNamedPropertyIdentityBetweenBases(interfaceName: Any, interfaceSymbol: Any, baseTypeSymbol: Any, inheritedMembersMap: Any, context: Any): Unit = noImpl
        public open fun checkIndexSignatureIdentityBetweenBases(interfaceName: Any, interfaceSymbol: Any, baseTypeSymbol: Any, allInheritedSignatures: Any, derivedTypeHasOwnNumberSignature: Any, derivedTypeHasOwnStringSignature: Any, context: Any): Unit = noImpl
        public open fun checkInheritedMembersAgainstInheritedIndexSignatures(interfaceName: Any, interfaceSymbol: Any, inheritedIndexSignatures: Any, inheritedMembers: Any, context: Any): Unit = noImpl
        public open fun checkThatInheritedNumberSignatureIsSubtypeOfInheritedStringSignature(interfaceName: Any, interfaceSymbol: Any, inheritedIndexSignatures: Any, context: Any): Unit = noImpl
        public open fun checkAssignability(ast: Any, source: Any, target: Any, context: Any): Unit = noImpl
        public open fun isReference(ast: Any, astSymbol: Any): Unit = noImpl
        public open fun checkForSuperMemberAccess(expression: Any, name: Any, resolvedName: Any, context: Any): Unit = noImpl
        public open fun getEnclosingDeclForAST(ast: Any): Unit = noImpl
        public open fun getEnclosingSymbolForAST(ast: Any): Unit = noImpl
        public open fun checkForPrivateMemberAccess(name: Any, expressionType: Any, resolvedName: Any, context: Any): Unit = noImpl
        public open fun instantiateType(`type`: PullTypeSymbol, typeParameterArgumentMap: TypeArgumentMap): PullTypeSymbol = noImpl
        public open fun instantiateTypeParameter(typeParameter: PullTypeParameterSymbol, typeParameterArgumentMap: TypeArgumentMap): PullTypeParameterSymbol = noImpl
        public open fun instantiateSignature(signature: PullSignatureSymbol, typeParameterArgumentMap: TypeArgumentMap): PullSignatureSymbol = noImpl
        public class object {
            public fun hasSetAccessorParameterTypeAnnotation(setAccessor: SetAccessor): Boolean = noImpl
            public var globalTypeCheckPhase: Number = noImpl
            public fun typeCheck(compilationSettings: ImmutableCompilationSettings, semanticInfoChain: SemanticInfoChain, document: Document): Unit = noImpl
        }
    }
    enum class TypeRelationshipFlags
    public open class TypeComparisonInfo(sourceComparisonInfo: TypeComparisonInfo? = null, useSameIndent: Boolean? = null) {
        public open var onlyCaptureFirstError: Boolean = noImpl
        public open var flags: TypeRelationshipFlags = noImpl
        public open var message: String = noImpl
        public open var stringConstantVal: AST = noImpl
        public open var indent: Any = noImpl
        public open fun indentString(): Unit = noImpl
        public open fun addMessage(message: String): Unit = noImpl
    }
    public fun getPropertyAssignmentNameTextFromIdentifier(identifier: AST): `T$9` = noImpl
    public fun isTypesOnlyLocation(ast: AST): Boolean = noImpl
    public var declCacheHit: Number = noImpl
    public var declCacheMiss: Number = noImpl
    public var symbolCacheHit: Number = noImpl
    public var symbolCacheMiss: Number = noImpl
    public open class SemanticInfoChain(compiler: TypeScriptCompiler, logger: ILogger) {
        public open var compiler: Any = noImpl
        public open var logger: Any = noImpl
        public open var documents: Any = noImpl
        public open var fileNameToDocument: Any = noImpl
        public open var anyTypeDecl: PullDecl = noImpl
        public open var booleanTypeDecl: PullDecl = noImpl
        public open var numberTypeDecl: PullDecl = noImpl
        public open var stringTypeDecl: PullDecl = noImpl
        public open var nullTypeDecl: PullDecl = noImpl
        public open var undefinedTypeDecl: PullDecl = noImpl
        public open var voidTypeDecl: PullDecl = noImpl
        public open var undefinedValueDecl: PullDecl = noImpl
        public open var anyTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var booleanTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var numberTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var stringTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var nullTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var undefinedTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var voidTypeSymbol: PullPrimitiveTypeSymbol = noImpl
        public open var undefinedValueSymbol: PullSymbol = noImpl
        public open var emptyTypeSymbol: PullTypeSymbol = noImpl
        public open var astSymbolMap: Any = noImpl
        public open var astAliasSymbolMap: Any = noImpl
        public open var astCallResolutionDataMap: Any = noImpl
        public open var declSymbolMap: Any = noImpl
        public open var declSignatureSymbolMap: Any = noImpl
        public open var declCache: Any = noImpl
        public open var symbolCache: Any = noImpl
        public open var fileNameToDiagnostics: Any = noImpl
        public open var _binder: Any = noImpl
        public open var _resolver: Any = noImpl
        public open var _topLevelDecls: Any = noImpl
        public open var _fileNames: Any = noImpl
        public open fun getDocument(fileName: String): Document = noImpl
        public open fun lineMap(fileName: String): LineMap = noImpl
        public open fun fileNames(): Array<String> = noImpl
        public open fun bindPrimitiveSymbol<TSymbol : PullSymbol>(decl: Any, newSymbol: Any): Unit = noImpl
        public open fun addPrimitiveTypeSymbol(decl: Any): Unit = noImpl
        public open fun addPrimitiveValueSymbol(decl: Any, `type`: Any): Unit = noImpl
        public open fun resetGlobalSymbols(): Unit = noImpl
        public open fun addDocument(document: Document): Unit = noImpl
        public open fun removeDocument(fileName: String): Unit = noImpl
        public open fun getDeclPathCacheID(declPath: Any, declKind: Any): Unit = noImpl
        public open fun findTopLevelSymbol(name: String, kind: PullElementKind, doNotGoPastThisDecl: PullDecl): PullSymbol = noImpl
        public open fun findTopLevelSymbolInDecl(topLevelDecl: Any, name: Any, kind: Any, doNotGoPastThisDecl: Any): Unit = noImpl
        public open fun findExternalModule(id: String): PullContainerSymbol = noImpl
        public open fun findAmbientExternalModuleInGlobalContext(id: String): PullContainerSymbol = noImpl
        public open fun findDecls(declPath: Array<String>, declKind: PullElementKind): Array<PullDecl> = noImpl
        public open fun findDeclsFromPath(declPath: Array<PullDecl>, declKind: PullElementKind): Array<PullDecl> = noImpl
        public open fun findSymbol(declPath: Array<String>, declType: PullElementKind): PullSymbol = noImpl
        public open fun cacheGlobalSymbol(symbol: PullSymbol, kind: PullElementKind): Unit = noImpl
        public open fun invalidate(oldSettings: ImmutableCompilationSettings? = null, newSettings: ImmutableCompilationSettings? = null): Unit = noImpl
        public open fun settingsChangeAffectsSyntax(before: Any, after: Any): Unit = noImpl
        public open fun setSymbolForAST(ast: AST, symbol: PullSymbol): Unit = noImpl
        public open fun getSymbolForAST(ast: AST): PullSymbol = noImpl
        public open fun setAliasSymbolForAST(ast: AST, symbol: PullTypeAliasSymbol): Unit = noImpl
        public open fun getAliasSymbolForAST(ast: AST): PullTypeAliasSymbol = noImpl
        public open fun getCallResolutionDataForAST(ast: AST): PullAdditionalCallResolutionData = noImpl
        public open fun setCallResolutionDataForAST(ast: AST, callResolutionData: PullAdditionalCallResolutionData): Unit = noImpl
        public open fun setSymbolForDecl(decl: PullDecl, symbol: PullSymbol): Unit = noImpl
        public open fun getSymbolForDecl(decl: PullDecl): PullSymbol = noImpl
        public open fun setSignatureSymbolForDecl(decl: PullDecl, signatureSymbol: PullSignatureSymbol): Unit = noImpl
        public open fun getSignatureSymbolForDecl(decl: PullDecl): PullSignatureSymbol = noImpl
        public open fun addDiagnostic(diagnostic: Diagnostic): Unit = noImpl
        public open fun getDiagnostics(fileName: String): Array<Diagnostic> = noImpl
        public open fun getBinder(): PullSymbolBinder = noImpl
        public open fun getResolver(): PullTypeResolver = noImpl
        public open fun addSyntheticIndexSignature(containingDecl: PullDecl, containingSymbol: PullTypeSymbol, ast: AST, indexParamName: String, indexParamType: PullTypeSymbol, returnType: PullTypeSymbol): Unit = noImpl
        public open fun getDeclForAST(ast: AST): PullDecl = noImpl
        public open fun getEnclosingDecl(ast: AST): PullDecl = noImpl
        public open fun setDeclForAST(ast: AST, decl: PullDecl): Unit = noImpl
        public open fun getASTForDecl(decl: PullDecl): AST = noImpl
        public open fun setASTForDecl(decl: PullDecl, ast: AST): Unit = noImpl
        public open fun topLevelDecl(fileName: String): PullDecl = noImpl
        public open fun topLevelDecls(): Array<PullDecl> = noImpl
        public open fun addDiagnosticFromAST(ast: AST, diagnosticKey: String, _arguments: Array<Any>? = null, additionalLocations: Array<Location>? = null): Unit = noImpl
        public open fun diagnosticFromAST(ast: AST, diagnosticKey: String, _arguments: Array<Any>? = null, additionalLocations: Array<Location>? = null): Diagnostic = noImpl
        public open fun locationFromAST(ast: AST): Location = noImpl
        public open fun duplicateIdentifierDiagnosticFromAST(ast: AST, identifier: String, additionalLocationAST: AST): Diagnostic = noImpl
        public open fun addDuplicateIdentifierDiagnosticFromAST(ast: AST, identifier: String, additionalLocationAST: AST): Unit = noImpl
    }
    module
    public object DeclarationCreator {
        public fun create(document: Document, semanticInfoChain: SemanticInfoChain, compilationSettings: ImmutableCompilationSettings): PullDecl = noImpl
    }
    public open class PullSymbolBinder(semanticInfoChain: SemanticInfoChain) {
        public open var semanticInfoChain: Any = noImpl
        public open var declsBeingBound: Any = noImpl
        public open var inBindingOtherDeclsWalker: Any = noImpl
        public open fun getParent(decl: Any, returnInstanceType: Any? = null): Unit = noImpl
        public open fun findDeclsInContext(startingDecl: Any, declKind: Any, searchGlobally: Any): Unit = noImpl
        public open fun getExistingSymbol(decl: Any, searchKind: Any, parent: Any): Unit = noImpl
        public open fun checkThatExportsMatch(decl: Any, prevSymbol: Any, reportError: Any? = null): Unit = noImpl
        public open fun getIndexForInsertingSignatureAtEndOfEnclosingDeclInSignatureList(signature: Any, currentSignatures: Any): Unit = noImpl
        public open fun bindEnumDeclarationToPullSymbol(enumContainerDecl: Any): Unit = noImpl
        public open fun bindEnumIndexerDeclsToPullSymbols(enumContainerSymbol: Any): Unit = noImpl
        public open fun findExistingVariableSymbolForModuleValueDecl(decl: Any): Unit = noImpl
        public open fun bindModuleDeclarationToPullSymbol(moduleContainerDecl: Any): Unit = noImpl
        public open fun bindImportDeclaration(importDeclaration: Any): Unit = noImpl
        public open fun ensurePriorDeclarationsAreBound(container: Any, currentDecl: Any): Unit = noImpl
        public open fun bindClassDeclarationToPullSymbol(classDecl: Any): Unit = noImpl
        public open fun bindInterfaceDeclarationToPullSymbol(interfaceDecl: Any): Unit = noImpl
        public open fun bindObjectTypeDeclarationToPullSymbol(objectDecl: Any): Unit = noImpl
        public open fun bindConstructorTypeDeclarationToPullSymbol(constructorTypeDeclaration: Any): Unit = noImpl
        public open fun bindVariableDeclarationToPullSymbol(variableDeclaration: Any): Unit = noImpl
        public open fun bindCatchVariableToPullSymbol(variableDeclaration: Any): Unit = noImpl
        public open fun bindEnumMemberDeclarationToPullSymbol(propertyDeclaration: Any): Unit = noImpl
        public open fun bindPropertyDeclarationToPullSymbol(propertyDeclaration: Any): Unit = noImpl
        public open fun bindParameterSymbols(functionDeclaration: Any, parameterList: Any, funcType: Any, signatureSymbol: Any): Unit = noImpl
        public open fun bindFunctionDeclarationToPullSymbol(functionDeclaration: Any): Unit = noImpl
        public open fun bindFunctionExpressionToPullSymbol(functionExpressionDeclaration: Any): Unit = noImpl
        public open fun bindFunctionTypeDeclarationToPullSymbol(functionTypeDeclaration: Any): Unit = noImpl
        public open fun bindMethodDeclarationToPullSymbol(methodDeclaration: Any): Unit = noImpl
        public open fun bindStaticPrototypePropertyOfClass(classAST: Any, classTypeSymbol: Any, constructorTypeSymbol: Any): Unit = noImpl
        public open fun bindConstructorDeclarationToPullSymbol(constructorDeclaration: Any): Unit = noImpl
        public open fun bindConstructSignatureDeclarationToPullSymbol(constructSignatureDeclaration: Any): Unit = noImpl
        public open fun bindCallSignatureDeclarationToPullSymbol(callSignatureDeclaration: Any): Unit = noImpl
        public open fun bindIndexSignatureDeclarationToPullSymbol(indexSignatureDeclaration: Any): Unit = noImpl
        public open fun bindGetAccessorDeclarationToPullSymbol(getAccessorDeclaration: Any): Unit = noImpl
        public open fun bindSetAccessorDeclarationToPullSymbol(setAccessorDeclaration: Any): Unit = noImpl
        public open fun getDeclsToBind(decl: Any): Unit = noImpl
        public open fun shouldBindDeclaration(decl: Any): Unit = noImpl
        public open fun bindDeclToPullSymbol(decl: PullDecl): Unit = noImpl
        public open fun bindAllDeclsToPullSymbol(askedDecl: Any): Unit = noImpl
        public open fun bindSingleDeclToPullSymbol(decl: Any): Unit = noImpl
    }
    module
    public object PullHelpers {
        public fun diagnosticFromDecl(decl: PullDecl, diagnosticKey: String, _arguments: Array<Any>? = null, additionalLocations: Array<Location>? = null): Diagnostic = noImpl
        public fun resolveDeclaredSymbolToUseType(symbol: PullSymbol): Unit = noImpl
        public trait SignatureInfoForFuncDecl {
            public var signature: PullSignatureSymbol
            public var allSignatures: Array<PullSignatureSymbol>
        }
        public fun getSignatureForFuncDecl(functionDecl: PullDecl): `T$10` = noImpl
        public fun getAccessorSymbol(getterOrSetter: AST, semanticInfoChain: SemanticInfoChain): PullAccessorSymbol = noImpl
        public fun getGetterAndSetterFunction(funcDecl: AST, semanticInfoChain: SemanticInfoChain): `T$11` = noImpl
        public fun symbolIsEnum(source: PullSymbol): Boolean = noImpl
        public fun symbolIsModule(symbol: PullSymbol): Boolean = noImpl
        public fun isNameNumeric(name: String): Boolean = noImpl
        public fun typeSymbolsAreIdentical(a: PullTypeSymbol, b: PullTypeSymbol): Boolean = noImpl
        public fun getRootType(`type`: PullTypeSymbol): PullTypeSymbol = noImpl
        public fun isSymbolLocal(symbol: PullSymbol): Boolean = noImpl
        public fun isExportedSymbolInClodule(symbol: PullSymbol): Boolean = noImpl
        public fun isSymbolDeclaredInScopeChain(symbol: PullSymbol, scopeSymbol: PullSymbol): Boolean = noImpl
        public trait PullTypeSymbolStructureWalker {
            public fun memberSymbolWalk(memberSymbol: PullSymbol): Boolean
            public fun callSignatureWalk(signatureSymbol: PullSignatureSymbol): Boolean
            public fun constructSignatureWalk(signatureSymbol: PullSignatureSymbol): Boolean
            public fun indexSignatureWalk(signatureSymbol: PullSignatureSymbol): Boolean
            public fun signatureParameterWalk(parameterSymbol: PullSymbol): Boolean
            public fun signatureReturnTypeWalk(returnType: PullTypeSymbol): Boolean
        }
        public fun walkPullTypeSymbolStructure(typeSymbol: PullTypeSymbol, walker: PullTypeSymbolStructureWalker): Unit = noImpl
        public open class OtherPullDeclsWalker {
            public open var currentlyWalkingOtherDecls: Any = noImpl
            public open fun walkOtherPullDecls(currentDecl: PullDecl, otherDecls: Array<PullDecl>, callBack: (otherDecl: PullDecl) -> Unit): Unit = noImpl
        }
    }
    public open class WrapsTypeParameterCache {
        public open var _wrapsTypeParameterCache: Any = noImpl
        public open fun getWrapsTypeParameter(typeParameterArgumentMap: TypeArgumentMap): Number = noImpl
        public open fun setWrapsTypeParameter(typeParameterArgumentMap: TypeArgumentMap, wrappingTypeParameterID: Number): Unit = noImpl
    }
    module
    public object PullInstantiationHelpers {
        public open class MutableTypeArgumentMap(typeParameterArgumentMap: TypeArgumentMap) {
            public open var typeParameterArgumentMap: TypeArgumentMap = noImpl
            public open var createdDuplicateTypeArgumentMap: Boolean = noImpl
            public open fun ensureTypeArgumentCopy(): Unit = noImpl
        }
        public fun instantiateTypeArgument(resolver: PullTypeResolver, symbol: InstantiableSymbol, mutableTypeParameterMap: MutableTypeArgumentMap): Unit = noImpl
        public fun cleanUpTypeArgumentMap(symbol: InstantiableSymbol, mutableTypeArgumentMap: MutableTypeArgumentMap): Unit = noImpl
        public fun getAllowedToReferenceTypeParametersFromDecl(decl: PullDecl): Array<PullTypeParameterSymbol> = noImpl
        public fun createTypeParameterArgumentMap(typeParameters: Array<PullTypeParameterSymbol>, typeArguments: Array<PullTypeSymbol>): TypeArgumentMap = noImpl
        public fun updateTypeParameterArgumentMap(typeParameters: Array<PullTypeParameterSymbol>, typeArguments: Array<PullTypeSymbol>, typeParameterArgumentMap: TypeArgumentMap): TypeArgumentMap = noImpl
        public fun updateMutableTypeParameterArgumentMap(typeParameters: Array<PullTypeParameterSymbol>, typeArguments: Array<PullTypeSymbol>, mutableMap: MutableTypeArgumentMap): Unit = noImpl
        public fun twoTypesAreInstantiationsOfSameNamedGenericType(type1: PullTypeSymbol, type2: PullTypeSymbol): Boolean = noImpl
    }
    public var fileResolutionTime: Number = noImpl
    public var fileResolutionIOTime: Number = noImpl
    public var fileResolutionScanImportsTime: Number = noImpl
    public var fileResolutionImportFileSearchTime: Number = noImpl
    public var fileResolutionGetDefaultLibraryTime: Number = noImpl
    public var sourceCharactersCompiled: Number = noImpl
    public var syntaxTreeParseTime: Number = noImpl
    public var syntaxDiagnosticsTime: Number = noImpl
    public var astTranslationTime: Number = noImpl
    public var typeCheckTime: Number = noImpl
    public var compilerResolvePathTime: Number = noImpl
    public var compilerDirectoryNameTime: Number = noImpl
    public var compilerDirectoryExistsTime: Number = noImpl
    public var compilerFileExistsTime: Number = noImpl
    public var emitTime: Number = noImpl
    public var emitWriteFileTime: Number = noImpl
    public var declarationEmitTime: Number = noImpl
    public var declarationEmitIsExternallyVisibleTime: Number = noImpl
    public var declarationEmitTypeSignatureTime: Number = noImpl
    public var declarationEmitGetBoundDeclTypeTime: Number = noImpl
    public var declarationEmitIsOverloadedCallSignatureTime: Number = noImpl
    public var declarationEmitFunctionDeclarationGetSymbolTime: Number = noImpl
    public var declarationEmitGetBaseTypeTime: Number = noImpl
    public var declarationEmitGetAccessorFunctionTime: Number = noImpl
    public var declarationEmitGetTypeParameterSymbolTime: Number = noImpl
    public var declarationEmitGetImportDeclarationSymbolTime: Number = noImpl
    public var ioHostResolvePathTime: Number = noImpl
    public var ioHostDirectoryNameTime: Number = noImpl
    public var ioHostCreateDirectoryStructureTime: Number = noImpl
    public var ioHostWriteFileTime: Number = noImpl
    public trait PullSymbolInfo {
        public var symbol: PullSymbol
        public var aliasSymbol: PullTypeAliasSymbol
        public var ast: AST
        public var enclosingScopeSymbol: PullSymbol
    }
    public trait PullCallSymbolInfo {
        public var targetSymbol: PullSymbol
        public var resolvedSignatures: Array<PullSignatureSymbol>
        public var candidateSignature: PullSignatureSymbol
        public var isConstructorCall: Boolean
        public var ast: AST
        public var enclosingScopeSymbol: PullSymbol
    }
    public trait PullVisibleSymbolsInfo {
        public var symbols: Array<PullSymbol>
        public var enclosingScopeSymbol: PullSymbol
    }
    enum class EmitOutputResult
    public open class EmitOutput(emitOutputResult: EmitOutputResult? = null) {
        public open var outputFiles: Array<OutputFile> = noImpl
        public open var emitOutputResult: EmitOutputResult = noImpl
    }
    public open class OutputFile(name: String, writeByteOrderMark: Boolean, text: String, fileType: OutputFileType, sourceMapEntries: Array<SourceMapEntry>? = null) {
        public open var name: String = noImpl
        public open var writeByteOrderMark: Boolean = noImpl
        public open var text: String = noImpl
        public open var fileType: OutputFileType = noImpl
        public open var sourceMapEntries: Array<SourceMapEntry> = noImpl
    }
    public open class CompileResult {
        public open var diagnostics: Array<Diagnostic> = noImpl
        public open var outputFiles: Array<OutputFile> = noImpl
        public class object {
            public fun fromDiagnostics(diagnostics: Array<Diagnostic>): CompileResult = noImpl
            public fun fromOutputFiles(outputFiles: Array<OutputFile>): CompileResult = noImpl
        }
    }
    public open class TypeScriptCompiler(logger: ILogger? = null, _settings: ImmutableCompilationSettings? = null) {
        public open var logger: ILogger = noImpl
        public open var _settings: Any = noImpl
        public open var semanticInfoChain: Any = noImpl
        public open fun compilationSettings(): ImmutableCompilationSettings = noImpl
        public open fun setCompilationSettings(newSettings: ImmutableCompilationSettings): Unit = noImpl
        public open fun getDocument(fileName: String): Document = noImpl
        public open fun cleanupSemanticCache(): Unit = noImpl
        public open fun addFile(fileName: String, scriptSnapshot: IScriptSnapshot, byteOrderMark: ByteOrderMark, version: Number, isOpen: Boolean, referencedFiles: Array<String>? = null): Unit = noImpl
        public open fun updateFile(fileName: String, scriptSnapshot: IScriptSnapshot, version: Number, isOpen: Boolean, textChangeRange: TextChangeRange): Unit = noImpl
        public open fun removeFile(fileName: String): Unit = noImpl
        public open fun mapOutputFileName(document: Document, emitOptions: EmitOptions, extensionChanger: (fname: String, wholeFileNameReplaced: Boolean) -> String): String = noImpl
        public open fun writeByteOrderMarkForDocument(document: Any): Unit = noImpl
        public open fun _shouldEmit(document: Document): Boolean = noImpl
        public open fun _shouldEmitDeclarations(document: Document): Boolean = noImpl
        public open fun emitDocumentDeclarationsWorker(document: Any, emitOptions: Any, declarationEmitter: Any? = null): Unit = noImpl
        public open fun _emitDocumentDeclarations(document: Document, emitOptions: EmitOptions, onSingleFileEmitComplete: (files: OutputFile) -> Unit, sharedEmitter: DeclarationEmitter): DeclarationEmitter = noImpl
        public open fun emitAllDeclarations(resolvePath: (path: String) -> String): EmitOutput = noImpl
        public open fun emitDeclarations(fileName: String, resolvePath: (path: String) -> String): EmitOutput = noImpl
        public open fun canEmitDeclarations(fileName: String): Boolean = noImpl
        public open fun emitDocumentWorker(document: Any, emitOptions: Any, emitter: Any? = null): Unit = noImpl
        public open fun _emitDocument(document: Document, emitOptions: EmitOptions, onSingleFileEmitComplete: (files: Array<OutputFile>) -> Unit, sharedEmitter: Emitter): Emitter = noImpl
        public open fun emitAll(resolvePath: (path: String) -> String): EmitOutput = noImpl
        public open fun emit(fileName: String, resolvePath: (path: String) -> String): EmitOutput = noImpl
        public open fun compile(resolvePath: (path: String) -> String, continueOnDiagnostics: Boolean? = null): Iterator<CompileResult> = noImpl
        public open fun getSyntacticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
        public open fun getSyntaxTree(fileName: Any): Unit = noImpl
        public open fun getSourceUnit(fileName: Any): Unit = noImpl
        public open fun getSemanticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
        public open fun getCompilerOptionsDiagnostics(resolvePath: (path: String) -> String): Array<Diagnostic> = noImpl
        public open fun resolveAllFiles(): Unit = noImpl
        public open fun getSymbolOfDeclaration(decl: PullDecl): PullSymbol = noImpl
        public open fun extractResolutionContextFromAST(resolver: Any, ast: Any, document: Any, propagateContextualTypes: Any): Unit = noImpl
        public open fun extractResolutionContextForVariable(inContextuallyTypedAssignment: Any, propagateContextualTypes: Any, resolver: Any, resolutionContext: Any, enclosingDecl: Any, assigningAST: Any, init: Any): Unit = noImpl
        public open fun getASTPath(ast: Any): Unit = noImpl
        public open fun pullGetSymbolInformationFromAST(ast: AST, document: Document): PullSymbolInfo = noImpl
        public open fun pullGetCallInformationFromAST(ast: AST, document: Document): PullCallSymbolInfo = noImpl
        public open fun pullGetVisibleMemberSymbolsFromAST(ast: AST, document: Document): PullVisibleSymbolsInfo = noImpl
        public open fun pullGetVisibleDeclsFromAST(ast: AST, document: Document): Array<PullDecl> = noImpl
        public open fun pullGetContextualMembersFromAST(ast: AST, document: Document): PullVisibleSymbolsInfo = noImpl
        public open fun pullGetDeclInformation(decl: PullDecl, ast: AST, document: Document): PullSymbolInfo = noImpl
        public open fun topLevelDeclaration(fileName: String): PullDecl = noImpl
        public open fun getDeclForAST(ast: AST): PullDecl = noImpl
        public open fun fileNames(): Array<String> = noImpl
        public open fun topLevelDecl(fileName: String): PullDecl = noImpl
        public class object {
            public fun mapToDTSFileName(fileName: String, wholeFileNameReplaced: Boolean): String = noImpl
            public fun mapToFileNameExtension(extension: String, fileName: String, wholeFileNameReplaced: Boolean): String = noImpl
            public fun mapToJSFileName(fileName: String, wholeFileNameReplaced: Boolean): String = noImpl
            public fun getLocationText(location: Any, resolvePath: Any): Unit = noImpl
            public fun getFullDiagnosticText(diagnostic: Diagnostic, resolvePath: (path: String) -> String): String = noImpl
        }
    }
    public fun compareDataObjects(dst: Any, src: Any): Boolean = noImpl
    public trait TypeArgumentMap {
        public fun get(n: Number): PullTypeSymbol
        public fun set(n: Number, value: PullTypeSymbol)
    }
    public open class PullTypeReferenceSymbol(referencedTypeSymbol: PullTypeSymbol) : PullTypeSymbol(noImpl, noImpl) {
        public open var referencedTypeSymbol: PullTypeSymbol = noImpl
        override fun isTypeReference(): Boolean = noImpl
        override var isResolved: Boolean = noImpl
        override fun setResolved(): Unit = noImpl
        override fun setUnresolved(): Unit = noImpl
        public open fun invalidate(): Unit = noImpl
        public open fun ensureReferencedTypeIsResolved(): Unit = noImpl
        public open fun getReferencedTypeSymbol(): PullTypeSymbol = noImpl
        override fun _getResolver(): PullTypeResolver = noImpl
        override fun hasMembers(): Boolean = noImpl
        override fun setAssociatedContainerType(`type`: PullTypeSymbol): Unit = noImpl
        override fun getAssociatedContainerType(): PullTypeSymbol = noImpl
        override fun getFunctionSymbol(): PullSymbol = noImpl
        override fun setFunctionSymbol(symbol: PullSymbol): Unit = noImpl
        public open fun addContainedNonMember(nonMember: PullSymbol): Unit = noImpl
        override fun findContainedNonMemberContainer(containerName: String, kind: PullElementKind?): PullTypeSymbol = noImpl
        override fun addMember(memberSymbol: PullSymbol): Unit = noImpl
        override fun addEnclosedMemberType(enclosedType: PullTypeSymbol): Unit = noImpl
        override fun addEnclosedMemberContainer(enclosedContainer: PullTypeSymbol): Unit = noImpl
        override fun addEnclosedNonMember(enclosedNonMember: PullSymbol): Unit = noImpl
        override fun addEnclosedNonMemberType(enclosedNonMemberType: PullTypeSymbol): Unit = noImpl
        override fun addEnclosedNonMemberContainer(enclosedNonMemberContainer: PullTypeSymbol): Unit = noImpl
        override fun addTypeParameter(typeParameter: PullTypeParameterSymbol): Unit = noImpl
        public open fun addConstructorTypeParameter(typeParameter: PullTypeParameterSymbol): Unit = noImpl
        override fun findContainedNonMember(name: String): PullSymbol = noImpl
        override fun findContainedNonMemberType(typeName: String, kind: PullElementKind?): PullTypeSymbol = noImpl
        override fun getMembers(): Array<PullSymbol> = noImpl
        override fun setHasDefaultConstructor(hasOne: Boolean?): Unit = noImpl
        override fun getHasDefaultConstructor(): Boolean = noImpl
        override fun getConstructorMethod(): PullSymbol = noImpl
        override fun setConstructorMethod(constructorMethod: PullSymbol): Unit = noImpl
        override fun getTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        override fun isGeneric(): Boolean = noImpl
        override fun addSpecialization(specializedVersionOfThisType: PullTypeSymbol, substitutingTypes: Array<PullTypeSymbol>): Unit = noImpl
        override fun getSpecialization(substitutingTypes: Array<PullTypeSymbol>): PullTypeSymbol = noImpl
        override fun getKnownSpecializations(): Array<PullTypeSymbol> = noImpl
        override fun getTypeArguments(): Array<PullTypeSymbol> = noImpl
        override fun getTypeArgumentsOrTypeParameters(): Array<PullTypeSymbol> = noImpl
        override fun appendCallSignature(callSignature: PullSignatureSymbol): Unit = noImpl
        override fun insertCallSignatureAtIndex(callSignature: PullSignatureSymbol, index: Number): Unit = noImpl
        override fun appendConstructSignature(callSignature: PullSignatureSymbol): Unit = noImpl
        override fun insertConstructSignatureAtIndex(callSignature: PullSignatureSymbol, index: Number): Unit = noImpl
        override fun addIndexSignature(indexSignature: PullSignatureSymbol): Unit = noImpl
        override fun hasOwnCallSignatures(): Boolean = noImpl
        override fun getCallSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun hasOwnConstructSignatures(): Boolean = noImpl
        override fun getConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun hasOwnIndexSignatures(): Boolean = noImpl
        override fun getIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun addImplementedType(implementedType: PullTypeSymbol): Unit = noImpl
        override fun getImplementedTypes(): Array<PullTypeSymbol> = noImpl
        override fun addExtendedType(extendedType: PullTypeSymbol): Unit = noImpl
        override fun getExtendedTypes(): Array<PullTypeSymbol> = noImpl
        override fun addTypeThatExtendsThisType(`type`: PullTypeSymbol): Unit = noImpl
        override fun getTypesThatExtendThisType(): Array<PullTypeSymbol> = noImpl
        override fun addTypeThatExplicitlyImplementsThisType(`type`: PullTypeSymbol): Unit = noImpl
        override fun getTypesThatExplicitlyImplementThisType(): Array<PullTypeSymbol> = noImpl
        override fun isValidBaseKind(baseType: PullTypeSymbol, isExtendedType: Boolean): Boolean = noImpl
        override fun findMember(name: String, lookInParent: Boolean?): PullSymbol = noImpl
        override fun findNestedType(name: String, kind: PullElementKind?): PullTypeSymbol = noImpl
        override fun findNestedContainer(name: String, kind: PullElementKind?): PullTypeSymbol = noImpl
        override fun getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): Array<PullSymbol> = noImpl
        override fun findTypeParameter(name: String): PullTypeParameterSymbol = noImpl
        override fun hasOnlyOverloadCallSignatures(): Boolean = noImpl
        public class object {
            public fun createTypeReference(`type`: PullTypeSymbol): PullTypeReferenceSymbol = noImpl
        }
    }
    public var nSpecializationsCreated: Number = noImpl
    public var nSpecializedSignaturesCreated: Number = noImpl
    public var nSpecializedTypeParameterCreated: Number = noImpl
    public open class PullInstantiatedTypeReferenceSymbol(referencedTypeSymbol: PullTypeSymbol, _typeParameterArgumentMap: TypeArgumentMap, isInstanceReferenceType: Boolean) : PullTypeReferenceSymbol(noImpl) {
        override var referencedTypeSymbol: PullTypeSymbol = noImpl
        public open var _typeParameterArgumentMap: Any = noImpl
        public open var isInstanceReferenceType: Boolean = noImpl
        public open var _instantiatedMembers: Any = noImpl
        public open var _allInstantiatedMemberNameCache: Any = noImpl
        public open var _instantiatedMemberNameCache: Any = noImpl
        public open var _instantiatedCallSignatures: Any = noImpl
        public open var _instantiatedConstructSignatures: Any = noImpl
        public open var _instantiatedIndexSignatures: Any = noImpl
        public open var _typeArgumentReferences: Any = noImpl
        public open var _instantiatedConstructorMethod: Any = noImpl
        public open var _instantiatedAssociatedContainerType: Any = noImpl
        public open var _isArray: Any = noImpl
        override fun getIsSpecialized(): Boolean = noImpl
        public open var _generativeTypeClassification: Any = noImpl
        override fun getGenerativeTypeClassification(enclosingType: PullTypeSymbol): GenerativeTypeClassification = noImpl
        override fun isArrayNamedTypeReference(): Boolean = noImpl
        override fun getElementType(): PullTypeSymbol = noImpl
        override fun getReferencedTypeSymbol(): PullTypeSymbol = noImpl
        override fun isGeneric(): Boolean = noImpl
        override fun getTypeParameterArgumentMap(): TypeArgumentMap = noImpl
        override fun getTypeArguments(): Array<PullTypeSymbol> = noImpl
        override fun getTypeArgumentsOrTypeParameters(): Array<PullTypeSymbol> = noImpl
        public open fun populateInstantiatedMemberFromReferencedMember(referencedMember: Any): Unit = noImpl
        override fun getMembers(): Array<PullSymbol> = noImpl
        override fun findMember(name: String, lookInParent: Boolean?): PullSymbol = noImpl
        override fun getAllMembers(searchDeclKind: PullElementKind, memberVisiblity: GetAllMembersVisiblity): Array<PullSymbol> = noImpl
        override fun getConstructorMethod(): PullSymbol = noImpl
        override fun getAssociatedContainerType(): PullTypeSymbol = noImpl
        override fun getCallSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getConstructSignatures(): Array<PullSignatureSymbol> = noImpl
        override fun getIndexSignatures(): Array<PullSignatureSymbol> = noImpl
        public class object {
            public fun create(resolver: PullTypeResolver, `type`: PullTypeSymbol, typeParameterArgumentMap: TypeArgumentMap): PullInstantiatedTypeReferenceSymbol = noImpl
        }
    }
    public open class PullInstantiatedSignatureSymbol(rootSignature: PullSignatureSymbol, _typeParameterArgumentMap: TypeArgumentMap) : PullSignatureSymbol(noImpl,noImpl) {
        public open var _typeParameterArgumentMap: Any = noImpl
        override fun getTypeParameterArgumentMap(): TypeArgumentMap = noImpl
        override fun getIsSpecialized(): Boolean = noImpl
        override fun _getResolver(): PullTypeResolver = noImpl
        override fun getTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
        override fun getAllowedToReferenceTypeParameters(): Array<PullTypeParameterSymbol> = noImpl
    }
    public open class PullInstantiatedTypeParameterSymbol(rootTypeParameter: PullTypeSymbol, constraintType: PullTypeSymbol) : PullTypeParameterSymbol(noImpl) {
        override fun _getResolver(): PullTypeResolver = noImpl
    }
    public open class SyntaxTreeToAstVisitor(fileName: String, lineMap: LineMap, compilationSettings: ImmutableCompilationSettings) : ISyntaxVisitor {
        public open var fileName: Any = noImpl
        public open var lineMap: LineMap = noImpl
        public open var compilationSettings: Any = noImpl
        public open var position: Number = noImpl
        public open var previousTokenTrailingComments: Array<Comment> = noImpl
        public open fun movePast(element: ISyntaxElement): Unit = noImpl
        public open fun moveTo(element1: Any, element2: Any): Unit = noImpl
        public open fun setCommentsAndSpan(ast: Any, fullStart: Any, node: Any): Unit = noImpl
        public open fun createTokenSpan(fullStart: Number, element: ISyntaxToken): ASTSpan = noImpl
        public open fun setSpan(span: AST, fullStart: Number, element: ISyntaxElement, firstToken: ISyntaxToken? = null, lastToken: ISyntaxToken? = null): Unit = noImpl
        public open fun setSpanExplicit(span: IASTSpan, start: Number, end: Number): Unit = noImpl
        public open fun visitSyntaxList(node: ISyntaxList): ISyntaxList2 = noImpl
        public open fun visitSeparatedSyntaxList(list: ISeparatedSyntaxList): ISeparatedSyntaxList2 = noImpl
        public open fun convertComment(trivia: Any, commentStartPosition: Any, hasTrailingNewLine: Any): Unit = noImpl
        public open fun convertComments(triviaList: Any, commentStartPosition: Any): Unit = noImpl
        public open fun mergeComments(comments1: Any, comments2: Any): Unit = noImpl
        public open fun convertTokenLeadingComments(token: Any, commentStartPosition: Any): Unit = noImpl
        public open fun convertTokenTrailingComments(token: Any, commentStartPosition: Any): Unit = noImpl
        public open fun convertNodeTrailingComments(node: Any, lastToken: Any, nodeStart: Any): Unit = noImpl
        public open fun visitIdentifier(token: Any): Unit = noImpl
        override fun visitToken(token: ISyntaxToken): IASTToken = noImpl
        public open fun visitTokenWorker(token: ISyntaxToken): IASTToken = noImpl
        override fun visitSourceUnit(node: SourceUnitSyntax): SourceUnit = noImpl
        override fun visitExternalModuleReference(node: ExternalModuleReferenceSyntax): ExternalModuleReference = noImpl
        override fun visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): ModuleNameModuleReference = noImpl
        override fun visitClassDeclaration(node: ClassDeclarationSyntax): ClassDeclaration = noImpl
        public open fun visitModifiers(modifiers: Any): Unit = noImpl
        override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): InterfaceDeclaration = noImpl
        override fun visitHeritageClause(node: HeritageClauseSyntax): HeritageClause = noImpl
        override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): ModuleDeclaration = noImpl
        override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): FunctionDeclaration = noImpl
        override fun visitEnumDeclaration(node: EnumDeclarationSyntax): EnumDeclaration = noImpl
        override fun visitEnumElement(node: EnumElementSyntax): EnumElement = noImpl
        override fun visitImportDeclaration(node: ImportDeclarationSyntax): ImportDeclaration = noImpl
        override fun visitExportAssignment(node: ExportAssignmentSyntax): ExportAssignment = noImpl
        override fun visitVariableStatement(node: VariableStatementSyntax): VariableStatement = noImpl
        override fun visitVariableDeclaration(node: VariableDeclarationSyntax): VariableDeclaration = noImpl
        override fun visitVariableDeclarator(node: VariableDeclaratorSyntax): VariableDeclarator = noImpl
        override fun visitEqualsValueClause(node: EqualsValueClauseSyntax): EqualsValueClause = noImpl
        override fun visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): PrefixUnaryExpression = noImpl
        override fun visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): ArrayLiteralExpression = noImpl
        override fun visitOmittedExpression(node: OmittedExpressionSyntax): OmittedExpression = noImpl
        override fun visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): ParenthesizedExpression = noImpl
        override fun visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): SimpleArrowFunctionExpression = noImpl
        override fun visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): ParenthesizedArrowFunctionExpression = noImpl
        public open fun visitType(`type`: ITypeSyntax): AST = noImpl
        override fun visitTypeQuery(node: TypeQuerySyntax): TypeQuery = noImpl
        override fun visitQualifiedName(node: QualifiedNameSyntax): QualifiedName = noImpl
        override fun visitTypeArgumentList(node: TypeArgumentListSyntax): TypeArgumentList = noImpl
        override fun visitConstructorType(node: ConstructorTypeSyntax): ConstructorType = noImpl
        override fun visitFunctionType(node: FunctionTypeSyntax): FunctionType = noImpl
        override fun visitObjectType(node: ObjectTypeSyntax): ObjectType = noImpl
        override fun visitArrayType(node: ArrayTypeSyntax): ArrayType = noImpl
        override fun visitGenericType(node: GenericTypeSyntax): GenericType = noImpl
        override fun visitTypeAnnotation(node: TypeAnnotationSyntax): TypeAnnotation = noImpl
        override fun visitBlock(node: BlockSyntax): Block = noImpl
        override fun visitParameter(node: ParameterSyntax): Parameter = noImpl
        override fun visitMemberAccessExpression(node: MemberAccessExpressionSyntax): MemberAccessExpression = noImpl
        override fun visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): PostfixUnaryExpression = noImpl
        override fun visitElementAccessExpression(node: ElementAccessExpressionSyntax): ElementAccessExpression = noImpl
        override fun visitInvocationExpression(node: InvocationExpressionSyntax): InvocationExpression = noImpl
        override fun visitArgumentList(node: ArgumentListSyntax): ArgumentList = noImpl
        override fun visitBinaryExpression(node: BinaryExpressionSyntax): BinaryExpression = noImpl
        override fun visitConditionalExpression(node: ConditionalExpressionSyntax): ConditionalExpression = noImpl
        override fun visitConstructSignature(node: ConstructSignatureSyntax): ConstructSignature = noImpl
        override fun visitMethodSignature(node: MethodSignatureSyntax): MethodSignature = noImpl
        override fun visitIndexSignature(node: IndexSignatureSyntax): IndexSignature = noImpl
        override fun visitPropertySignature(node: PropertySignatureSyntax): PropertySignature = noImpl
        override fun visitParameterList(node: ParameterListSyntax): ParameterList = noImpl
        override fun visitCallSignature(node: CallSignatureSyntax): CallSignature = noImpl
        override fun visitTypeParameterList(node: TypeParameterListSyntax): TypeParameterList = noImpl
        override fun visitTypeParameter(node: TypeParameterSyntax): TypeParameter = noImpl
        override fun visitConstraint(node: ConstraintSyntax): Constraint = noImpl
        override fun visitIfStatement(node: IfStatementSyntax): IfStatement = noImpl
        override fun visitElseClause(node: ElseClauseSyntax): ElseClause = noImpl
        override fun visitExpressionStatement(node: ExpressionStatementSyntax): ExpressionStatement = noImpl
        override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): ConstructorDeclaration = noImpl
        override fun visitIndexMemberDeclaration(node: IndexMemberDeclarationSyntax): IndexMemberDeclaration = noImpl
        override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): MemberFunctionDeclaration = noImpl
        override fun visitGetAccessor(node: GetAccessorSyntax): GetAccessor = noImpl
        override fun visitSetAccessor(node: SetAccessorSyntax): SetAccessor = noImpl
        override fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): MemberVariableDeclaration = noImpl
        override fun visitThrowStatement(node: ThrowStatementSyntax): ThrowStatement = noImpl
        override fun visitReturnStatement(node: ReturnStatementSyntax): ReturnStatement = noImpl
        override fun visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): ObjectCreationExpression = noImpl
        override fun visitSwitchStatement(node: SwitchStatementSyntax): SwitchStatement = noImpl
        override fun visitCaseSwitchClause(node: CaseSwitchClauseSyntax): CaseSwitchClause = noImpl
        override fun visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): DefaultSwitchClause = noImpl
        override fun visitBreakStatement(node: BreakStatementSyntax): BreakStatement = noImpl
        override fun visitContinueStatement(node: ContinueStatementSyntax): ContinueStatement = noImpl
        override fun visitForStatement(node: ForStatementSyntax): ForStatement = noImpl
        override fun visitForInStatement(node: ForInStatementSyntax): ForInStatement = noImpl
        override fun visitWhileStatement(node: WhileStatementSyntax): WhileStatement = noImpl
        override fun visitWithStatement(node: WithStatementSyntax): WithStatement = noImpl
        override fun visitCastExpression(node: CastExpressionSyntax): CastExpression = noImpl
        override fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): ObjectLiteralExpression = noImpl
        override fun visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): SimplePropertyAssignment = noImpl
        override fun visitFunctionPropertyAssignment(node: FunctionPropertyAssignmentSyntax): FunctionPropertyAssignment = noImpl
        override fun visitFunctionExpression(node: FunctionExpressionSyntax): FunctionExpression = noImpl
        override fun visitEmptyStatement(node: EmptyStatementSyntax): EmptyStatement = noImpl
        override fun visitTryStatement(node: TryStatementSyntax): TryStatement = noImpl
        override fun visitCatchClause(node: CatchClauseSyntax): CatchClause = noImpl
        override fun visitFinallyClause(node: FinallyClauseSyntax): FinallyClause = noImpl
        override fun visitLabeledStatement(node: LabeledStatementSyntax): LabeledStatement = noImpl
        override fun visitDoStatement(node: DoStatementSyntax): DoStatement = noImpl
        override fun visitTypeOfExpression(node: TypeOfExpressionSyntax): TypeOfExpression = noImpl
        override fun visitDeleteExpression(node: DeleteExpressionSyntax): DeleteExpression = noImpl
        override fun visitVoidExpression(node: VoidExpressionSyntax): VoidExpression = noImpl
        override fun visitDebuggerStatement(node: DebuggerStatementSyntax): DebuggerStatement = noImpl
        public class object {
            public open fun visit(syntaxTree: SyntaxTree, fileName: String, compilationSettings: ImmutableCompilationSettings, incrementalAST: Boolean): SourceUnit = noImpl
        }
    }
    public trait IASTSpan {
        public var _start: Number
        public var _end: Number
        public fun start(): Number
        public fun end(): Number
    }
    public open class ASTSpan(_start: Number, _end: Number) : IASTSpan {
        override var _start: Number = noImpl
        override var _end: Number = noImpl
        override fun start(): Number = noImpl
        override fun end(): Number = noImpl
    }
    public fun structuralEqualsNotIncludingPosition(ast1: AST, ast2: AST): Boolean = noImpl
    public fun structuralEqualsIncludingPosition(ast1: AST, ast2: AST): Boolean = noImpl
    public open class AST : IASTSpan {
        public open var parent: AST = noImpl
        override var _start: Number = noImpl
        override var _end: Number = noImpl
        public open var _trailingTriviaWidth: Number = noImpl
        public open var _astID: Any = noImpl
        public open var _preComments: Any = noImpl
        public open var _postComments: Any = noImpl
        public open fun syntaxID(): Number = noImpl
        override fun start(): Number = noImpl
        override fun end(): Number = noImpl
        public open fun trailingTriviaWidth(): Number = noImpl
        public open fun fileName(): String = noImpl
        public open fun kind(): SyntaxKind = noImpl
        public open fun preComments(): Array<Comment> = noImpl
        public open fun postComments(): Array<Comment> = noImpl
        public open fun setPreComments(comments: Array<Comment>): Unit = noImpl
        public open fun setPostComments(comments: Array<Comment>): Unit = noImpl
        public open fun width(): Number = noImpl
        public open fun structuralEquals(ast: AST, includingPosition: Boolean): Boolean = noImpl
        public open fun isExpression(): Boolean = noImpl
    }
    public trait IASTToken : AST {
        public fun text(): String
        public fun valueText(): String
    }
    public open class ISyntaxList2(_fileName: String, members: Array<AST>) : AST() {
        public open var _fileName: Any = noImpl
        public open var members: Any = noImpl
        public open fun childCount(): Number = noImpl
        public open fun childAt(index: Number): AST = noImpl
        override fun fileName(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        public open fun firstOrDefault(func: (v: AST, index: Number) -> Boolean): AST = noImpl
        public open fun lastOrDefault(func: (v: AST, index: Number) -> Boolean): AST = noImpl
        public open fun any(func: (v: AST) -> Boolean): Boolean = noImpl
        override fun structuralEquals(ast: ISyntaxList2, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ISeparatedSyntaxList2(_fileName: String, members: Array<AST>, _separatorCount: Number) : AST() {
        public open var _fileName: Any = noImpl
        public open var members: Any = noImpl
        public open var _separatorCount: Any = noImpl
        public open fun nonSeparatorCount(): Number = noImpl
        public open fun separatorCount(): Number = noImpl
        public open fun nonSeparatorAt(index: Number): AST = noImpl
        public open fun nonSeparatorIndexOf(ast: AST): Number = noImpl
        override fun fileName(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ISeparatedSyntaxList2, includingPosition: Boolean): Boolean = noImpl
    }
    public open class SourceUnit(moduleElements: ISyntaxList2, endOfFileTokenLeadingComments: Array<Comment>, _fileName: String) : AST() {
        public open var moduleElements: ISyntaxList2 = noImpl
        public open var endOfFileTokenLeadingComments: Array<Comment> = noImpl
        public open var _fileName: Any = noImpl
        override fun fileName(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: SourceUnit, includingPosition: Boolean): Boolean = noImpl
    }
    public open class Identifier(_text: String) : AST(), IASTToken {
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: Identifier, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class LiteralExpression(_nodeType: SyntaxKind, _text: String, _valueText: String) : AST() {
        public open var _nodeType: Any = noImpl
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        public open fun text(): String = noImpl
        public open fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ParenthesizedExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ThisExpression(_text: String, _valueText: String) : AST(), IASTToken {
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ParenthesizedExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class SuperExpression(_text: String, _valueText: String) : AST(), IASTToken {
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ParenthesizedExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class NumericLiteral(_value: Number, _text: String, _valueText: String) : AST(), IASTToken {
        public open var _value: Any = noImpl
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        public open fun value(): Any = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: NumericLiteral, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class RegularExpressionLiteral(_text: String, _valueText: String) : AST(), IASTToken {
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class StringLiteral(_text: String, _valueText: String) : AST(), IASTToken {
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: StringLiteral, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class TypeAnnotation(`type`: AST) : AST() {
        public open var `type`: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class BuiltInType(_nodeType: SyntaxKind, _text: String, _valueText: String) : AST(), IASTToken {
        public open var _nodeType: Any = noImpl
        public open var _text: Any = noImpl
        public open var _valueText: Any = noImpl
        override fun text(): String = noImpl
        override fun valueText(): String = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ExternalModuleReference(stringLiteral: StringLiteral) : AST() {
        public open var stringLiteral: StringLiteral = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ModuleNameModuleReference(moduleName: AST) : AST() {
        public open var moduleName: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ImportDeclaration(modifiers: Array<PullElementFlags>, identifier: Identifier, moduleReference: AST) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var moduleReference: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ImportDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ExportAssignment(identifier: Identifier) : AST() {
        public open var identifier: Identifier = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ExportAssignment, includingPosition: Boolean): Boolean = noImpl
    }
    public open class TypeParameterList(typeParameters: ISeparatedSyntaxList2) : AST() {
        public open var typeParameters: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ClassDeclaration(modifiers: Array<PullElementFlags>, identifier: Identifier, typeParameterList: TypeParameterList, heritageClauses: ISyntaxList2, classElements: ISyntaxList2, closeBraceToken: ASTSpan) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var typeParameterList: TypeParameterList = noImpl
        public open var heritageClauses: ISyntaxList2 = noImpl
        public open var classElements: ISyntaxList2 = noImpl
        public open var closeBraceToken: ASTSpan = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ClassDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class InterfaceDeclaration(modifiers: Array<PullElementFlags>, identifier: Identifier, typeParameterList: TypeParameterList, heritageClauses: ISyntaxList2, body: ObjectType) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var typeParameterList: TypeParameterList = noImpl
        public open var heritageClauses: ISyntaxList2 = noImpl
        public open var body: ObjectType = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: InterfaceDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class HeritageClause(_nodeType: SyntaxKind, typeNames: ISeparatedSyntaxList2) : AST() {
        public open var _nodeType: Any = noImpl
        public open var typeNames: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: HeritageClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ModuleDeclaration(modifiers: Array<PullElementFlags>, name: AST, stringLiteral: StringLiteral, moduleElements: ISyntaxList2, endingToken: ASTSpan) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var name: AST = noImpl
        public open var stringLiteral: StringLiteral = noImpl
        public open var moduleElements: ISyntaxList2 = noImpl
        public open var endingToken: ASTSpan = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ModuleDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class FunctionDeclaration(modifiers: Array<PullElementFlags>, identifier: Identifier, callSignature: CallSignature, block: Block) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: FunctionDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class VariableStatement(modifiers: Array<PullElementFlags>, declaration: VariableDeclaration) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var declaration: VariableDeclaration = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: VariableStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class VariableDeclaration(declarators: ISeparatedSyntaxList2) : AST() {
        public open var declarators: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: VariableDeclaration, includingPosition: Boolean): Boolean = noImpl
    }
    public open class VariableDeclarator(propertyName: IASTToken, typeAnnotation: TypeAnnotation, equalsValueClause: EqualsValueClause) : AST() {
        public open var propertyName: IASTToken = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        public open var equalsValueClause: EqualsValueClause = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class EqualsValueClause(value: AST) : AST() {
        public open var value: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class PrefixUnaryExpression(_nodeType: SyntaxKind, operand: AST) : AST() {
        public open var _nodeType: Any = noImpl
        public open var operand: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: PrefixUnaryExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ArrayLiteralExpression(expressions: ISeparatedSyntaxList2) : AST() {
        public open var expressions: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ArrayLiteralExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class OmittedExpression : AST() {
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CatchClause, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ParenthesizedExpression(openParenTrailingComments: Array<Comment>, expression: AST) : AST() {
        public open var openParenTrailingComments: Array<Comment> = noImpl
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ParenthesizedExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public trait ICallExpression : IASTSpan {
        public var expression: AST
        public var argumentList: ArgumentList
    }
    public open class SimpleArrowFunctionExpression(identifier: Identifier, block: Block, expression: AST) : AST() {
        public open var identifier: Identifier = noImpl
        public open var block: Block = noImpl
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ParenthesizedArrowFunctionExpression(callSignature: CallSignature, block: Block, expression: AST) : AST() {
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class QualifiedName(left: AST, right: Identifier) : AST() {
        public open var left: AST = noImpl
        public open var right: Identifier = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: QualifiedName, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ParameterList(openParenTrailingComments: Array<Comment>, parameters: ISeparatedSyntaxList2) : AST() {
        public open var openParenTrailingComments: Array<Comment> = noImpl
        public open var parameters: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ConstructorType(typeParameterList: TypeParameterList, parameterList: ParameterList, `type`: AST) : AST() {
        public open var typeParameterList: TypeParameterList = noImpl
        public open var parameterList: ParameterList = noImpl
        public open var `type`: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class FunctionType(typeParameterList: TypeParameterList, parameterList: ParameterList, `type`: AST) : AST() {
        public open var typeParameterList: TypeParameterList = noImpl
        public open var parameterList: ParameterList = noImpl
        public open var `type`: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ObjectType(typeMembers: ISeparatedSyntaxList2) : AST() {
        public open var typeMembers: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ObjectType, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ArrayType(`type`: AST) : AST() {
        public open var `type`: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ArrayType, includingPosition: Boolean): Boolean = noImpl
    }
    public open class TypeArgumentList(typeArguments: ISeparatedSyntaxList2) : AST() {
        public open var typeArguments: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class GenericType(name: AST, typeArgumentList: TypeArgumentList) : AST() {
        public open var name: AST = noImpl
        public open var typeArgumentList: TypeArgumentList = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: GenericType, includingPosition: Boolean): Boolean = noImpl
    }
    public open class TypeQuery(name: AST) : AST() {
        public open var name: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: TypeQuery, includingPosition: Boolean): Boolean = noImpl
    }
    public open class Block(statements: ISyntaxList2, closeBraceLeadingComments: Array<Comment>, closeBraceToken: IASTSpan) : AST() {
        public open var statements: ISyntaxList2 = noImpl
        public open var closeBraceLeadingComments: Array<Comment> = noImpl
        public open var closeBraceToken: IASTSpan = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: Block, includingPosition: Boolean): Boolean = noImpl
    }
    public open class Parameter(dotDotDotToken: ASTSpan, modifiers: Array<PullElementFlags>, identifier: Identifier, questionToken: ASTSpan, typeAnnotation: TypeAnnotation, equalsValueClause: EqualsValueClause) : AST() {
        public open var dotDotDotToken: ASTSpan = noImpl
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var questionToken: ASTSpan = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        public open var equalsValueClause: EqualsValueClause = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class MemberAccessExpression(expression: AST, name: Identifier) : AST() {
        public open var expression: AST = noImpl
        public open var name: Identifier = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: MemberAccessExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class PostfixUnaryExpression(_nodeType: SyntaxKind, operand: AST) : AST() {
        public open var _nodeType: Any = noImpl
        public open var operand: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: PostfixUnaryExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ElementAccessExpression(expression: AST, argumentExpression: AST) : AST() {
        public open var expression: AST = noImpl
        public open var argumentExpression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ElementAccessExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class InvocationExpression(expression: AST, argumentList: ArgumentList) : AST(), ICallExpression {
        override var expression: AST = noImpl
        override var argumentList: ArgumentList = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: InvocationExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ArgumentList(typeArgumentList: TypeArgumentList, _arguments: ISeparatedSyntaxList2, closeParenToken: ASTSpan) : AST() {
        public open var typeArgumentList: TypeArgumentList = noImpl
        public open var closeParenToken: ASTSpan = noImpl
        public open var arguments: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class BinaryExpression(_nodeType: SyntaxKind, left: AST, right: AST) : AST() {
        public open var _nodeType: Any = noImpl
        public open var left: AST = noImpl
        public open var right: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: BinaryExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ConditionalExpression(condition: AST, whenTrue: AST, whenFalse: AST) : AST() {
        public open var condition: AST = noImpl
        public open var whenTrue: AST = noImpl
        public open var whenFalse: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ConditionalExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ConstructSignature(callSignature: CallSignature) : AST() {
        public open var callSignature: CallSignature = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class MethodSignature(propertyName: IASTToken, questionToken: ASTSpan, callSignature: CallSignature) : AST() {
        public open var propertyName: IASTToken = noImpl
        public open var questionToken: ASTSpan = noImpl
        public open var callSignature: CallSignature = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class IndexSignature(parameter: Parameter, typeAnnotation: TypeAnnotation) : AST() {
        public open var parameter: Parameter = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class PropertySignature(propertyName: IASTToken, questionToken: ASTSpan, typeAnnotation: TypeAnnotation) : AST() {
        public open var propertyName: IASTToken = noImpl
        public open var questionToken: ASTSpan = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class CallSignature(typeParameterList: TypeParameterList, parameterList: ParameterList, typeAnnotation: TypeAnnotation) : AST() {
        public open var typeParameterList: TypeParameterList = noImpl
        public open var parameterList: ParameterList = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class TypeParameter(identifier: Identifier, constraint: Constraint) : AST() {
        public open var identifier: Identifier = noImpl
        public open var constraint: Constraint = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: TypeParameter, includingPosition: Boolean): Boolean = noImpl
    }
    public open class Constraint(`type`: AST) : AST() {
        public open var `type`: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ElseClause(statement: AST) : AST() {
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ElseClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class IfStatement(condition: AST, statement: AST, elseClause: ElseClause) : AST() {
        public open var condition: AST = noImpl
        public open var statement: AST = noImpl
        public open var elseClause: ElseClause = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: IfStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ExpressionStatement(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ExpressionStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ConstructorDeclaration(callSignature: CallSignature, block: Block) : AST() {
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class MemberFunctionDeclaration(modifiers: Array<PullElementFlags>, propertyName: IASTToken, callSignature: CallSignature, block: Block) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var propertyName: IASTToken = noImpl
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class GetAccessor(modifiers: Array<PullElementFlags>, propertyName: IASTToken, parameterList: ParameterList, typeAnnotation: TypeAnnotation, block: Block) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var propertyName: IASTToken = noImpl
        public open var parameterList: ParameterList = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class SetAccessor(modifiers: Array<PullElementFlags>, propertyName: IASTToken, parameterList: ParameterList, block: Block) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var propertyName: IASTToken = noImpl
        public open var parameterList: ParameterList = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    enum class PullElementFlags
    enum class SyntaxKind

    public open class MemberVariableDeclaration(modifiers: Array<PullElementFlags>, variableDeclarator: VariableDeclarator) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var variableDeclarator: VariableDeclarator = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class IndexMemberDeclaration(indexSignature: IndexSignature) : AST() {
        public open var indexSignature: IndexSignature = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class ThrowStatement(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ThrowStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ReturnStatement(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ReturnStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ObjectCreationExpression(expression: AST, argumentList: ArgumentList) : AST(), ICallExpression {
        override var expression: AST = noImpl
        override var argumentList: ArgumentList = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ObjectCreationExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class SwitchStatement(expression: AST, closeParenToken: ASTSpan, switchClauses: ISyntaxList2) : AST() {
        public open var expression: AST = noImpl
        public open var closeParenToken: ASTSpan = noImpl
        public open var switchClauses: ISyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: SwitchStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class CaseSwitchClause(expression: AST, statements: ISyntaxList2) : AST() {
        public open var expression: AST = noImpl
        public open var statements: ISyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CaseSwitchClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class DefaultSwitchClause(statements: ISyntaxList2) : AST() {
        public open var statements: ISyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: DefaultSwitchClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class BreakStatement(identifier: Identifier) : AST() {
        public open var identifier: Identifier = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: BreakStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ContinueStatement(identifier: Identifier) : AST() {
        public open var identifier: Identifier = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ContinueStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ForStatement(variableDeclaration: VariableDeclaration, initializer: AST, condition: AST, incrementor: AST, statement: AST) : AST() {
        public open var variableDeclaration: VariableDeclaration = noImpl
        public open var initializer: AST = noImpl
        public open var condition: AST = noImpl
        public open var incrementor: AST = noImpl
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ForStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class ForInStatement(variableDeclaration: VariableDeclaration, left: AST, expression: AST, statement: AST) : AST() {
        public open var variableDeclaration: VariableDeclaration = noImpl
        public open var left: AST = noImpl
        public open var expression: AST = noImpl
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ForInStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class WhileStatement(condition: AST, statement: AST) : AST() {
        public open var condition: AST = noImpl
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: WhileStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class WithStatement(condition: AST, statement: AST) : AST() {
        public open var condition: AST = noImpl
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: WithStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class EnumDeclaration(modifiers: Array<PullElementFlags>, identifier: Identifier, enumElements: ISeparatedSyntaxList2) : AST() {
        public open var modifiers: Array<PullElementFlags> = noImpl
        public open var identifier: Identifier = noImpl
        public open var enumElements: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class EnumElement(propertyName: IASTToken, equalsValueClause: EqualsValueClause) : AST() {
        public open var propertyName: IASTToken = noImpl
        public open var equalsValueClause: EqualsValueClause = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class CastExpression(`type`: AST, expression: AST) : AST() {
        public open var `type`: AST = noImpl
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CastExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class ObjectLiteralExpression(propertyAssignments: ISeparatedSyntaxList2) : AST() {
        public open var propertyAssignments: ISeparatedSyntaxList2 = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: ObjectLiteralExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class SimplePropertyAssignment(propertyName: Identifier, expression: AST) : AST() {
        public open var propertyName: Identifier = noImpl
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class FunctionPropertyAssignment(propertyName: Identifier, callSignature: CallSignature, block: Block) : AST() {
        public open var propertyName: Identifier = noImpl
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
    }
    public open class FunctionExpression(identifier: Identifier, callSignature: CallSignature, block: Block) : AST() {
        public open var identifier: Identifier = noImpl
        public open var callSignature: CallSignature = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class EmptyStatement : AST() {
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CatchClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class TryStatement(block: Block, catchClause: CatchClause, finallyClause: FinallyClause) : AST() {
        public open var block: Block = noImpl
        public open var catchClause: CatchClause = noImpl
        public open var finallyClause: FinallyClause = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: TryStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class CatchClause(identifier: Identifier, typeAnnotation: TypeAnnotation, block: Block) : AST() {
        public open var identifier: Identifier = noImpl
        public open var typeAnnotation: TypeAnnotation = noImpl
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CatchClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class FinallyClause(block: Block) : AST() {
        public open var block: Block = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: CatchClause, includingPosition: Boolean): Boolean = noImpl
    }
    public open class LabeledStatement(identifier: Identifier, statement: AST) : AST() {
        public open var identifier: Identifier = noImpl
        public open var statement: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: LabeledStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class DoStatement(statement: AST, whileKeyword: ASTSpan, condition: AST) : AST() {
        public open var statement: AST = noImpl
        public open var whileKeyword: ASTSpan = noImpl
        public open var condition: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: DoStatement, includingPosition: Boolean): Boolean = noImpl
    }
    public open class TypeOfExpression(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: TypeOfExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class DeleteExpression(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: DeleteExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class VoidExpression(expression: AST) : AST() {
        public open var expression: AST = noImpl
        override fun kind(): SyntaxKind = noImpl
        override fun structuralEquals(ast: VoidExpression, includingPosition: Boolean): Boolean = noImpl
        override fun isExpression(): Boolean = noImpl
    }
    public open class DebuggerStatement : AST() {
        override fun kind(): SyntaxKind = noImpl
    }
    public open class Comment(_trivia: ISyntaxTrivia, endsLine: Boolean, _start: Number, _end: Number) {
        public open var _trivia: Any = noImpl
        public open var endsLine: Boolean = noImpl
        public open var _start: Number = noImpl
        public open var _end: Number = noImpl
        public open fun start(): Number = noImpl
        public open fun end(): Number = noImpl
        public open fun fullText(): String = noImpl
        public open fun kind(): SyntaxKind = noImpl
        public open fun structuralEquals(ast: Comment, includingPosition: Boolean): Boolean = noImpl
    }
    module
    public object Services {
        enum class EndOfLineState

        public open class Classifier(host: IClassifierHost) {
            public open var host: IClassifierHost = noImpl
            public open var scanner: Any = noImpl
            public open var characterWindow: Any = noImpl
            public open var diagnostics: Any = noImpl
            public open fun getClassificationsForLine(text: String, lexState: EndOfLineState): ClassificationResult = noImpl
            public open fun processToken(text: Any, offset: Any, token: Any, result: Any): Unit = noImpl
            public open fun processTriviaList(text: Any, offset: Any, triviaList: Any, result: Any): Unit = noImpl
            public open fun addResult(text: Any, offset: Any, result: Any, length: Any, kind: Any): Unit = noImpl
            public open fun classFromKind(kind: Any): Unit = noImpl
        }
        public trait IClassifierHost : ILogger
        public open class ClassificationResult {
            public open var finalLexState: EndOfLineState = noImpl
            public open var entries: Array<ClassificationInfo> = noImpl
        }

        enum class TokenClass

        public open class ClassificationInfo(length: Number, classification: TokenClass) {
            public open var length: Number = noImpl
            public open var classification: TokenClass = noImpl
        }
        public trait ILanguageServicesDiagnostics {
            public fun log(content: String)
        }
        public trait ILanguageServiceHost : ILogger, IReferenceResolverHost {
            public fun getCompilationSettings(): CompilationSettings
            public fun getScriptFileNames(): Array<String>
            public fun getScriptVersion(fileName: String): Number
            public fun getScriptIsOpen(fileName: String): Boolean
            public fun getScriptByteOrderMark(fileName: String): ByteOrderMark
            override fun getScriptSnapshot(fileName: String): IScriptSnapshot
            public fun getDiagnosticsObject(): ILanguageServicesDiagnostics
            public fun getLocalizedDiagnosticMessages(): Any
        }
        public trait ILanguageService {
            public fun refresh()
            public fun cleanupSemanticCache()
            public fun getSyntacticDiagnostics(fileName: String): Array<Diagnostic>
            public fun getSemanticDiagnostics(fileName: String): Array<Diagnostic>
            public fun getCompilerOptionsDiagnostics(): Array<Diagnostic>
            public fun getCompletionsAtPosition(fileName: String, position: Number, isMemberCompletion: Boolean): CompletionInfo
            public fun getCompletionEntryDetails(fileName: String, position: Number, entryName: String): CompletionEntryDetails
            public fun getTypeAtPosition(fileName: String, position: Number): TypeInfo
            public fun getNameOrDottedNameSpan(fileName: String, startPos: Number, endPos: Number): SpanInfo
            public fun getBreakpointStatementAtPosition(fileName: String, position: Number): SpanInfo
            public fun getSignatureAtPosition(fileName: String, position: Number): SignatureInfo
            public fun getDefinitionAtPosition(fileName: String, position: Number): Array<DefinitionInfo>
            public fun getReferencesAtPosition(fileName: String, position: Number): Array<ReferenceEntry>
            public fun getOccurrencesAtPosition(fileName: String, position: Number): Array<ReferenceEntry>
            public fun getImplementorsAtPosition(fileName: String, position: Number): Array<ReferenceEntry>
            public fun getNavigateToItems(searchValue: String): Array<NavigateToItem>
            public fun getScriptLexicalStructure(fileName: String): Array<NavigateToItem>
            public fun getOutliningRegions(fileName: String): Array<TextSpan>
            public fun getBraceMatchingAtPosition(fileName: String, position: Number): Array<TextSpan>
            public fun getIndentationAtPosition(fileName: String, position: Number, options: EditorOptions): Number
            public fun getFormattingEditsForRange(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit>
            public fun getFormattingEditsForDocument(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit>
            public fun getFormattingEditsOnPaste(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit>
            public fun getFormattingEditsAfterKeystroke(fileName: String, position: Number, key: String, options: FormatCodeOptions): Array<TextEdit>
            public fun getEmitOutput(fileName: String): EmitOutput
            public fun getSyntaxTree(fileName: String): SyntaxTree
        }
        public fun logInternalError(logger: ILogger, err: Error): Unit = noImpl
        public open class ReferenceEntry(fileName: String, minChar: Number, limChar: Number, isWriteAccess: Boolean) {
            public open var fileName: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
            public open var isWriteAccess: Boolean = noImpl
        }
        public open class NavigateToItem {
            public open var name: String = noImpl
            public open var kind: String = noImpl
            public open var kindModifiers: String = noImpl
            public open var matchKind: String = noImpl
            public open var fileName: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
            public open var additionalSpans: Array<SpanInfo> = noImpl
            public open var containerName: String = noImpl
            public open var containerKind: String = noImpl
        }
        public open class TextEdit(minChar: Number, limChar: Number, text: String) {
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
            public open var text: String = noImpl
            public class object {
                public fun createInsert(pos: Number, text: String): TextEdit = noImpl
                public fun createDelete(minChar: Number, limChar: Number): TextEdit = noImpl
                public fun createReplace(minChar: Number, limChar: Number, text: String): TextEdit = noImpl
            }
        }
        public open class EditorOptions {
            public open var IndentSize: Number = noImpl
            public open var TabSize: Number = noImpl
            public open var NewLineCharacter: String = noImpl
            public open var ConvertTabsToSpaces: Boolean = noImpl
            public class object {
                public fun clone(objectToClone: EditorOptions): EditorOptions = noImpl
            }
        }
        public open class FormatCodeOptions : EditorOptions() {
            public open var InsertSpaceAfterCommaDelimiter: Boolean = noImpl
            public open var InsertSpaceAfterSemicolonInForStatements: Boolean = noImpl
            public open var InsertSpaceBeforeAndAfterBinaryOperators: Boolean = noImpl
            public open var InsertSpaceAfterKeywordsInControlFlowStatements: Boolean = noImpl
            public open var InsertSpaceAfterFunctionKeywordForAnonymousFunctions: Boolean = noImpl
            public open var InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: Boolean = noImpl
            public open var PlaceOpenBraceOnNewLineForFunctions: Boolean = noImpl
            public open var PlaceOpenBraceOnNewLineForControlBlocks: Boolean = noImpl
            public class object {
                public fun clone(objectToClone: FormatCodeOptions): FormatCodeOptions = noImpl
            }
        }
        public open class DefinitionInfo(fileName: String, minChar: Number, limChar: Number, kind: String, name: String, containerKind: String, containerName: String) {
            public open var fileName: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
            public open var kind: String = noImpl
            public open var name: String = noImpl
            public open var containerKind: String = noImpl
            public open var containerName: String = noImpl
        }
        public open class TypeInfo(memberName: MemberName, docComment: String, fullSymbolName: String, kind: String, minChar: Number, limChar: Number) {
            public open var memberName: MemberName = noImpl
            public open var docComment: String = noImpl
            public open var fullSymbolName: String = noImpl
            public open var kind: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
        }
        public open class SpanInfo(minChar: Number, limChar: Number, text: String? = null) {
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
            public open var text: String = noImpl
        }
        public open class SignatureInfo {
            public open var actual: ActualSignatureInfo = noImpl
            public open var formal: Array<FormalSignatureItemInfo> = noImpl
            public open var activeFormal: Number = noImpl
        }
        public open class FormalSignatureItemInfo {
            public open var signatureInfo: String = noImpl
            public open var typeParameters: Array<FormalTypeParameterInfo> = noImpl
            public open var parameters: Array<FormalParameterInfo> = noImpl
            public open var docComment: String = noImpl
        }
        public open class FormalTypeParameterInfo {
            public open var name: String = noImpl
            public open var docComment: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
        }
        public open class FormalParameterInfo {
            public open var name: String = noImpl
            public open var isVariable: Boolean = noImpl
            public open var docComment: String = noImpl
            public open var minChar: Number = noImpl
            public open var limChar: Number = noImpl
        }
        public open class ActualSignatureInfo {
            public open var parameterMinChar: Number = noImpl
            public open var parameterLimChar: Number = noImpl
            public open var currentParameterIsTypeParameter: Boolean = noImpl
            public open var currentParameter: Number = noImpl
        }
        public open class CompletionInfo {
            public open var maybeInaccurate: Boolean = noImpl
            public open var isMemberCompletion: Boolean = noImpl
            public open var entries: Array<CompletionEntry> = noImpl
        }
        public trait CompletionEntry {
            public var name: String
            public var kind: String
            public var kindModifiers: String
        }
        public trait CompletionEntryDetails {
            public var name: String
            public var kind: String
            public var kindModifiers: String
            public var `type`: String
            public var fullSymbolName: String
            public var docComment: String
        }
        public open class ScriptElementKind {
            public class object {
                public var unknown: String = noImpl
                public var keyword: String = noImpl
                public var scriptElement: String = noImpl
                public var moduleElement: String = noImpl
                public var classElement: String = noImpl
                public var interfaceElement: String = noImpl
                public var enumElement: String = noImpl
                public var variableElement: String = noImpl
                public var localVariableElement: String = noImpl
                public var functionElement: String = noImpl
                public var localFunctionElement: String = noImpl
                public var memberFunctionElement: String = noImpl
                public var memberGetAccessorElement: String = noImpl
                public var memberSetAccessorElement: String = noImpl
                public var memberVariableElement: String = noImpl
                public var constructorImplementationElement: String = noImpl
                public var callSignatureElement: String = noImpl
                public var indexSignatureElement: String = noImpl
                public var constructSignatureElement: String = noImpl
                public var parameterElement: String = noImpl
                public var typeParameterElement: String = noImpl
                public var primitiveType: String = noImpl
            }
        }
        public open class ScriptElementKindModifier {
            public class object {
                public var none: String = noImpl
                public var publicMemberModifier: String = noImpl
                public var privateMemberModifier: String = noImpl
                public var exportedModifier: String = noImpl
                public var ambientModifier: String = noImpl
                public var staticModifier: String = noImpl
            }
        }
        public open class MatchKind {
            public class object {
                public var none: String = noImpl
                public var exact: String = noImpl
                public var subString: String = noImpl
                public var prefix: String = noImpl
            }
        }
        public open class DiagnosticCategory {
            public class object {
                public var none: String = noImpl
                public var error: String = noImpl
                public var warning: String = noImpl
                public var message: String = noImpl
            }
        }
        module
        public object Formatting {
            public trait ITextSnapshot {
                public fun getText(span: TextSpan): String
                public fun getLineNumberFromPosition(position: Number): Number
                public fun getLineFromPosition(position: Number): ITextSnapshotLine
                public fun getLineFromLineNumber(lineNumber: Number): ITextSnapshotLine
            }
            public open class TextSnapshot(snapshot: ISimpleText) : ITextSnapshot {
                public open var snapshot: Any = noImpl
                public open var lines: Any = noImpl
                override fun getText(span: TextSpan): String = noImpl
                override fun getLineNumberFromPosition(position: Number): Number = noImpl
                override fun getLineFromPosition(position: Number): ITextSnapshotLine = noImpl
                override fun getLineFromLineNumber(lineNumber: Number): ITextSnapshotLine = noImpl
                public open fun getLineFromLineNumberWorker(lineNumber: Any): Unit = noImpl
            }
            public trait ITextSnapshotLine {
                public fun snapshot(): ITextSnapshot
                public fun start(): SnapshotPoint
                public fun startPosition(): Number
                public fun end(): SnapshotPoint
                public fun endPosition(): Number
                public fun endIncludingLineBreak(): SnapshotPoint
                public fun endIncludingLineBreakPosition(): Number
                public fun length(): Number
                public fun lineNumber(): Number
                public fun getText(): String
            }
            public open class TextSnapshotLine(_snapshot: ITextSnapshot, _lineNumber: Number, _start: Number, _end: Number, _lineBreak: String) : ITextSnapshotLine {
                public open var _snapshot: Any = noImpl
                public open var _lineNumber: Any = noImpl
                public open var _start: Any = noImpl
                public open var _end: Any = noImpl
                public open var _lineBreak: Any = noImpl
                override fun snapshot(): ITextSnapshot = noImpl
                override fun start(): SnapshotPoint = noImpl
                override fun startPosition(): Number = noImpl
                override fun end(): SnapshotPoint = noImpl
                override fun endPosition(): Number = noImpl
                override fun endIncludingLineBreak(): SnapshotPoint = noImpl
                override fun endIncludingLineBreakPosition(): Number = noImpl
                override fun length(): Number = noImpl
                override fun lineNumber(): Number = noImpl
                override fun getText(): String = noImpl
            }
            public open class SnapshotPoint(snapshot: ITextSnapshot, position: Number) {
                public open var snapshot: ITextSnapshot = noImpl
                public open var position: Number = noImpl
                public open fun getContainingLine(): ITextSnapshotLine = noImpl
                public open fun add(offset: Number): SnapshotPoint = noImpl
            }

            enum class FormattingRequestKind

            public open class FormattingContext(snapshot: ITextSnapshot, formattingRequestKind: FormattingRequestKind) {
                public open var snapshot: Any = noImpl
                public open var formattingRequestKind: FormattingRequestKind = noImpl
                public open var currentTokenSpan: TokenSpan = noImpl
                public open var nextTokenSpan: TokenSpan = noImpl
                public open var contextNode: IndentationNodeContext = noImpl
                public open var currentTokenParent: IndentationNodeContext = noImpl
                public open var nextTokenParent: IndentationNodeContext = noImpl
                public open var contextNodeAllOnSameLine: Any = noImpl
                public open var nextNodeAllOnSameLine: Any = noImpl
                public open var tokensAreOnSameLine: Any = noImpl
                public open var contextNodeBlockIsOnOneLine: Any = noImpl
                public open var nextNodeBlockIsOnOneLine: Any = noImpl
                public open fun updateContext(currentTokenSpan: TokenSpan, currentTokenParent: IndentationNodeContext, nextTokenSpan: TokenSpan, nextTokenParent: IndentationNodeContext, commonParent: IndentationNodeContext): Unit = noImpl
                public open fun ContextNodeAllOnSameLine(): Boolean = noImpl
                public open fun NextNodeAllOnSameLine(): Boolean = noImpl
                public open fun TokensAreOnSameLine(): Boolean = noImpl
                public open fun ContextNodeBlockIsOnOneLine(): Boolean = noImpl
                public open fun NextNodeBlockIsOnOneLine(): Boolean = noImpl
                public open fun NodeIsOnOneLine(node: IndentationNodeContext): Boolean = noImpl
                public open fun BlockIsOnOneLine(node: IndentationNodeContext): Boolean = noImpl
            }
            public open class FormattingManager(syntaxTree: SyntaxTree, snapshot: ITextSnapshot, rulesProvider: RulesProvider, editorOptions: EditorOptions) {
                public open var syntaxTree: Any = noImpl
                public open var snapshot: Any = noImpl
                public open var rulesProvider: Any = noImpl
                public open var options: Any = noImpl
                public open fun formatSelection(minChar: Number, limChar: Number): Array<TextEdit> = noImpl
                public open fun formatDocument(minChar: Number, limChar: Number): Array<TextEdit> = noImpl
                public open fun formatOnPaste(minChar: Number, limChar: Number): Array<TextEdit> = noImpl
                public open fun formatOnSemicolon(caretPosition: Number): Array<TextEdit> = noImpl
                public open fun formatOnClosingCurlyBrace(caretPosition: Number): Array<TextEdit> = noImpl
                public open fun formatOnEnter(caretPosition: Number): Array<TextEdit> = noImpl
                public open fun formatSpan(span: Any, formattingRequestKind: Any): Unit = noImpl
            }

            enum class RuleFlags

            public open class Rule(Descriptor: RuleDescriptor, Operation: RuleOperation, Flag: RuleFlags? = null) {
                public open var Descriptor: RuleDescriptor = noImpl
                public open var Operation: RuleOperation = noImpl
                public open var Flag: RuleFlags = noImpl
                override fun toString(): String = noImpl
            }
            public open class RuleDescriptor(LeftTokenRange: Shared.TokenRange, RightTokenRange: Shared.TokenRange) {
                public open var LeftTokenRange: Shared.TokenRange = noImpl
                public open var RightTokenRange: Shared.TokenRange = noImpl
                override fun toString(): String = noImpl
                public class object {
                    public fun create1(left: SyntaxKind, right: SyntaxKind): RuleDescriptor = noImpl
                    public fun create2(left: Shared.TokenRange, right: SyntaxKind): RuleDescriptor = noImpl
                    public fun create3(left: SyntaxKind, right: Shared.TokenRange): RuleDescriptor = noImpl
                    public fun create4(left: Shared.TokenRange, right: Shared.TokenRange): RuleDescriptor = noImpl
                }
            }

            enum class RuleAction

            public open class RuleOperation {
                public open var Context: RuleOperationContext = noImpl
                public open var Action: RuleAction = noImpl
                override fun toString(): String = noImpl
                public class object {
                    public fun create1(action: RuleAction): RuleOperation = noImpl
                    public fun create2(context: RuleOperationContext, action: RuleAction): RuleOperation = noImpl
                }
            }
            public open class RuleOperationContext(vararg funcs: `T$12`) {
                public open var customContextChecks: Any = noImpl
                public open fun IsAny(): Boolean = noImpl
                public open fun InContext(context: FormattingContext): Boolean = noImpl
                public class object {
                    public var Any: RuleOperationContext = noImpl
                }
            }
            public open class Rules {
                public open fun getRuleName(rule: Rule): Any = noImpl
                public open fun get(name: String): Any = noImpl
                public open fun set(name: String, value: Any): Unit = noImpl
                public open var IgnoreBeforeComment: Rule = noImpl
                public open var IgnoreAfterLineComment: Rule = noImpl
                public open var NoSpaceBeforeSemicolon: Rule = noImpl
                public open var NoSpaceBeforeColon: Rule = noImpl
                public open var NoSpaceBeforeQMark: Rule = noImpl
                public open var SpaceAfterColon: Rule = noImpl
                public open var SpaceAfterQMark: Rule = noImpl
                public open var SpaceAfterSemicolon: Rule = noImpl
                public open var SpaceAfterCloseBrace: Rule = noImpl
                public open var SpaceBetweenCloseBraceAndElse: Rule = noImpl
                public open var SpaceBetweenCloseBraceAndWhile: Rule = noImpl
                public open var NoSpaceAfterCloseBrace: Rule = noImpl
                public open var NoSpaceBeforeDot: Rule = noImpl
                public open var NoSpaceAfterDot: Rule = noImpl
                public open var NoSpaceBeforeOpenBracket: Rule = noImpl
                public open var NoSpaceAfterOpenBracket: Rule = noImpl
                public open var NoSpaceBeforeCloseBracket: Rule = noImpl
                public open var NoSpaceAfterCloseBracket: Rule = noImpl
                public open var SpaceAfterOpenBrace: Rule = noImpl
                public open var SpaceBeforeCloseBrace: Rule = noImpl
                public open var NoSpaceBetweenEmptyBraceBrackets: Rule = noImpl
                public open var NewLineAfterOpenBraceInBlockContext: Rule = noImpl
                public open var NewLineBeforeCloseBraceInBlockContext: Rule = noImpl
                public open var NoSpaceAfterUnaryPrefixOperator: Rule = noImpl
                public open var NoSpaceAfterUnaryPreincrementOperator: Rule = noImpl
                public open var NoSpaceAfterUnaryPredecrementOperator: Rule = noImpl
                public open var NoSpaceBeforeUnaryPostincrementOperator: Rule = noImpl
                public open var NoSpaceBeforeUnaryPostdecrementOperator: Rule = noImpl
                public open var SpaceAfterPostincrementWhenFollowedByAdd: Rule = noImpl
                public open var SpaceAfterAddWhenFollowedByUnaryPlus: Rule = noImpl
                public open var SpaceAfterAddWhenFollowedByPreincrement: Rule = noImpl
                public open var SpaceAfterPostdecrementWhenFollowedBySubtract: Rule = noImpl
                public open var SpaceAfterSubtractWhenFollowedByUnaryMinus: Rule = noImpl
                public open var SpaceAfterSubtractWhenFollowedByPredecrement: Rule = noImpl
                public open var NoSpaceBeforeComma: Rule = noImpl
                public open var SpaceAfterCertainKeywords: Rule = noImpl
                public open var NoSpaceBeforeOpenParenInFuncCall: Rule = noImpl
                public open var SpaceAfterFunctionInFuncDecl: Rule = noImpl
                public open var NoSpaceBeforeOpenParenInFuncDecl: Rule = noImpl
                public open var SpaceAfterVoidOperator: Rule = noImpl
                public open var NoSpaceBetweenReturnAndSemicolon: Rule = noImpl
                public open var SpaceBetweenStatements: Rule = noImpl
                public open var SpaceAfterTryFinally: Rule = noImpl
                public open var SpaceAfterGetSetInMember: Rule = noImpl
                public open var SpaceBeforeBinaryKeywordOperator: Rule = noImpl
                public open var SpaceAfterBinaryKeywordOperator: Rule = noImpl
                public open var NoSpaceAfterConstructor: Rule = noImpl
                public open var NoSpaceAfterModuleImport: Rule = noImpl
                public open var SpaceAfterCertainTypeScriptKeywords: Rule = noImpl
                public open var SpaceBeforeCertainTypeScriptKeywords: Rule = noImpl
                public open var SpaceAfterModuleName: Rule = noImpl
                public open var SpaceAfterArrow: Rule = noImpl
                public open var NoSpaceAfterEllipsis: Rule = noImpl
                public open var NoSpaceAfterOptionalParameters: Rule = noImpl
                public open var NoSpaceBeforeOpenAngularBracket: Rule = noImpl
                public open var NoSpaceBetweenCloseParenAndAngularBracket: Rule = noImpl
                public open var NoSpaceAfterOpenAngularBracket: Rule = noImpl
                public open var NoSpaceBeforeCloseAngularBracket: Rule = noImpl
                public open var NoSpaceAfterCloseAngularBracket: Rule = noImpl
                public open var NoSpaceBetweenEmptyInterfaceBraceBrackets: Rule = noImpl
                public open var HighPriorityCommonRules: Array<Rule> = noImpl
                public open var LowPriorityCommonRules: Array<Rule> = noImpl
                public open var SpaceAfterComma: Rule = noImpl
                public open var NoSpaceAfterComma: Rule = noImpl
                public open var SpaceBeforeBinaryOperator: Rule = noImpl
                public open var SpaceAfterBinaryOperator: Rule = noImpl
                public open var NoSpaceBeforeBinaryOperator: Rule = noImpl
                public open var NoSpaceAfterBinaryOperator: Rule = noImpl
                public open var SpaceAfterKeywordInControl: Rule = noImpl
                public open var NoSpaceAfterKeywordInControl: Rule = noImpl
                public open var FunctionOpenBraceLeftTokenRange: Shared.TokenRange = noImpl
                public open var SpaceBeforeOpenBraceInFunction: Rule = noImpl
                public open var NewLineBeforeOpenBraceInFunction: Rule = noImpl
                public open var TypeScriptOpenBraceLeftTokenRange: Shared.TokenRange = noImpl
                public open var SpaceBeforeOpenBraceInTypeScriptDeclWithBlock: Rule = noImpl
                public open var NewLineBeforeOpenBraceInTypeScriptDeclWithBlock: Rule = noImpl
                public open var ControlOpenBraceLeftTokenRange: Shared.TokenRange = noImpl
                public open var SpaceBeforeOpenBraceInControl: Rule = noImpl
                public open var NewLineBeforeOpenBraceInControl: Rule = noImpl
                public open var SpaceAfterSemicolonInFor: Rule = noImpl
                public open var NoSpaceAfterSemicolonInFor: Rule = noImpl
                public open var SpaceAfterOpenParen: Rule = noImpl
                public open var SpaceBeforeCloseParen: Rule = noImpl
                public open var NoSpaceBetweenParens: Rule = noImpl
                public open var NoSpaceAfterOpenParen: Rule = noImpl
                public open var NoSpaceBeforeCloseParen: Rule = noImpl
                public open var SpaceAfterAnonymousFunctionKeyword: Rule = noImpl
                public open var NoSpaceAfterAnonymousFunctionKeyword: Rule = noImpl
                public class object {
                    public fun IsForContext(context: FormattingContext): Boolean = noImpl
                    public fun IsNotForContext(context: FormattingContext): Boolean = noImpl
                    public fun IsBinaryOpContext(context: FormattingContext): Boolean = noImpl
                    public fun IsNotBinaryOpContext(context: FormattingContext): Boolean = noImpl
                    public fun IsSameLineTokenOrBeforeMultilineBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsBeforeMultilineBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsMultilineBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsSingleLineBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsBeforeBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun NodeIsBlockContext(node: IndentationNodeContext): Boolean = noImpl
                    public fun IsFunctionDeclContext(context: FormattingContext): Boolean = noImpl
                    public fun IsTypeScriptDeclWithBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun NodeIsTypeScriptDeclWithBlockContext(node: IndentationNodeContext): Boolean = noImpl
                    public fun IsAfterCodeBlockContext(context: FormattingContext): Boolean = noImpl
                    public fun IsControlDeclContext(context: FormattingContext): Boolean = noImpl
                    public fun IsObjectContext(context: FormattingContext): Boolean = noImpl
                    public fun IsFunctionCallContext(context: FormattingContext): Boolean = noImpl
                    public fun IsNewContext(context: FormattingContext): Boolean = noImpl
                    public fun IsFunctionCallOrNewContext(context: FormattingContext): Boolean = noImpl
                    public fun IsSameLineTokenContext(context: FormattingContext): Boolean = noImpl
                    public fun IsNotFormatOnEnter(context: FormattingContext): Boolean = noImpl
                    public fun IsModuleDeclContext(context: FormattingContext): Boolean = noImpl
                    public fun IsObjectTypeContext(context: FormattingContext): Boolean = noImpl
                    public fun IsTypeArgumentOrParameter(tokenKind: SyntaxKind, parentKind: SyntaxKind): Boolean = noImpl
                    public fun IsTypeArgumentOrParameterContext(context: FormattingContext): Boolean = noImpl
                    public fun IsVoidOpContext(context: FormattingContext): Boolean = noImpl
                }
            }
            public open class RulesMap {
                public open var map: Array<RulesBucket> = noImpl
                public open var mapRowLength: Number = noImpl
                public open fun Initialize(rules: Array<Rule>): Array<RulesBucket> = noImpl
                public open fun FillRules(rules: Array<Rule>, rulesBucketConstructionStateList: Array<RulesBucketConstructionState>): Unit = noImpl
                public open fun GetRuleBucketIndex(row: Any, column: Any): Unit = noImpl
                public open fun FillRule(rule: Any, rulesBucketConstructionStateList: Any): Unit = noImpl
                public open fun GetRule(context: FormattingContext): Rule = noImpl
                public class object {
                    public fun create(rules: Array<Rule>): RulesMap = noImpl
                }
            }

            enum class RulesPosition

            public open class RulesBucketConstructionState {
                public open var rulesInsertionIndexBitmap: Any = noImpl
                public open fun GetInsertionIndex(maskPosition: RulesPosition): Number = noImpl
                public open fun IncreaseInsertionIndex(maskPosition: RulesPosition): Unit = noImpl
            }
            public open class RulesBucket {
                public open var rules: Any = noImpl
                public open fun Rules(): Array<Rule> = noImpl
                public open fun AddRule(rule: Rule, specificTokens: Boolean, constructionState: Array<RulesBucketConstructionState>, rulesBucketIndex: Number): Unit = noImpl
            }
            public open class RulesProvider(logger: ILogger) {
                public open var logger: Any = noImpl
                public open var globalRules: Any = noImpl
                public open var options: Any = noImpl
                public open var activeRules: Any = noImpl
                public open var rulesMap: Any = noImpl
                public open fun getRuleName(rule: Rule): String = noImpl
                public open fun getRuleByName(name: String): Rule = noImpl
                public open fun getRulesMap(): RulesMap = noImpl
                public open fun ensureUpToDate(options: FormatCodeOptions): Unit = noImpl
                public open fun createActiveRules(options: Any): Unit = noImpl
            }
            public open class TextEditInfo(position: Number, length: Number, replaceWith: String) {
                public open var position: Number = noImpl
                public open var length: Number = noImpl
                public open var replaceWith: String = noImpl
                override fun toString(): String = noImpl
            }
            module
            public object Shared {
                public trait ITokenAccess {
                    public fun GetTokens(): Array<SyntaxKind>
                    public fun Contains(token: SyntaxKind): Boolean
                }
                public open class TokenRangeAccess(from: SyntaxKind, to: SyntaxKind, except: Array<SyntaxKind>) : ITokenAccess {
                    public open var tokens: Any = noImpl
                    override fun GetTokens(): Array<SyntaxKind> = noImpl
                    override fun Contains(token: SyntaxKind): Boolean = noImpl
                    override fun toString(): String = noImpl
                }
                public open class TokenValuesAccess(tks: Array<SyntaxKind>) : ITokenAccess {
                    public open var tokens: Any = noImpl
                    override fun GetTokens(): Array<SyntaxKind> = noImpl
                    override fun Contains(token: SyntaxKind): Boolean = noImpl
                }
                public open class TokenSingleValueAccess(token: SyntaxKind) : ITokenAccess {
                    public open var token: SyntaxKind = noImpl
                    override fun GetTokens(): Array<SyntaxKind> = noImpl
                    override fun Contains(tokenValue: SyntaxKind): Boolean = noImpl
                    override fun toString(): String = noImpl
                }
                public open class TokenAllAccess : ITokenAccess {
                    override fun GetTokens(): Array<SyntaxKind> = noImpl
                    override fun Contains(tokenValue: SyntaxKind): Boolean = noImpl
                    override fun toString(): String = noImpl
                }
                public open class TokenRange(tokenAccess: ITokenAccess) {
                    public open var tokenAccess: ITokenAccess = noImpl
                    public open fun GetTokens(): Array<SyntaxKind> = noImpl
                    public open fun Contains(token: SyntaxKind): Boolean = noImpl
                    override fun toString(): String = noImpl
                    public class object {
                        public fun FromToken(token: SyntaxKind): TokenRange = noImpl
                        public fun FromTokens(tokens: Array<SyntaxKind>): TokenRange = noImpl
                        public fun FromRange(f: SyntaxKind, to: SyntaxKind, except: Array<SyntaxKind>? = null): TokenRange = noImpl
                        public fun AllTokens(): TokenRange = noImpl
                        public var Any: TokenRange = noImpl
                        public var AnyIncludingMultilineComments: TokenRange = noImpl
                        public var Keywords: TokenRange = noImpl
                        public var Operators: TokenRange = noImpl
                        public var BinaryOperators: TokenRange = noImpl
                        public var BinaryKeywordOperators: TokenRange = noImpl
                        public var ReservedKeywords: TokenRange = noImpl
                        public var UnaryPrefixOperators: TokenRange = noImpl
                        public var UnaryPrefixExpressions: TokenRange = noImpl
                        public var UnaryPreincrementExpressions: TokenRange = noImpl
                        public var UnaryPostincrementExpressions: TokenRange = noImpl
                        public var UnaryPredecrementExpressions: TokenRange = noImpl
                        public var UnaryPostdecrementExpressions: TokenRange = noImpl
                        public var Comments: TokenRange = noImpl
                        public var TypeNames: TokenRange = noImpl
                    }
                }
            }
            public open class TokenSpan(kind: SyntaxKind, start: Number, length: Number) : TextSpan(noImpl,noImpl) {
                public open var _kind: Any = noImpl
                public open fun kind(): SyntaxKind = noImpl
            }
            public open class IndentationNodeContext(parent: IndentationNodeContext, node: SyntaxNode, fullStart: Number, indentationAmount: Number, childIndentationAmountDelta: Number) {
                public open var _node: Any = noImpl
                public open var _parent: Any = noImpl
                public open var _fullStart: Any = noImpl
                public open var _indentationAmount: Any = noImpl
                public open var _childIndentationAmountDelta: Any = noImpl
                public open var _depth: Any = noImpl
                public open var _hasSkippedOrMissingTokenChild: Any = noImpl
                public open fun parent(): IndentationNodeContext = noImpl
                public open fun node(): SyntaxNode = noImpl
                public open fun fullStart(): Number = noImpl
                public open fun fullWidth(): Number = noImpl
                public open fun start(): Number = noImpl
                public open fun end(): Number = noImpl
                public open fun indentationAmount(): Number = noImpl
                public open fun childIndentationAmountDelta(): Number = noImpl
                public open fun depth(): Number = noImpl
                public open fun kind(): SyntaxKind = noImpl
                public open fun hasSkippedOrMissingTokenChild(): Boolean = noImpl
                public open fun clone(pool: IndentationNodeContextPool): IndentationNodeContext = noImpl
                public open fun update(parent: IndentationNodeContext, node: SyntaxNode, fullStart: Number, indentationAmount: Number, childIndentationAmountDelta: Number): Unit = noImpl
            }
            public open class IndentationNodeContextPool {
                public open var nodes: Any = noImpl
                public open fun getNode(parent: IndentationNodeContext, node: SyntaxNode, fullStart: Number, indentationLevel: Number, childIndentationLevelDelta: Number): IndentationNodeContext = noImpl
                public open fun releaseNode(node: IndentationNodeContext, recursive: Boolean? = null): Unit = noImpl
            }
            public open class IndentationTrackingWalker(textSpan: TextSpan, sourceUnit: SourceUnitSyntax, snapshot: ITextSnapshot, indentFirstToken: Boolean, options: FormattingOptions) : SyntaxWalker() {
                public open var options: FormattingOptions = noImpl
                public open var _position: Any = noImpl
                public open var _parent: Any = noImpl
                public open var _textSpan: Any = noImpl
                public open var _snapshot: Any = noImpl
                public open var _lastTriviaWasNewLine: Any = noImpl
                public open var _indentationNodeContextPool: Any = noImpl
                public open fun position(): Number = noImpl
                public open fun parent(): IndentationNodeContext = noImpl
                public open fun textSpan(): TextSpan = noImpl
                public open fun snapshot(): ITextSnapshot = noImpl
                public open fun indentationNodeContextPool(): IndentationNodeContextPool = noImpl
                public open fun forceIndentNextToken(tokenStart: Number): Unit = noImpl
                public open fun forceSkipIndentingNextToken(tokenStart: Number): Unit = noImpl
                public open fun indentToken(token: ISyntaxToken, indentationAmount: Number, commentIndentationAmount: Number): Unit = noImpl
                public open fun visitTokenInSpan(token: ISyntaxToken): Unit = noImpl
                override fun visitToken(token: ISyntaxToken): Unit = noImpl
                override fun visitNode(node: SyntaxNode): Unit = noImpl
                public open fun getTokenIndentationAmount(token: Any): Unit = noImpl
                public open fun getCommentIndentationAmount(token: Any): Unit = noImpl
                public open fun getNodeIndentation(node: Any, newLineInsertedByFormatting: Any? = null): Unit = noImpl
                public open fun shouldIndentBlockInParent(parent: Any): Unit = noImpl
                public open fun forceRecomputeIndentationOfParent(tokenStart: Any, newLineAdded: Any): Unit = noImpl
            }
            public open class MultipleTokenIndenter(textSpan: TextSpan, sourceUnit: SourceUnitSyntax, snapshot: ITextSnapshot, indentFirstToken: Boolean, options: FormattingOptions) : IndentationTrackingWalker(noImpl,noImpl,noImpl,noImpl,noImpl) {
                public open var _edits: Any = noImpl
                override fun indentToken(token: ISyntaxToken, indentationAmount: Number, commentIndentationAmount: Number): Unit = noImpl
                public open fun edits(): Array<TextEditInfo> = noImpl
                public open fun recordEdit(position: Number, length: Number, replaceWith: String): Unit = noImpl
                public open fun recordIndentationEditsForToken(token: Any, indentationString: Any, commentIndentationString: Any): Unit = noImpl
                public open fun recordIndentationEditsForSingleLineOrSkippedText(trivia: Any, fullStart: Any, indentationString: Any): Unit = noImpl
                public open fun recordIndentationEditsForWhitespace(trivia: Any, fullStart: Any, indentationString: Any): Unit = noImpl
                public open fun recordIndentationEditsForMultiLineComment(trivia: Any, fullStart: Any, indentationString: Any, leadingWhiteSpace: Any, firstLineAlreadyIndented: Any): Unit = noImpl
                public open fun recordIndentationEditsForSegment(segment: Any, fullStart: Any, indentationColumns: Any, whiteSpaceColumnsInFirstSegment: Any): Unit = noImpl
            }
            public open class SingleTokenIndenter(indentationPosition: Number, sourceUnit: SourceUnitSyntax, snapshot: ITextSnapshot, indentFirstToken: Boolean, options: FormattingOptions) : IndentationTrackingWalker(noImpl,noImpl,noImpl,noImpl,noImpl) {
                public open var indentationAmount: Any = noImpl
                public open var indentationPosition: Any = noImpl
                override fun indentToken(token: ISyntaxToken, indentationAmount: Number, commentIndentationAmount: Number): Unit = noImpl
                public class object {
                    public fun getIndentationAmount(position: Number, sourceUnit: SourceUnitSyntax, snapshot: ITextSnapshot, options: FormattingOptions): Number = noImpl
                }
            }
            public open class Formatter(textSpan: TextSpan, sourceUnit: SourceUnitSyntax, indentFirstToken: Boolean, options: FormattingOptions, snapshot: ITextSnapshot, rulesProvider: RulesProvider, formattingRequestKind: FormattingRequestKind) : MultipleTokenIndenter(noImpl,noImpl,noImpl,noImpl,noImpl) {
                public open var previousTokenSpan: Any = noImpl
                public open var previousTokenParent: Any = noImpl
                public open var scriptHasErrors: Any = noImpl
                public open var rulesProvider: Any = noImpl
                public open var formattingRequestKind: Any = noImpl
                public open var formattingContext: Any = noImpl
                override fun visitTokenInSpan(token: ISyntaxToken): Unit = noImpl
                public open fun processToken(token: Any): Unit = noImpl
                public open fun processTrivia(triviaList: Any, fullStart: Any): Unit = noImpl
                public open fun findCommonParents(parent1: Any, parent2: Any): Unit = noImpl
                public open fun formatPair(t1: Any, t1Parent: Any, t2: Any, t2Parent: Any): Unit = noImpl
                public open fun getLineNumber(span: Any): Unit = noImpl
                public open fun trimWhitespaceInLineRange(startLine: Any, endLine: Any, token: Any? = null): Unit = noImpl
                public open fun trimWhitespace(line: Any, token: Any? = null): Unit = noImpl
                public open fun RecordRuleEdits(rule: Any, t1: Any, t2: Any): Unit = noImpl
                public class object {
                    public fun getEdits(textSpan: TextSpan, sourceUnit: SourceUnitSyntax, options: FormattingOptions, indentFirstToken: Boolean, snapshot: ITextSnapshot, rulesProvider: RulesProvider, formattingRequestKind: FormattingRequestKind): Array<TextEditInfo> = noImpl
                }
            }
        }
        public trait ICoreServicesHost {
            public var logger: ILogger
        }
        public open class CoreServices(host: ICoreServicesHost) {
            public open var host: ICoreServicesHost = noImpl
            public open fun getPreProcessedFileInfo(fileName: String, sourceText: IScriptSnapshot): IPreProcessedFileInfo = noImpl
            public open fun getDefaultCompilationSettings(): CompilationSettings = noImpl
            public open fun dumpMemory(): String = noImpl
            public open fun getMemoryInfo(): Array<Any> = noImpl
            public open fun collectGarbage(): Unit = noImpl
        }
        public open class SyntaxTreeCache(_host: ILanguageServiceHost) {
            public open var _host: Any = noImpl
            public open var _hostCache: Any = noImpl
            public open var _currentFileName: Any = noImpl
            public open var _currentFileVersion: Any = noImpl
            public open var _currentFileSyntaxTree: Any = noImpl
            public open var _currentFileScriptSnapshot: Any = noImpl
            public open fun getCurrentFileSyntaxTree(fileName: String): SyntaxTree = noImpl
            public open fun createSyntaxTree(fileName: Any, scriptSnapshot: Any): Unit = noImpl
            public open fun updateSyntaxTree(fileName: Any, scriptSnapshot: Any, previousSyntaxTree: Any, previousFileVersion: Any): Unit = noImpl
            public open fun ensureInvariants(fileName: Any, editRange: Any, incrementalTree: Any, oldScriptSnapshot: Any, newScriptSnapshot: Any): Unit = noImpl
        }
        public open class LanguageServiceCompiler(host: ILanguageServiceHost) {
            public open var host: Any = noImpl
            public open var logger: Any = noImpl
            public open var compiler: Any = noImpl
            public open var hostCache: Any = noImpl
            public open fun synchronizeHostData(): Unit = noImpl
            public open fun synchronizeHostDataWorker(): Unit = noImpl
            public open fun tryUpdateFile(compiler: Any, fileName: Any): Unit = noImpl
            public open fun getScriptSnapshot(fileName: String): IScriptSnapshot = noImpl
            public open fun getCachedHostFileName(fileName: String): String = noImpl
            public open fun getCachedTopLevelDeclaration(fileName: String): PullDecl = noImpl
            public open fun compilationSettings(): ImmutableCompilationSettings = noImpl
            public open fun fileNames(): Array<String> = noImpl
            public open fun cleanupSemanticCache(): Unit = noImpl
            public open fun getDocument(fileName: String): Document = noImpl
            public open fun getSyntacticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
            public open fun getSemanticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
            public open fun getCompilerOptionsDiagnostics(resolvePath: (path: String) -> String): Array<Diagnostic> = noImpl
            public open fun getSymbolInformationFromAST(ast: AST, document: Document): PullSymbolInfo = noImpl
            public open fun getCallInformationFromAST(ast: AST, document: Document): PullCallSymbolInfo = noImpl
            public open fun getVisibleMemberSymbolsFromAST(ast: AST, document: Document): PullVisibleSymbolsInfo = noImpl
            public open fun getVisibleDeclsFromAST(ast: AST, document: Document): Array<PullDecl> = noImpl
            public open fun getContextualMembersFromAST(ast: AST, document: Document): PullVisibleSymbolsInfo = noImpl
            public open fun pullGetDeclInformation(decl: PullDecl, ast: AST, document: Document): PullSymbolInfo = noImpl
            public open fun topLevelDeclaration(fileName: String): PullDecl = noImpl
            public open fun getDeclForAST(ast: AST): PullDecl = noImpl
            public open fun emit(fileName: String, resolvePath: (path: String) -> String): EmitOutput = noImpl
            public open fun emitDeclarations(fileName: String, resolvePath: (path: String) -> String): EmitOutput = noImpl
            public open fun canEmitDeclarations(fileName: String): Boolean = noImpl
        }
        public open class CompletionHelpers {
            public class object {
                public fun getSpan(ast: Any): Unit = noImpl
                public fun symbolDeclarationIntersectsPosition(symbol: Any, fileName: Any, position: Any): Unit = noImpl
                public fun filterContextualMembersList(contextualMemberSymbols: Array<PullSymbol>, existingMembers: PullVisibleSymbolsInfo, fileName: String, position: Number): Array<PullSymbol> = noImpl
                public fun isCompletionListBlocker(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
                public fun getContainingObjectLiteralApplicableForCompletion(sourceUnit: SourceUnitSyntax, position: Number): PositionedElement = noImpl
                public fun isIdentifierDefinitionLocation(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
                public fun getNonIdentifierCompleteTokenOnLeft(sourceUnit: SourceUnitSyntax, position: Number): PositionedToken = noImpl
                public fun isRightOfIllegalDot(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
                public fun getValidCompletionEntryDisplayName(displayName: String): String = noImpl
            }
        }
        public open class KeywordCompletions {
            public class object {
                public var keywords: Any = noImpl
                public var keywordCompletions: Any = noImpl
                public fun getKeywordCompltions(): Array<ResolvedCompletionEntry> = noImpl
            }
        }
        public trait IPartiallyWrittenTypeArgumentListInformation {
            public var genericIdentifer: PositionedToken
            public var lessThanToken: PositionedToken
            public var argumentIndex: Number
        }
        public open class SignatureInfoHelpers {
            public class object {
                public fun isInPartiallyWrittenTypeArgumentList(syntaxTree: SyntaxTree, position: Number): IPartiallyWrittenTypeArgumentListInformation = noImpl
                public fun getSignatureInfoFromSignatureSymbol(symbol: PullSymbol, signatures: Array<PullSignatureSymbol>, enclosingScopeSymbol: PullSymbol, compilerState: LanguageServiceCompiler): Array<FormalSignatureItemInfo> = noImpl
                public fun getSignatureInfoFromGenericSymbol(symbol: PullSymbol, enclosingScopeSymbol: PullSymbol, compilerState: LanguageServiceCompiler): Array<FormalSignatureItemInfo> = noImpl
                public fun getActualSignatureInfoFromCallExpression(ast: ICallExpression, caretPosition: Number, typeParameterInformation: IPartiallyWrittenTypeArgumentListInformation): ActualSignatureInfo = noImpl
                public fun getActualSignatureInfoFromPartiallyWritenGenericExpression(caretPosition: Number, typeParameterInformation: IPartiallyWrittenTypeArgumentListInformation): ActualSignatureInfo = noImpl
                public fun isSignatureHelpBlocker(sourceUnit: SourceUnitSyntax, position: Number): Boolean = noImpl
                public fun isTargetOfObjectCreationExpression(positionedToken: PositionedToken): Boolean = noImpl
                public fun moveBackUpTillMatchingTokenKind(token: Any, tokenKind: Any, matchingTokenKind: Any): Unit = noImpl
            }
        }
        public trait CachedCompletionEntryDetails : CompletionEntryDetails {
            public fun isResolved(): Boolean
        }
        public open class ResolvedCompletionEntry(name: String, kind: String, kindModifiers: String, `type`: String, fullSymbolName: String, docComment: String) : CachedCompletionEntryDetails {
            override var name: String = noImpl
            override var kind: String = noImpl
            override var kindModifiers: String = noImpl
            override var `type`: String = noImpl
            override var fullSymbolName: String = noImpl
            override var docComment: String = noImpl
            override fun isResolved(): Boolean = noImpl
        }
        public open class DeclReferenceCompletionEntry(name: String, kind: String, kindModifiers: String, decl: PullDecl) : CachedCompletionEntryDetails {
            override var name: String = noImpl
            override var kind: String = noImpl
            override var kindModifiers: String = noImpl
            public open var decl: PullDecl = noImpl
            override var `type`: String = noImpl
            override var fullSymbolName: String = noImpl
            override var docComment: String = noImpl
            public open var hasBeenResolved: Any = noImpl
            override fun isResolved(): Boolean = noImpl
            public open fun resolve(`type`: String, fullSymbolName: String, docComments: String): Unit = noImpl
        }
        public open class CompletionSession(fileName: String, position: Number, entries: IdentiferNameHashTable<CachedCompletionEntryDetails>) {
            public open var fileName: String = noImpl
            public open var position: Number = noImpl
            public open var entries: IdentiferNameHashTable<CachedCompletionEntryDetails> = noImpl
        }
        public open class LanguageService(host: ILanguageServiceHost) : ILanguageService {
            public open var host: ILanguageServiceHost = noImpl
            public open var logger: Any = noImpl
            public open var compiler: Any = noImpl
            public open var _syntaxTreeCache: Any = noImpl
            public open var formattingRulesProvider: Any = noImpl
            public open var activeCompletionSession: Any = noImpl
            override fun cleanupSemanticCache(): Unit = noImpl
            override fun refresh(): Unit = noImpl
            public open fun getSymbolInfoAtPosition(fileName: Any, pos: Any, requireName: Any): Unit = noImpl
            override fun getReferencesAtPosition(fileName: String, pos: Number): Array<ReferenceEntry> = noImpl
            public open fun getSymbolScopeAST(symbol: Any, ast: Any): Unit = noImpl
            override fun getOccurrencesAtPosition(fileName: String, pos: Number): Array<ReferenceEntry> = noImpl
            public open fun getSingleNodeReferenceAtPosition(fileName: Any, position: Any): Unit = noImpl
            override fun getImplementorsAtPosition(fileName: String, pos: Number): Array<ReferenceEntry> = noImpl
            public open fun getOverrides(container: PullTypeSymbol, memberSym: PullSymbol): Array<PullTypeSymbol> = noImpl
            public open fun getImplementorsInFile(fileName: Any, symbol: Any): Unit = noImpl
            public open fun getReferencesInFile(fileName: Any, symbol: Any, containingASTOpt: Any): Unit = noImpl
            public open fun isWriteAccess(current: Any): Unit = noImpl
            public open fun isLetterOrDigit(char: Any): Unit = noImpl
            public open fun getPossibleSymbolReferencePositions(fileName: Any, symbolName: Any): Unit = noImpl
            override fun getSignatureAtPosition(fileName: String, position: Number): SignatureInfo = noImpl
            public open fun getTypeParameterSignatureFromPartiallyWrittenExpression(document: Any, position: Any, genericTypeArgumentListInfo: Any): Unit = noImpl
            override fun getDefinitionAtPosition(fileName: String, position: Number): Array<DefinitionInfo> = noImpl
            public open fun addDeclarations(symbolKind: Any, symbolName: Any, containerKind: Any, containerName: Any, declarations: Any, result: Any): Unit = noImpl
            public open fun addDeclaration(symbolKind: Any, symbolName: Any, containerKind: Any, containerName: Any, declaration: Any, result: Any): Unit = noImpl
            public open fun tryAddDefinition(symbolKind: Any, symbolName: Any, containerKind: Any, containerName: Any, declarations: Any, result: Any): Unit = noImpl
            public open fun tryAddSignatures(symbolKind: Any, symbolName: Any, containerKind: Any, containerName: Any, declarations: Any, result: Any): Unit = noImpl
            public open fun tryAddConstructor(symbolKind: Any, symbolName: Any, containerKind: Any, containerName: Any, declarations: Any, result: Any): Unit = noImpl
            override fun getNavigateToItems(searchValue: String): Array<NavigateToItem> = noImpl
            public open fun hasAnyUpperCaseCharacter(s: Any): Unit = noImpl
            public open fun findSearchValueInPullDecl(fileName: Any, declarations: Any, results: Any, searchTerms: Any, parentName: Any? = null, parentkindName: Any? = null): Unit = noImpl
            public open fun getScriptElementKindModifiersFromDecl(decl: Any): Unit = noImpl
            public open fun isContainerDeclaration(declaration: Any): Unit = noImpl
            public open fun shouldIncludeDeclarationInNavigationItems(declaration: Any): Unit = noImpl
            override fun getSyntacticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
            override fun getSemanticDiagnostics(fileName: String): Array<Diagnostic> = noImpl
            public open fun _getHostSpecificDiagnosticWithFileName(diagnostic: Any): Unit = noImpl
            override fun getCompilerOptionsDiagnostics(): Array<Diagnostic> = noImpl
            public open fun _getHostFileName(fileName: Any): Unit = noImpl
            override fun getEmitOutput(fileName: String): EmitOutput = noImpl
            public open fun getAllSyntacticDiagnostics(): Unit = noImpl
            public open fun getAllSemanticDiagnostics(): Unit = noImpl
            public open fun containErrors(diagnostics: Any): Unit = noImpl
            public open fun getFullNameOfSymbol(symbol: Any, enclosingScopeSymbol: Any): Unit = noImpl
            public open fun getTypeInfoEligiblePath(fileName: Any, position: Any, isConstructorValidPosition: Any): Unit = noImpl
            override fun getTypeAtPosition(fileName: String, position: Number): TypeInfo = noImpl
            override fun getCompletionsAtPosition(fileName: String, position: Number, isMemberCompletion: Boolean): CompletionInfo = noImpl
            public open fun getCompletionEntriesFromSymbols(symbolInfo: Any, result: Any): Unit = noImpl
            public open fun getCompletionEntriesFromDecls(decls: Any, result: Any): Unit = noImpl
            public open fun getResolvedCompletionEntryDetailsFromSymbol(symbol: Any, enclosingScopeSymbol: Any): Unit = noImpl
            public open fun getCompletionEntriesForKeywords(keywords: Any, result: Any): Unit = noImpl
            override fun getCompletionEntryDetails(fileName: String, position: Number, entryName: String): CompletionEntryDetails = noImpl
            public open fun tryFindDeclFromPreviousCompilerVersion(invalidatedDecl: Any): Unit = noImpl
            public open fun getModuleOrEnumKind(symbol: Any): Unit = noImpl
            public open fun mapPullElementKind(kind: Any, symbol: Any? = null, useConstructorAsClass: Any? = null, varIsFunction: Any? = null, functionIsConstructor: Any? = null): Unit = noImpl
            public open fun getScriptElementKindModifiers(symbol: Any): Unit = noImpl
            public open fun getScriptElementKindModifiersFromFlags(flags: Any): Unit = noImpl
            override fun getNameOrDottedNameSpan(fileName: String, startPos: Number, endPos: Number): SpanInfo = noImpl
            override fun getBreakpointStatementAtPosition(fileName: String, pos: Number): SpanInfo = noImpl
            override fun getFormattingEditsForRange(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit> = noImpl
            override fun getFormattingEditsForDocument(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit> = noImpl
            override fun getFormattingEditsOnPaste(fileName: String, minChar: Number, limChar: Number, options: FormatCodeOptions): Array<TextEdit> = noImpl
            override fun getFormattingEditsAfterKeystroke(fileName: String, position: Number, key: String, options: FormatCodeOptions): Array<TextEdit> = noImpl
            public open fun getFormattingManager(fileName: Any, options: Any): Unit = noImpl
            override fun getOutliningRegions(fileName: String): Array<TextSpan> = noImpl
            override fun getIndentationAtPosition(fileName: String, position: Number, editorOptions: EditorOptions): Number = noImpl
            override fun getBraceMatchingAtPosition(fileName: String, position: Number): Array<TextSpan> = noImpl
            override fun getScriptLexicalStructure(fileName: String): Array<NavigateToItem> = noImpl
            override fun getSyntaxTree(fileName: String): SyntaxTree = noImpl
        }
        public open class FindReferenceHelpers {
            public class object {
                public fun compareSymbolsForLexicalIdentity(firstSymbol: PullSymbol, secondSymbol: PullSymbol): Boolean = noImpl
                public fun checkSymbolsForDeclarationEquality(firstSymbol: Any, secondSymbol: Any): Unit = noImpl
                public fun declarationsAreSameOrParents(firstDecl: Any, secondDecl: Any): Unit = noImpl
            }
        }
        public trait IScriptSnapshotShim {
            public fun getText(start: Number, end: Number): String
            public fun getLength(): Number
            public fun getLineStartPositions(): String
            public fun getTextChangeRangeSinceVersion(scriptVersion: Number): String
        }
        public trait ILanguageServiceShimHost : ILogger {
            public fun getCompilationSettings(): String
            public fun getScriptFileNames(): String
            public fun getScriptVersion(fileName: String): Number
            public fun getScriptIsOpen(fileName: String): Boolean
            public fun getScriptByteOrderMark(fileName: String): Number
            public fun getScriptSnapshot(fileName: String): IScriptSnapshotShim
            public fun resolveRelativePath(path: String, directory: String): String
            public fun fileExists(path: String): Boolean
            public fun directoryExists(path: String): Boolean
            public fun getParentDirectory(path: String): String
            public fun getDiagnosticsObject(): ILanguageServicesDiagnostics
            public fun getLocalizedDiagnosticMessages(): String
        }
        public trait IShimFactory {
            public fun registerShim(shim: IShim)
            public fun unregisterShim(shim: IShim)
        }
        public trait IShim {
            public fun dispose(dummy: Any)
        }
        public open class ShimBase(factory: IShimFactory) : IShim {
            public open var factory: Any = noImpl
            override fun dispose(dummy: Any): Unit = noImpl
        }
        public trait ILanguageServiceShim : IShim {
            public var languageService: ILanguageService
            override fun dispose(dummy: Any)
            public fun refresh(throwOnError: Boolean)
            public fun cleanupSemanticCache()
            public fun getSyntacticDiagnostics(fileName: String): String
            public fun getSemanticDiagnostics(fileName: String): String
            public fun getCompilerOptionsDiagnostics(): String
            public fun getCompletionsAtPosition(fileName: String, position: Number, isMemberCompletion: Boolean): String
            public fun getCompletionEntryDetails(fileName: String, position: Number, entryName: String): String
            public fun getTypeAtPosition(fileName: String, position: Number): String
            public fun getNameOrDottedNameSpan(fileName: String, startPos: Number, endPos: Number): String
            public fun getBreakpointStatementAtPosition(fileName: String, position: Number): String
            public fun getSignatureAtPosition(fileName: String, position: Number): String
            public fun getDefinitionAtPosition(fileName: String, position: Number): String
            public fun getReferencesAtPosition(fileName: String, position: Number): String
            public fun getOccurrencesAtPosition(fileName: String, position: Number): String
            public fun getImplementorsAtPosition(fileName: String, position: Number): String
            public fun getNavigateToItems(searchValue: String): String
            public fun getScriptLexicalStructure(fileName: String): String
            public fun getOutliningRegions(fileName: String): String
            public fun getBraceMatchingAtPosition(fileName: String, position: Number): String
            public fun getIndentationAtPosition(fileName: String, position: Number, options: String): String
            public fun getFormattingEditsForRange(fileName: String, minChar: Number, limChar: Number, options: String): String
            public fun getFormattingEditsForDocument(fileName: String, minChar: Number, limChar: Number, options: String): String
            public fun getFormattingEditsOnPaste(fileName: String, minChar: Number, limChar: Number, options: String): String
            public fun getFormattingEditsAfterKeystroke(fileName: String, position: Number, key: String, options: String): String
            public fun getEmitOutput(fileName: String): String
        }
        public open class LanguageServiceShimHostAdapter(shimHost: ILanguageServiceShimHost) : ILanguageServiceHost {
            public open var shimHost: Any = noImpl
            override fun information(): Boolean = noImpl
            override fun debug(): Boolean = noImpl
            override fun warning(): Boolean = noImpl
            override fun error(): Boolean = noImpl
            override fun fatal(): Boolean = noImpl
            override fun log(s: String): Unit = noImpl
            override fun getCompilationSettings(): CompilationSettings = noImpl
            override fun getScriptFileNames(): Array<String> = noImpl
            override fun getScriptSnapshot(fileName: String): IScriptSnapshot = noImpl
            override fun getScriptVersion(fileName: String): Number = noImpl
            override fun getScriptIsOpen(fileName: String): Boolean = noImpl
            override fun getScriptByteOrderMark(fileName: String): ByteOrderMark = noImpl
            override fun getDiagnosticsObject(): ILanguageServicesDiagnostics = noImpl
            override fun getLocalizedDiagnosticMessages(): Any = noImpl
            override fun resolveRelativePath(path: String, directory: String): String = noImpl
            override fun fileExists(path: String): Boolean = noImpl
            override fun directoryExists(path: String): Boolean = noImpl
            override fun getParentDirectory(path: String): String = noImpl
        }
        public fun simpleForwardCall(logger: ILogger, actionDescription: String, action: () -> Any): Any = noImpl
        public fun forwardJSONCall(logger: ILogger, actionDescription: String, action: () -> Any): String = noImpl
        public open class LanguageServiceShim(factory: IShimFactory, host: ILanguageServiceShimHost, languageService: ILanguageService) : ShimBase(noImpl), ILanguageServiceShim {
            public open var host: Any = noImpl
            override var languageService: ILanguageService = noImpl
            public open var logger: Any = noImpl
            public open fun forwardJSONCall(actionDescription: String, action: () -> Any): String = noImpl
            override fun dispose(dummy: Any): Unit = noImpl
            override fun refresh(throwOnError: Boolean): Unit = noImpl
            override fun cleanupSemanticCache(): Unit = noImpl
            public open fun realizeDiagnosticWithFileName(diagnostic: Any): Unit = noImpl
            override fun getSyntacticDiagnostics(fileName: String): String = noImpl
            override fun getSemanticDiagnostics(fileName: String): String = noImpl
            override fun getCompilerOptionsDiagnostics(): String = noImpl
            override fun getTypeAtPosition(fileName: String, position: Number): String = noImpl
            override fun getNameOrDottedNameSpan(fileName: String, startPos: Number, endPos: Number): String = noImpl
            override fun getBreakpointStatementAtPosition(fileName: String, position: Number): String = noImpl
            override fun getSignatureAtPosition(fileName: String, position: Number): String = noImpl
            override fun getDefinitionAtPosition(fileName: String, position: Number): String = noImpl
            override fun getBraceMatchingAtPosition(fileName: String, position: Number): String = noImpl
            override fun getIndentationAtPosition(fileName: String, position: Number, options: String): String = noImpl
            override fun getReferencesAtPosition(fileName: String, position: Number): String = noImpl
            override fun getOccurrencesAtPosition(fileName: String, position: Number): String = noImpl
            override fun getImplementorsAtPosition(fileName: String, position: Number): String = noImpl
            override fun getCompletionsAtPosition(fileName: String, position: Number, isMemberCompletion: Boolean): String = noImpl
            override fun getCompletionEntryDetails(fileName: String, position: Number, entryName: String): String = noImpl
            override fun getFormattingEditsForRange(fileName: String, minChar: Number, limChar: Number, options: String): String = noImpl
            override fun getFormattingEditsForDocument(fileName: String, minChar: Number, limChar: Number, options: String): String = noImpl
            override fun getFormattingEditsOnPaste(fileName: String, minChar: Number, limChar: Number, options: String): String = noImpl
            override fun getFormattingEditsAfterKeystroke(fileName: String, position: Number, key: String, options: String): String = noImpl
            override fun getNavigateToItems(searchValue: String): String = noImpl
            override fun getScriptLexicalStructure(fileName: String): String = noImpl
            override fun getOutliningRegions(fileName: String): String = noImpl
            override fun getEmitOutput(fileName: String): String = noImpl
            public open fun _navigateToItemsToString(items: Any): Unit = noImpl
            public class object {
                public fun realizeDiagnosticCategory(category: Any): Unit = noImpl
                public fun realizeDiagnostic(diagnostic: Any): Unit = noImpl
            }
        }
        public open class ClassifierShim(factory: IShimFactory, host: IClassifierHost) : ShimBase(noImpl) {
            public open var host: IClassifierHost = noImpl
            public open var classifier: Classifier = noImpl
            public open fun getClassificationsForLine(text: String, lexState: EndOfLineState): String = noImpl
        }
        public open class CoreServicesShim(factory: IShimFactory, host: ICoreServicesHost) : ShimBase(noImpl) {
            public open var host: ICoreServicesHost = noImpl
            public open var logger: ILogger = noImpl
            public open var services: CoreServices = noImpl
            public open fun forwardJSONCall(actionDescription: Any, action: Any): Unit = noImpl
            public open fun getPreProcessedFileInfo(fileName: String, sourceText: IScriptSnapshot): String = noImpl
            public open fun getDefaultCompilationSettings(): String = noImpl
            public open fun dumpMemory(dummy: Any): String = noImpl
            public open fun getMemoryInfo(dummy: Any): String = noImpl
        }
        public open class OutliningElementsCollector : DepthLimitedWalker(noImpl) {
            public open var inObjectLiteralExpression: Any = noImpl
            public open var elements: Any = noImpl
            override fun visitClassDeclaration(node: ClassDeclarationSyntax): Unit = noImpl
            override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Unit = noImpl
            override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Unit = noImpl
            override fun visitEnumDeclaration(node: EnumDeclarationSyntax): Unit = noImpl
            override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Unit = noImpl
            override fun visitFunctionExpression(node: FunctionExpressionSyntax): Unit = noImpl
            override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Unit = noImpl
            override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Unit = noImpl
            override fun visitGetAccessor(node: GetAccessorSyntax): Unit = noImpl
            override fun visitSetAccessor(node: SetAccessorSyntax): Unit = noImpl
            override fun visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): Unit = noImpl
            public open fun addOutlineRange(node: Any, startElement: Any, endElement: Any): Unit = noImpl
            public class object {
                public var MaximumDepth: Any = noImpl
                public fun collectElements(node: SourceUnitSyntax): Array<TextSpan> = noImpl
            }
        }
        public open class Indenter {
            public class object {
                public fun getIndentation(node: SourceUnitSyntax, soruceText: IScriptSnapshot, position: Number, editorOptions: EditorOptions): Number = noImpl
                public fun belongsToBracket(sourceText: Any, token: Any, position: Any): Unit = noImpl
                public fun isInContainerNode(parent: Any, element: Any): Unit = noImpl
                public fun getCustomListIndentation(list: Any, element: Any): Unit = noImpl
                public fun getListItemIndentation(list: Any, elementIndex: Any): Unit = noImpl
            }
        }
        module
        public object Breakpoints {
            public fun getBreakpointLocation(syntaxTree: SyntaxTree, askedPos: Number): SpanInfo = noImpl
        }
        public open class GetScriptLexicalStructureWalker(fileName: String) : PositionTrackingWalker() {
            public open var fileName: Any = noImpl
            public open var nameStack: Any = noImpl
            public open var kindStack: Any = noImpl
            public open var currentMemberVariableDeclaration: Any = noImpl
            public open var currentVariableStatement: Any = noImpl
            public open var currentInterfaceDeclaration: Any = noImpl
            public open var parentScopes: Any = noImpl
            public open var currentScope: Any = noImpl
            public open fun createScope(): Unit = noImpl
            public open fun pushNewContainerScope(containerName: Any, kind: Any): Unit = noImpl
            public open fun popScope(): Unit = noImpl
            public open fun collectItems(items: Any, scope: Any? = null): Unit = noImpl
            public open fun createItem(node: Any, modifiers: Any, kind: Any, name: Any): Unit = noImpl
            public open fun addAdditionalSpan(node: Any, key: Any): Unit = noImpl
            public open fun getKindModifiers(modifiers: Any): Unit = noImpl
            override fun visitModuleDeclaration(node: ModuleDeclarationSyntax): Unit = noImpl
            public open fun visitModuleDeclarationWorker(node: Any, names: Any, nameIndex: Any): Unit = noImpl
            public open fun getModuleNames(node: Any): Unit = noImpl
            public open fun getModuleNamesHelper(name: Any, result: Any): Unit = noImpl
            override fun visitClassDeclaration(node: ClassDeclarationSyntax): Unit = noImpl
            override fun visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): Unit = noImpl
            override fun visitObjectType(node: ObjectTypeSyntax): Unit = noImpl
            override fun visitEnumDeclaration(node: EnumDeclarationSyntax): Unit = noImpl
            override fun visitConstructorDeclaration(node: ConstructorDeclarationSyntax): Unit = noImpl
            override fun visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): Unit = noImpl
            override fun visitGetAccessor(node: GetAccessorSyntax): Unit = noImpl
            override fun visitSetAccessor(node: SetAccessorSyntax): Unit = noImpl
            override fun visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): Unit = noImpl
            override fun visitVariableStatement(node: VariableStatementSyntax): Unit = noImpl
            override fun visitVariableDeclarator(node: VariableDeclaratorSyntax): Unit = noImpl
            override fun visitIndexSignature(node: IndexSignatureSyntax): Unit = noImpl
            override fun visitEnumElement(node: EnumElementSyntax): Unit = noImpl
            override fun visitCallSignature(node: CallSignatureSyntax): Unit = noImpl
            override fun visitConstructSignature(node: ConstructSignatureSyntax): Unit = noImpl
            override fun visitMethodSignature(node: MethodSignatureSyntax): Unit = noImpl
            override fun visitPropertySignature(node: PropertySignatureSyntax): Unit = noImpl
            override fun visitFunctionDeclaration(node: FunctionDeclarationSyntax): Unit = noImpl
            override fun visitBlock(node: BlockSyntax): Unit = noImpl
            override fun visitIfStatement(node: IfStatementSyntax): Unit = noImpl
            override fun visitExpressionStatement(node: ExpressionStatementSyntax): Unit = noImpl
            override fun visitThrowStatement(node: ThrowStatementSyntax): Unit = noImpl
            override fun visitReturnStatement(node: ReturnStatementSyntax): Unit = noImpl
            override fun visitSwitchStatement(node: SwitchStatementSyntax): Unit = noImpl
            override fun visitWithStatement(node: WithStatementSyntax): Unit = noImpl
            override fun visitTryStatement(node: TryStatementSyntax): Unit = noImpl
            override fun visitLabeledStatement(node: LabeledStatementSyntax): Unit = noImpl
            public class object {
                public fun getListsOfAllScriptLexicalStructure(items: Array<NavigateToItem>, fileName: String, unit: SourceUnitSyntax): Unit = noImpl
            }
        }
        public fun copyDataObject(dst: Any, src: Any): Any = noImpl
        public open class TypeScriptServicesFactory : IShimFactory {
            public open var _shims: Any = noImpl
            public open fun createPullLanguageService(host: ILanguageServiceHost): ILanguageService = noImpl
            public open fun createLanguageServiceShim(host: ILanguageServiceShimHost): ILanguageServiceShim = noImpl
            public open fun createClassifier(host: IClassifierHost): Classifier = noImpl
            public open fun createClassifierShim(host: IClassifierHost): ClassifierShim = noImpl
            public open fun createCoreServices(host: ICoreServicesHost): CoreServices = noImpl
            public open fun createCoreServicesShim(host: ICoreServicesHost): CoreServicesShim = noImpl
            public open fun close(): Unit = noImpl
            override fun registerShim(shim: IShim): Unit = noImpl
            override fun unregisterShim(shim: IShim): Unit = noImpl
        }
        public open class BraceMatcher {
            public class object {
                public fun getMatchSpans(syntaxTree: SyntaxTree, position: Number): Array<TextSpan> = noImpl
                public fun getMatchingCloseBrace(currentToken: Any, position: Any, result: Any): Unit = noImpl
                public fun getMatchingOpenBrace(currentToken: Any, position: Any, result: Any): Unit = noImpl
                public fun getMatchingCloseBraceTokenKind(positionedElement: Any): Unit = noImpl
                public fun getMatchingOpenBraceTokenKind(positionedElement: Any): Unit = noImpl
            }
        }
    }
}
native
public open class Enumerator(o: Any) {
    public open fun atEnd(): Boolean = noImpl
    public open fun moveNext(): Boolean = noImpl
    public open fun item(): Any = noImpl
}
native
public trait `T$1` {
    public var recursive: Boolean?// = noImpl
}
native
public trait `T$2` {
    public var lineStarts: Array<Number>
    public var length: Number
}
native
public open class FormattingOptions(useTabs: Boolean, spacesPerTab: Number, indentSpaces: Number, newLineCharacter: String) {
    public open var useTabs: Boolean = noImpl
    public open var spacesPerTab: Number = noImpl
    public open var indentSpaces: Number = noImpl
    public open var newLineCharacter: String = noImpl
    public class object {
        public var defaultOptions: FormattingOptions = noImpl
    }
}
native
public trait `T$3` {
    public var allowAutomaticSemicolonInsertion: Boolean
}
native
public trait `T$4` {
    public var value: Number
    public var rest: String
}
native
public trait `T$5` {
    public var importList: String
    public var dependencyList: String
}
native
public trait `T$6` {
    public var stateWhenStartedWalkingTypes1: TypeScript.EnclosingTypeWalkerState
    public var stateWhenStartedWalkingTypes2: TypeScript.EnclosingTypeWalkerState
}
native
public trait `T$7` {
    public var enclosingTypeWalkerState1: TypeScript.EnclosingTypeWalkerState
    public var enclosingTypeWalkerState2: TypeScript.EnclosingTypeWalkerState
}
native
public trait `T$8` {
    public var indexSigs1: TypeScript.IndexSignatureInfo
    public var indexSigs2: TypeScript.IndexSignatureInfo
}
native
public trait `T$9` {
    public var actualText: String
    public var memberName: String
}
native
public trait `T$10` {
    public var signature: TypeScript.PullSignatureSymbol
    public var allSignatures: Array<TypeScript.PullSignatureSymbol>
}
native
public trait `T$11` {
    public var getter: TypeScript.GetAccessor
    public var setter: TypeScript.SetAccessor
}
native
public trait `T$12` {
    public open fun invoke(context: TypeScript.Services.Formatting.FormattingContext): Boolean
}
native
public var debugObjectHost: Any = noImpl
module
public object typescript-services {

}
